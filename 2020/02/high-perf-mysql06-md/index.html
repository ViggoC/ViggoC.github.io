<!DOCTYPE html>
<html lang="default">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://viggoc.github.io').hostname,
    root: '/',
    scheme: 'Mist',
    version: '7.7.1',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="表结构优化、索引优化、查询优化缺一不可，需要齐头并进。  查询速度为什么会变慢 查询需要在不同的地方花费时间，包括网络，CPU 计算，生成统计信息和执行计划，锁等待等操作，尤其是底层存储引擎检索数据，这些检索需要内存操作、CPU 操作和内存不足时的 IO 操作。  慢查询基础：优化数据访问 分析步骤  确认应用程序是否检索大量不必要的的数据，太多行或太多列。 确认 MySQL 服务器层是否在分析大">
<meta property="og:type" content="article">
<meta property="og:title" content="查询性能优化">
<meta property="og:url" content="https://viggoc.github.io/2020/02/high-perf-mysql06-md/index.html">
<meta property="og:site_name" content="VC&#39; Blog">
<meta property="og:description" content="表结构优化、索引优化、查询优化缺一不可，需要齐头并进。  查询速度为什么会变慢 查询需要在不同的地方花费时间，包括网络，CPU 计算，生成统计信息和执行计划，锁等待等操作，尤其是底层存储引擎检索数据，这些检索需要内存操作、CPU 操作和内存不足时的 IO 操作。  慢查询基础：优化数据访问 分析步骤  确认应用程序是否检索大量不必要的的数据，太多行或太多列。 确认 MySQL 服务器层是否在分析大">
<meta property="og:image" content="https://i.loli.net/2020/02/13/wi3ozX8YHSvcpex.png">
<meta property="og:image" content="https://i.loli.net/2020/02/13/8xDFghPGLit1Wp9.png">
<meta property="og:image" content="https://i.loli.net/2020/02/16/kAuNf25xScyZL9e.png">
<meta property="article:published_time" content="2020-02-13T05:21:55.000Z">
<meta property="article:modified_time" content="2020-03-16T13:22:23.038Z">
<meta property="article:author" content="VC">
<meta property="article:tag" content="mysql">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/02/13/wi3ozX8YHSvcpex.png">

<link rel="canonical" href="https://viggoc.github.io/2020/02/high-perf-mysql06-md/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>查询性能优化 | VC' Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">VC' Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="Searching..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="default">
    <link itemprop="mainEntityOfPage" href="https://viggoc.github.io/2020/02/high-perf-mysql06-md/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="VC">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="VC' Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          查询性能优化
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-13 13:21:55" itemprop="dateCreated datePublished" datetime="2020-02-13T13:21:55+08:00">2020-02-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-16 21:22:23" itemprop="dateModified" datetime="2020-03-16T21:22:23+08:00">2020-03-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/database/" itemprop="url" rel="index">
                    <span itemprop="name">database</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2020/02/high-perf-mysql06-md/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/02/high-perf-mysql06-md/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>表结构优化、索引优化、查询优化缺一不可，需要齐头并进。</p>
<h2 id="查询速度为什么会变慢"><a class="markdownIt-Anchor" href="#查询速度为什么会变慢"></a> 查询速度为什么会变慢</h2>
<p>查询需要在不同的地方花费时间，包括网络，CPU 计算，生成统计信息和执行计划，锁等待等操作，尤其是底层存储引擎检索数据，这些检索需要内存操作、CPU 操作和内存不足时的 IO 操作。</p>
<h2 id="慢查询基础优化数据访问"><a class="markdownIt-Anchor" href="#慢查询基础优化数据访问"></a> 慢查询基础：优化数据访问</h2>
<p>分析步骤</p>
<ol>
<li>确认应用程序是否检索大量不必要的的数据，太多行或太多列。</li>
<li>确认 MySQL 服务器层是否在分析大量不必要的数据行。</li>
</ol>
<h3 id="是否向数据库请求了多余的数据"><a class="markdownIt-Anchor" href="#是否向数据库请求了多余的数据"></a> 是否向数据库请求了多余的数据</h3>
<ul>
<li>
<p>查询不需要的记录<br />
使用 SELECT 查询所有结果，获取前面的 N 行后关闭，实际上 MySQL 已经查询出全部结果。需要多少查多少，用 LIMIT 进行限制。</p>
</li>
<li>
<p>取出全部列<br />
不要使用 <code>SELECT * FROM a INNER JOIN b INNER JOIN C;</code>这样的语句。很多时候取出全部列是不必要的。并且，取出全部列会让优化器无法完成索引覆盖这类优化，还会为服务器带来额外的 IO、内存和 CPU 的消耗。<br />
有时候出于开发效率，应用程序可以通过缓存进行复用等角度也可以查询这些多余的数据，需要进行权衡。</p>
</li>
<li>
<p>重复查询相同的数据<br />
利用缓存，减少重复查询。</p>
</li>
</ul>
<a id="more"></a>
<h3 id="mysql-是否扫描额外的记录"><a class="markdownIt-Anchor" href="#mysql-是否扫描额外的记录"></a> MySQL 是否扫描额外的记录</h3>
<p>衡量查询开销的三个指标：</p>
<ul>
<li>响应时间</li>
<li>扫描的行数</li>
<li>返回的行数</li>
</ul>
<p><strong>响应时间</strong> = 服务时间 + 排队时间。服务时间是数据库处理查询真正花的时间。排队时间是为了等待某些资源花费的时间——可能是 IO，也可能是锁等等。可以使用“快速上限估计法”估算查询响应时间：了解一个查询需要哪些索引以及它的执行计划，然后计算大概需要多少个顺序和随机 IO，乘以其在具体硬件条件下一次 IO 消耗的时间。</p>
<p><strong>扫描的行数和返回的行数</strong>对查询速度的影响很大。但并不是所有的行的访问代价都是相同的，较短的行的访问速度快，内存中的行比磁盘中的行访问速度快。扫描行与返回行的比值通常很小，一般在 1:1 和 10:1 之间。</p>
<p>MySQL 中有好几种<strong>访问方式</strong>可以返回一行结果，有些要扫描很多行，有些甚至无需扫描行。<br />
EXPLAIN 语句中的 type 列反应了<strong>访问类型</strong>。速度从慢到快，扫描行数从多到少分别是：</p>
<ul>
<li>全表扫描</li>
<li>索引扫描</li>
<li>范围扫描</li>
<li>唯一索引查询</li>
<li>常数引用</li>
</ul>
<p>一般 MySQL 能使用如下三种方式应用 WHERE 条件，从好到坏依次为：</p>
<ul>
<li>在索引中使用 WHERE 语句过滤不匹配的记录。（在存储引擎层完成）</li>
<li>使用索引覆盖扫描（在 Extra 列中出现 Using index）来返回记录，直接从索引中过滤不需要的记录，并返回命中的结果，在 MySQL 服务器完成，但无须回表查询。</li>
<li>在数据表中返回数据，然后过滤不满足条件的记录（在 Extra 列中出现 Using Where）。在 MySQL 服务器完成，先从数据表读出数据然后过滤。</li>
</ul>
<p>如果发现查询需要扫描大量的数据，但只返回很少的行，可以尝试一下技巧：</p>
<ul>
<li>使用索引覆盖扫描，把需要的列都放到索引中</li>
<li>改变表结构，如使用单独的汇总表</li>
<li>重写这个复杂的查询，让优化器能以更优化的方式执行。</li>
</ul>
<h2 id="重构查询的方式"><a class="markdownIt-Anchor" href="#重构查询的方式"></a> 重构查询的方式</h2>
<h3 id="一个复杂查询还是多个简单查询"><a class="markdownIt-Anchor" href="#一个复杂查询还是多个简单查询"></a> 一个复杂查询还是多个简单查询</h3>
<p>传统的实现中强调数据库完成尽可能多的工作，其逻辑在于认为网络通信<br />
查询解析和优化是一件代价很高的事情。但这对于 MySQL 不适用，MySQL 在设计上让连接和断开链接都很轻量，对小结果集友好。</p>
<p>在其他条件相同的时候，使用尽可能少的查询更有利。但有的时候，将一个大查询分解成为多个小查询是必要的。</p>
<h3 id="切分查询"><a class="markdownIt-Anchor" href="#切分查询"></a> 切分查询</h3>
<p>如定期删除数据时，用一个大的语句一次性完成需要锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 大查询</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> message <span class="keyword">WHERE</span> created &lt; DATA_SUB(<span class="keyword">NOW</span>(), INTERBAL <span class="number">3</span> <span class="keyword">MONTH</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 小查询 一次删除一万条</span></span><br><span class="line">rows_affected = 0</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    rows_affected = do_query(</span><br><span class="line">        <span class="string">"DELETE FROM message WHERE created &lt; DATA_SUB(NOW(), INTERBAL 3 MONTH) </span></span><br><span class="line"><span class="string">        LIMIT 10000"</span></span><br><span class="line">    ) </span><br><span class="line">&#125; <span class="keyword">while</span> rows_affected &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h3 id="分解关联查询"><a class="markdownIt-Anchor" href="#分解关联查询"></a> 分解关联查询</h3>
<p>分解关联查询将关联操作转移到应用程序中，优势如下：</p>
<ul>
<li>让缓存的效率更高。很多应用程序会缓存单表查询的结果进行复用。另外，对于 MySQL 的查询缓存（query cacheA）来说，关联中的表发生了变化就无法使用缓存了，拆分后如果某个表很少改变，那就可以重复利用查询缓存。</li>
<li>单个查询减少锁的竞争。</li>
<li>在应用层关联更容易对数据库进行拆分，更容易提高性能和扩展性</li>
<li>拆分查询有时可以指定查询条件中的查询顺序（使用 IN()），提高效率</li>
<li>减少冗余记录的查询</li>
<li>拆分后相当于在应用中实现了哈希关联，而不是使用嵌套循环关联（<strong>MySQL 新版本中已经实现了哈希关联</strong>）</li>
</ul>
<h2 id="执行查询的基础"><a class="markdownIt-Anchor" href="#执行查询的基础"></a> 执行查询的基础</h2>
<p><img src="https://i.loli.net/2020/02/13/wi3ozX8YHSvcpex.png" alt="" /></p>
<h3 id="mysql-客户端服务器通信协议"><a class="markdownIt-Anchor" href="#mysql-客户端服务器通信协议"></a> MySQL 客户端/服务器通信协议</h3>
<p>MySQL 客户端和服务器之间的通信协议是“半双工”的。发送和接受无法同时进行，无法也无须将一个消息切成小块独立发送。</p>
<p>这种协议让通信简单快速，也从很多地方限制了 MySQL。一个明显的限制是无法进行流量控制，一段发送的消息全部发完另一端才能响应。多数连接 MySQL 的库函数可以获取全部结果难道缓存中或逐行获取数据。默认一般是全部获取到内存中。MySQL 通常要等所有数据发送完成后才能释放资源，接收全部数据并缓存可以尽早释放相应的资源。对于很大的查询结果集，为了减少内存的消耗可以不缓存而直接处理，但相应的服务器被该资源长时间占用。</p>
<p>一个 MySQL 连接为一个线程，使用 <code>SHOW FULL PROCESSLIST;</code> 命令可以查询线程状态。</p>
<h3 id="查询缓存-query-cache"><a class="markdownIt-Anchor" href="#查询缓存-query-cache"></a> 查询缓存 Query Cache</h3>
<p>如果查询缓存是打开的，MySQL 会优先检查是否命中缓存中的数据。这个检查通过一个对大小写敏感的哈希查找实现，即使有一个字节不同（包括注释和空格）。</p>
<p>如果命中了查询缓存，会检查用户权限，通过则直接从缓存中获取结果。</p>
<h3 id="优化查询处理"><a class="markdownIt-Anchor" href="#优化查询处理"></a> 优化查询处理</h3>
<p>将一个 SQL 转换为一个执行计划包括几个子阶段：解析 SQL，预处理，优化 SQL 执行计划。</p>
<p>语法解析器对语句进行语法验证，生成解析树。</p>
<p>预处理器则根据一些 MySQL 规则进一步检查解析树是否合法，如检查数据表和列是否存在，名字和别名是否有歧义。然后进行权限验证。</p>
<p>优化器将检查合法的语法树转化为执行计划。MySQL 使用基于成本的优化器。最初，成本的最小单位是随机读取一个 4K 数据页的成本，后来成本计算公式变得更加复杂，并引入了一些因子来进行估算，如执行一次 WHERE 比较的成本。可以通过 <code>SHOW STATUS LIKE 'Last_query_cost';</code> 得知上条语句的查询成本。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;  SELECT COUNT(*) FROM sakila.film_actor;</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">| count(*) |</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">|     5462 |</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">&gt; <span class="keyword">SHOW</span> <span class="keyword">STATUS</span> <span class="keyword">LIKE</span> <span class="string">'Last_query_cost'</span>;</span><br><span class="line">+<span class="comment">-----------------+-------------+</span></span><br><span class="line">| Variable_name   | Value       |</span><br><span class="line">+<span class="comment">-----------------+-------------+</span></span><br><span class="line">| Last_query_cost | 1104.399000 |</span><br><span class="line">+<span class="comment">-----------------+-------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>结果表示 MySQL 的优化器认为大概需要 1104 个数据页的随机查找才能完成上面的查询。这通过每个表或索引的页面个数、索引的基数、索引和数据行的长度、索引分布情况计算得出。</p>
<p>导致 MySQL 优化器选择错误执行计划的可能原因：</p>
<ul>
<li>统计信息不准确。InnoDB 因其 MVCC 架构不能维护一个数据表的准确行数统计信息。</li>
<li>执行计划中的成本不等于实际成本。收到页面读取方式（顺序/随机）、页面存储位置（内存/磁盘），是否缓存等影响。</li>
<li>成本模型无法真实反应执行速度</li>
<li>MySQL 没有考虑其它并发执行的查询的影响。</li>
<li>有时基于固定规则执行。如存在全文搜索 MATCH() 子句，则存在全文索引的时候就使用全文索引。</li>
<li>不考虑其他不受控制的操作的成本。如执行存储过程或用户自定义函数的成本。</li>
<li>无法估计可能的执行计划</li>
</ul>
<p>MySQL 能处理的优化类型：</p>
<ul>
<li>重新定义关联表的顺序</li>
<li>将外连接转化为内链接</li>
<li>使用等价变换规则。如将 <code>(a&lt;b AND b&lt;c) AND a=5</code> 改写为 <code>b&gt;5 AND b=c AND a=5</code></li>
<li>优化 COUNT(), MIN() 和 MAX()。有时，要找某一列的最小值需要查询 B 树索引的最左端（EXPLAIN 中看到 Select tables optimized away），类似的，最大值找索引的最后一个记录。MyISAM 维护了数据表行数的精确值，对于没有筛选条件的 COUNT(*) 查询可以直接使用。</li>
<li>预估并转化为常数表达式。检测到表达式可以转化为常数时，将其转化。对数学表达式，甚至一个查询（如带 MIN()，MAX()，主键或唯一键查找语句） 都能转化为常数。</li>
<li>覆盖索引扫描</li>
<li>子查询优化</li>
<li>提前终止查询。如 LIMIT 子句或条件不成立返回空结果。</li>
<li>等值传播。如果两个列的值通过等式关联，则把一个列的 WHERE 条件传递到另一个列上使得存储引擎可以更高效地过滤数据。</li>
<li>列表 IN() 的比较。MySQL 中 IN() 并非不等同于多个 OR 条件子句。MySQL 将 IN() 列表中的数据先进行排序，然后通过二分查找的方式确定列表中的值是否满足条件，IN() 列表中有大量取值时速度相较 OR 快很多。</li>
</ul>
<p><strong>嵌套循环关联</strong>：先在一个表中循环取出单条数据，然后再嵌套循环到下一个表中寻找匹配的行，依次下去，直到找到所有表中匹配的行为止。然后根据各个表匹配的行，返回需要的各个列。MySQL 会尝试在最有一个关联表中找到所有匹配的行，然后回溯到上一层关联表继续查找。<br />
本质上，MySQL 对多有类型的查询都以这样的方式运行。FROM 子句遇到子查询是，先执行子查询并将结果放在一个临时表中，然后将临时表当作普通表一样对待。<em>在 MySQL 中每一个查询，每一个片段（包括子查询，甚至单表 select）都可能是关联。</em></p>
<p><strong>执行计划</strong>：MySQL 生成查询的一颗指令树，然后通过存储引擎完成这颗指令树并返回结果。最终的执行计划包含了查询的所有信息。在对某个查询执行<code>EXPLAIN EXTENDED</code>后，再执行<code>SHOW WARNINGS</code>就可以看到重构的查询，其与原查询语义相同，但查询语句可能不同。</p>
<p>MySQL 的执行计划是一颗左侧深度优先的树。<br />
<img src="https://i.loli.net/2020/02/13/8xDFghPGLit1Wp9.png" alt="" /></p>
<p><strong>关联查询优化器</strong>通过评估多表关联时不同顺序的成本来选择代价最小的关联顺序。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 自动优化顺序</span></span><br><span class="line"><span class="keyword">SELECT</span> film.film_id, film.title, film.release_year, actor.actor_id, actor.last_name</span><br><span class="line"><span class="keyword">FROM</span> film</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> film_actor <span class="keyword">USING</span>(film_id)</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> actor <span class="keyword">USING</span>(actor_id)</span><br><span class="line"></span><br><span class="line">+<span class="comment">------+-------------+------------+--------+------------------------+---------------------+---------+---------------------------+------+-------------+</span></span><br><span class="line">| <span class="keyword">id</span>   | select_type | <span class="keyword">table</span>      | <span class="keyword">type</span>   | possible_keys          | <span class="keyword">key</span>                 | key_len | <span class="keyword">ref</span>                       | <span class="keyword">rows</span> | Extra       |</span><br><span class="line">+<span class="comment">------+-------------+------------+--------+------------------------+---------------------+---------+---------------------------+------+-------------+</span></span><br><span class="line">|    <span class="number">1</span> | SIMPLE      | actor      | <span class="keyword">index</span>  | PRIMARY                | idx_actor_last_name | <span class="number">137</span>     | <span class="literal">NULL</span>                      |  <span class="number">200</span> | <span class="keyword">Using</span> <span class="keyword">index</span> |</span><br><span class="line">|    <span class="number">1</span> | SIMPLE      | film_actor | <span class="keyword">ref</span>    | PRIMARY,idx_fk_film_id | PRIMARY             | <span class="number">2</span>       | sakila.actor.actor_id     |   <span class="number">13</span> | <span class="keyword">Using</span> <span class="keyword">index</span> |</span><br><span class="line">|    <span class="number">1</span> | SIMPLE      | film       | eq_ref | PRIMARY                | PRIMARY             | <span class="number">2</span>       | sakila.film_actor.film_id |    <span class="number">1</span> |             |</span><br><span class="line">+<span class="comment">------+-------------+------------+--------+------------------------+---------------------+---------+---------------------------+------+-------------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 固定顺序</span></span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> <span class="keyword">STRAIGHT_JOIN</span> film.film_id, film.title, film.release_year, actor.actor_id, actor.last_name</span><br><span class="line"><span class="keyword">FROM</span> film</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> film_actor <span class="keyword">USING</span>(film_id)</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> actor <span class="keyword">USING</span>(actor_id)</span><br><span class="line"></span><br><span class="line">+<span class="comment">------+-------------+------------+--------+------------------------+----------------+---------+----------------------------+------+-------------+</span></span><br><span class="line">| <span class="keyword">id</span>   | select_type | <span class="keyword">table</span>      | <span class="keyword">type</span>   | possible_keys          | <span class="keyword">key</span>            | key_len | <span class="keyword">ref</span>                        | <span class="keyword">rows</span> | Extra       |</span><br><span class="line">+<span class="comment">------+-------------+------------+--------+------------------------+----------------+---------+----------------------------+------+-------------+</span></span><br><span class="line">|    <span class="number">1</span> | SIMPLE      | film       | <span class="keyword">ALL</span>    | PRIMARY                | <span class="literal">NULL</span>           | <span class="literal">NULL</span>    | <span class="literal">NULL</span>                       | <span class="number">1000</span> |             |</span><br><span class="line">|    <span class="number">1</span> | SIMPLE      | film_actor | <span class="keyword">ref</span>    | PRIMARY,idx_fk_film_id | idx_fk_film_id | <span class="number">2</span>       | sakila.film.film_id        |    <span class="number">2</span> | <span class="keyword">Using</span> <span class="keyword">index</span> |</span><br><span class="line">|    <span class="number">1</span> | SIMPLE      | actor      | eq_ref | PRIMARY                | PRIMARY        | <span class="number">2</span>       | sakila.film_actor.actor_id |    <span class="number">1</span> |             |</span><br><span class="line">+<span class="comment">------+-------------+------------+--------+------------------------+----------------+---------+----------------------------+------+-------------+</span></span><br></pre></td></tr></table></figure>
<p>通过对比两种关联顺序，相比原顺序，优化后的顺序第一个关联表只需要扫描更少的行数，而第二和第三个关联表都是根据索引查询速度很快，因而优化后查询速度更快。通过 Last_query_cost 也可以看出来。</p>
<p>当表的数量过多，需要关联的表超过<code>optimizer_search_depth</code>时，使用 <a href="http://ourmysql.com/archives/1207" target="_blank" rel="noopener">贪婪模式</a> 进行搜索。</p>
<p><strong>排序优化</strong>。从性能角度考虑，应尽可能避免排序或者尽可能避免对大量数据及逆行排序。</p>
<p>当不能使用索引生成排序结果的时候，MySQL 将利用内存或磁盘进行排序（文件排序 filesort）。</p>
<p>内存足够时，MySQL 使用内存进行“快速排序”。内存不够时，将数据分块 ，对每个独立的块使用“快速排序”，结果保存在磁盘上，将排好的块进行合并，返回排序结果。</p>
<p>MySQL 的两种排序算法：</p>
<ul>
<li>两次传输排序：读取行指针和需要排序的行，完成排序后根据结果读取需要的数据行。第二次读取数据行会产生大量的随机 IO，成本高。</li>
<li>单次传输排序：读取查询所需的所有列，然后根据给定列进行排序，最后直接返回排序结果。此算法只需一次顺序 IO 读取所有数据。缺点是，如果需要返回的列非常多、非常大会占用大量的空间，造成浪费。单条排序记录很大所以可能有更多的排序块需要合并。</li>
</ul>
<p>进行文件排序时，占用的临时空间可能很大。MySQL 为每行排序数据分配一个足以容纳其最长字符串的定长空间。</p>
<p>在关联查询中如果需要排序，分两种情况处理。</p>
<ul>
<li>ORDER BY 子句中的所有列来自关联的第一个表。MySQL 在关联第一个变的时候就进行文件排序，Extra 字段为 <code>Using filesort</code>。</li>
<li>除此之外。MySQL 先进行所有关联再进行文件排序。Extra 字段为 <code>Using temporary; Using filesort</code>。</li>
</ul>
<p>LIMIT 子句在排序之后应用。MySQL 5.6 进行了改进，不再对所有结果进行排序，而是根据实际情况，选择抛弃不满足条件的结果，然后进行排序。</p>
<h3 id="查询执行引擎"><a class="markdownIt-Anchor" href="#查询执行引擎"></a> 查询执行引擎</h3>
<p>查询执行过程有大量操作需要通过调用存储引擎的接口（handler API）完成。查询中的每一个表由一个 handler 的实例表示。MySQL 在优化阶段就为每个表创建了一个 handler 实例。</p>
<p>并不是所有操作都由 handler 完成，如果是所有存储引擎共有的特性则由服务器层实现。</p>
<h3 id="返回结果给客户端"><a class="markdownIt-Anchor" href="#返回结果给客户端"></a> 返回结果给客户端</h3>
<p>MySQL 返回结果集是一个增量、逐步返回的过程。如在关联操作中，一旦服务器处理完最后一个关联表，开始生成第一条结果时，MySQL 就可以开始向客户端逐步返回结果集了。这样处理服务器无须存储太多结果，节省内存，另外也能让客户端第一时间获得结果。</p>
<p>结果集的每一行都会以一个满足 MySQL 通信协议的封包发送，再通过 TCP 协议传输，传输过程中可能对 MySQL 的封包进行缓存然后批量传输。</p>
<h2 id="mysql-查询优化器的局限性"><a class="markdownIt-Anchor" href="#mysql-查询优化器的局限性"></a> MySQL 查询优化器的局限性</h2>
<ul>
<li>关联子查询</li>
</ul>
<p>MySQL 的<code>IN(sub query)</code>语句效率不高，可改写为关联查询。<strong>MariaDB 进行了一定的优化，可以跟踪一下。</strong></p>
<p>使用子查询有时候也会比关联查询更加清晰、快速：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 关联查询，需要 DISTICT 剔除重复数据</span></span><br><span class="line"><span class="comment">-- 查询过程中会产生临时中间表，影响效率</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> film.film_id <span class="keyword">FROM</span> film </span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> film_actor <span class="keyword">USING</span>(film_id)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 子查询</span></span><br><span class="line"><span class="keyword">SELECT</span>  film.film_id <span class="keyword">FROM</span> film </span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span>(<span class="keyword">SELECT</span> * <span class="keyword">from</span> film_actor</span><br><span class="line"><span class="keyword">WHERE</span> film.film_id = film_actor.film_id)</span><br></pre></td></tr></table></figure>
<ul>
<li>UNION 的限制</li>
</ul>
<p>有时候 MySQL 无法将限制条件从外层“下推”到内层，使得原本能够限制部分返回结果的条件无法应用到每层查询的优化上。</p>
<p>如当使用 UNION 和 LIMIT 语句，将两个结果集合并后取部分结果集，MySQL 会将两个表的所有结果都存放到临时表中，可以在两个 UNION 子查询中都添加 LIMIT 进行优化。</p>
<ul>
<li>索引合并优化</li>
</ul>
<p>当 WHERE 子句中包含多个复杂条件的时候，MySQL 能够访问单个表的多个索引以合并和交叉过滤的方式定位需要查找的行。、</p>
<ul>
<li>等值传递</li>
</ul>
<p>当有一个很大了 IN() 列表时，等值传播的特性会带来很大开销。</p>
<ul>
<li>并行执行</li>
</ul>
<p>MySQL 无法并行执行查询</p>
<ul>
<li>哈希关联</li>
</ul>
<p>MariaDB 支持 hash join。<br />
MySQL 8.0.18 版本增加了对 hash join 的支持。</p>
<p>版本对照</p>
<table>
<thead>
<tr>
<th>MariaDB</th>
<th>MySQL</th>
</tr>
</thead>
<tbody>
<tr>
<td>10.0-1</td>
<td>5.6</td>
</tr>
<tr>
<td>10.1-3</td>
<td>5.7</td>
</tr>
<tr>
<td>10.3-4</td>
<td>8.0</td>
</tr>
</tbody>
</table>
<ul>
<li>松散索引扫描</li>
</ul>
<p>相当于 Oracle 中的跳跃索引扫描（skip index scan）</p>
<p>MySQL 只在某些特定场景下可以使用松散索引扫描，如在一个分组查询中找到最大（小）值</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> actor_id, <span class="keyword">MAX</span>(film_id)</span><br><span class="line"><span class="keyword">FROM</span> film_actor</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> actor_id</span><br></pre></td></tr></table></figure>
<p>有索引 (actor_id, film_id)，可以跳跃式的扫描每个 actor_id 段的最后一个记录，就是相应的 <code>MAX(film_id)</code>。</p>
<ul>
<li>最大值和最小值优化</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MIN</span>(actor_id) <span class="keyword">FROM</span> actor <span class="keyword">WHERE</span> first_name = <span class="string">'PENELOPE'</span>;</span><br></pre></td></tr></table></figure>
<p>以上查询中，<code>first_name</code>字段没有索引，MySQL 会进行全表扫描。而事实上因为主键 actor_id 是升序排列的，因此在找到第一个满足<code>first_name = 'PENELOPE'</code>的记录时就可以结束查询。因此可以改写为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> actor_id <span class="keyword">FROM</span> actor <span class="keyword">USE</span> <span class="keyword">INDEX</span>(PRIMARY)</span><br><span class="line"><span class="keyword">WHERE</span> first_name = <span class="string">'PENELOPE'</span> <span class="keyword">LIMIT</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>在同一张表上查询和更新</li>
</ul>
<p>MySQL 不允许对同一张表同时进行查询和更新。但是可以通过使用生成表的形式绕过限制，关联时不是关联自身，而是关联临时表。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> tb <span class="keyword">as</span> outer_tb</span><br><span class="line">    <span class="keyword">set</span> cnt = (</span><br><span class="line">        <span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> tb <span class="keyword">AS</span> inner_tb</span><br><span class="line">        <span class="keyword">WHERE</span> inner_tb.type = outer_tb.type</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ERROR 1093 (HY000): Table 'outer_tb' is specified twice, both as a target for 'UPDATE' and as a separate source for data</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> tb</span><br><span class="line">    <span class="keyword">INNER</span> <span class="keyword">JOIN</span>(</span><br><span class="line">        <span class="keyword">SELECT</span> <span class="keyword">type</span>, <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> cnt</span><br><span class="line">        <span class="keyword">FROM</span> tb</span><br><span class="line">        <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">type</span></span><br><span class="line">    ) <span class="keyword">AS</span> der <span class="keyword">USING</span>(<span class="keyword">type</span>)</span><br><span class="line"><span class="keyword">SET</span> tb.cnt = der.cnt;</span><br></pre></td></tr></table></figure>
<ul>
<li>hint
<ul>
<li>HIGH_PRIORITY / LOW_PRIORITY</li>
<li>DELAYED</li>
<li>STRAIGHT_JOIN</li>
<li>SQL_SMALL_RESULT / SQL_BIG_RESULT：前者告诉优化器结果集会很小，可以将结果放在林村中的索引临时表，避免排序操作；后者说明结果集非常大，建议使用磁盘临时表进行排序操作。</li>
<li>SQL_BUFFER_RESULT</li>
<li>SQL_CACHE / SQL_NO_CACHE</li>
<li>SQL_CALC_FOUND_ROWS</li>
<li>FOR UPDATE / LOCK IN SHARE MODE</li>
<li>USE INDEX / IGNORE INDEX / FORCE INDEX</li>
</ul>
</li>
</ul>
<p>因版本而异，详见官方手册</p>
<h2 id="优化特定类型的查询"><a class="markdownIt-Anchor" href="#优化特定类型的查询"></a> 优化特定类型的查询</h2>
<h3 id="优化-count-查询"><a class="markdownIt-Anchor" href="#优化-count-查询"></a> 优化 COUNT() 查询</h3>
<p>在 COUNT() 的括号中指定了列或者列的表达式，则统计的就是这个表达式有值的结果数。</p>
<p>对于没有任何 WHERE 条件的 COUNT(*)，MyISAM 可以直接返回结果。</p>
<p>可以利用 MyISAM 此特性对特定语句进行优化</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 原查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> world.city <span class="keyword">where</span> <span class="keyword">ID</span> &gt; <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 优化 只需要扫描前 5 条就行</span></span><br><span class="line"><span class="keyword">SELECT</span> (<span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> world.city) - <span class="keyword">COUNT</span>(*) </span><br><span class="line"><span class="keyword">FROM</span> world.city <span class="keyword">where</span> <span class="keyword">ID</span> &lt;= <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p>一个查询中统计一个列不同值的数量</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(color = <span class="string">'blue'</span> <span class="keyword">OR</span> <span class="literal">NULL</span>) <span class="keyword">AS</span> blue, <span class="keyword">COUNT</span>(color = <span class="string">'red'</span> <span class="keyword">OR</span> <span class="literal">NULL</span>) <span class="keyword">AS</span> red <span class="keyword">FROM</span> items;</span><br></pre></td></tr></table></figure>
<p>在对精度要求不高的时候可以使用近似值代替</p>
<h3 id="优化关联查询"><a class="markdownIt-Anchor" href="#优化关联查询"></a> 优化关联查询</h3>
<ul>
<li>确保 ON 或者 USING 子句中的列上有索引。创建索引的时候要考虑关联的顺序，当表 A 和表 B 通过列 c 关联的时候，如果优化器的关联顺序是 B、A，则只需要在 A.c（内层）上创建索引。</li>
<li>确保 GROUP BY 和 ORDER BY 中的表达式只涉及一个表中的列，这样 MySQL 才能使用索引进行优化。</li>
<li>升级时注意，关联语法、运算符优先级等可能发生变化。</li>
</ul>
<h3 id="优化-group-by-和-distinct"><a class="markdownIt-Anchor" href="#优化-group-by-和-distinct"></a> 优化 GROUP BY 和 DISTINCT</h3>
<p>在 GROUP BY 子句中使用查找表的标识列分组的效率比其他列高。但当所需字段为非分组列时，部分服务器可能禁用这种写法（ORACLE 是不支持的），强行使用也可能带来问题。</p>
<p>如果没有 ORDER BY 子句显式地指定排序列，当使用 GROUP BY 子句时，结果集会自动按照分组的字段进行排列。如果不关心结果集的顺序，这种默认排序有导致了需要文件排序操作，则可以使用 ORDER BY NULL，让 MySQL 不进行文件排序。</p>
<p>可以直接在 GROUP BY 子句中使用 DESC 或 ASC 指定排序方向。</p>
<p>尽可能将 GROUP BY WITH ROLLUP 的 ROLLUP 部分放在应用程序中进行。</p>
<h3 id="优化-limit-分页"><a class="markdownIt-Anchor" href="#优化-limit-分页"></a> 优化 LIMIT 分页</h3>
<p>分页查询中，非常靠后的页偏移量很大，很多的记录被抛弃，代价很高。</p>
<p>优化此类分页查询的最简单办法就是尽可能地使用索引覆盖扫描，而不是所有的列，然后再进行一次关联操作返回需要的列。</p>
<p>对于部分情况（主键排序），可以记录上次查询中最后一条记录的 ID 作为下一次查询的条件，避免使用偏移量。如</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> rental</span><br><span class="line"><span class="keyword">WHERE</span> rental_id &lt; <span class="number">16030</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> rental_id <span class="keyword">DESC</span> <span class="keyword">LIMIT</span> <span class="number">20</span>。</span><br></pre></td></tr></table></figure>
<h3 id="优化-sql_calc_found_rows"><a class="markdownIt-Anchor" href="#优化-sql_calc_found_rows"></a> 优化 SQL_CALC_FOUND_ROWS</h3>
<p>分页时可以在 LIMIT 语句中加上 SQL_CALC_FOUND_ROWS hint，可以获得所有满足条件的行数以便计算页数，但事实上它就是通过扫描所有行实现的，因此改提示的代价很高。</p>
<p>实践中可以不显示页数，只显示下一页，假设每页显示 20 条，那么就一次查询 21 条，如果 21 条存在则激活“下一页”按钮。另一种做法是一次缓存较多的数据。</p>
<h3 id="优化-union-查询"><a class="markdownIt-Anchor" href="#优化-union-查询"></a> 优化 UNION 查询</h3>
<p>WHERE、LIMIT、ORDER BY 等子句需要手动“下推”</p>
<p>除非必须消除重复行，否则使用 UNION ALL 避免唯一性检查</p>
<h3 id="使用用户自定义变量"><a class="markdownIt-Anchor" href="#使用用户自定义变量"></a> 使用用户自定义变量</h3>
<p>用户自定义变量是一个用来存储内容的临时容器，在连接 MySQL 的整个过程中都存在。可以使用 SET 和 SELECT 语句来定义：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; SET @one      := 1;</span><br><span class="line">&gt; SET @min_actor:= (SELECT MIN(actor_id) FROM actor);</span><br><span class="line">&gt; SET @last_week:= CURRENT_DATE - INTERVAL 1 WEEK;</span><br></pre></td></tr></table></figure>
<p>然后可以在任何使用表达式的地方使用这些自定义变量。</p>
<p>不能使用用户自定义变量的场景：</p>
<ul>
<li>使用自定义变量的查询无法使用查询缓存。</li>
<li>不能在使用常量或标识符的地方使用自定义变量，如表名、列名和 LIMIT 子句中。</li>
<li>用户自定义变量的生命周期为一个连接，不可以跨连接通信。</li>
<li>如果使用连接池或者持久化连接，自定义变量可能让看起来毫无关系的代码发生交互。</li>
<li>不能显式声明变量类型，其为动态类型。</li>
<li>优化器在某些场景可能会将这些变量优化掉，导致意想不到的错误。</li>
<li>赋值表达式需要使用括号，<code>:=</code>的优先级很低。</li>
<li>使用未定义变量不会报语法错误</li>
</ul>
<p>总之使用时要注意<strong>赋值的顺序和赋值的时间</strong></p>
<p>应用场景：</p>
<ul>
<li>优化排名语句</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> @curr_cnt := <span class="number">0</span> , @prev_cnt := <span class="number">0</span> , @<span class="keyword">rank</span> := <span class="number">0</span>;</span><br><span class="line"><span class="keyword">SELECT</span> actor_id, </span><br><span class="line">    @curr_cnt := cnt <span class="keyword">AS</span> cnt, </span><br><span class="line">    @<span class="keyword">rank</span>     := <span class="keyword">IF</span>(@prev_cnt &lt;&gt; @curr_cnt, @<span class="keyword">rank</span> + <span class="number">1</span>, @<span class="keyword">rank</span>) <span class="keyword">AS</span> <span class="keyword">rank</span>,</span><br><span class="line">    @prev_cnt := @curr_cnt <span class="keyword">AS</span> dummy</span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> actor_id, <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> cnt </span><br><span class="line">    <span class="keyword">FROM</span> sakila.film_actor </span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> actor_id</span><br><span class="line">    <span class="keyword">ORDER</span> <span class="keyword">BY</span> cnt <span class="keyword">DESC</span></span><br><span class="line">    <span class="keyword">LIMIT</span> <span class="number">10</span> </span><br><span class="line">)<span class="keyword">AS</span> der;</span><br></pre></td></tr></table></figure>
<ul>
<li>更新的同时获取数据</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> t1 <span class="keyword">SET</span> lastUpdated = <span class="keyword">NOW</span>() <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">AND</span> @<span class="keyword">now</span> = <span class="keyword">NOW</span>();</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="keyword">now</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>统计更新和插入的数量</li>
</ul>
<p>当使用了 <code>INSERT ON DUPLICATE KEY UPDATE</code>时想知道更新数可以使用</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1(c1, c2) <span class="keyword">VALUES</span>(<span class="number">4</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">1</span>), (<span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">DUPLICATE</span> <span class="keyword">KEY</span> <span class="keyword">UPDATE</span></span><br><span class="line">    c1 = <span class="keyword">VALUES</span>(c1) + (<span class="number">0</span> * (@x := @x + <span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<ul>
<li>确定取值的顺序</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> @<span class="keyword">rownum</span> := <span class="number">0</span>;</span><br><span class="line"><span class="comment">-- where 语句 在 select 之前执行</span></span><br><span class="line"><span class="keyword">SELECT</span> actor_id, @<span class="keyword">rownum</span> := @<span class="keyword">rownum</span> + <span class="number">1</span> <span class="keyword">AS</span> cnt</span><br><span class="line"><span class="keyword">FROM</span> sakila.actor</span><br><span class="line"><span class="keyword">WHERE</span> @<span class="keyword">rownum</span> &lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--  Using where; Using index </span></span><br><span class="line">+<span class="comment">----------+------+</span></span><br><span class="line">| actor_id | cnt  |</span><br><span class="line">+<span class="comment">----------+------+</span></span><br><span class="line">|       58 |    1 |</span><br><span class="line">|       92 |    2 |</span><br><span class="line">+<span class="comment">----------+------+</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> @<span class="keyword">rownum</span> := <span class="number">0</span>;</span><br><span class="line"><span class="comment">-- 让赋值和取值发生在查询的同一个阶段（子句）可结果以上问题</span></span><br><span class="line"><span class="keyword">SELECT</span> actor_id, @<span class="keyword">rownum</span> <span class="keyword">AS</span> cnt</span><br><span class="line"><span class="keyword">FROM</span> sakila.actor</span><br><span class="line"><span class="keyword">WHERE</span> (@<span class="keyword">rownum</span> := @<span class="keyword">rownum</span> + <span class="number">1</span>) &lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Using where; Using index</span></span><br><span class="line">+<span class="comment">----------+------+</span></span><br><span class="line">| actor_id | cnt  |</span><br><span class="line">+<span class="comment">----------+------+</span></span><br><span class="line">|       58 |    1 |</span><br><span class="line">+<span class="comment">----------+------+</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> @<span class="keyword">rownum</span>:=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">SELECT</span> actor_id,first_name, </span><br><span class="line">    @<span class="keyword">rownum</span> <span class="keyword">AS</span> cnt <span class="keyword">FROM</span> sakila.actor <span class="keyword">WHERE</span> (@<span class="keyword">rownum</span> := @<span class="keyword">rownum</span> + <span class="number">1</span>) &lt;= <span class="number">1</span> </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> first_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Using where; Using filesort</span></span><br><span class="line">+<span class="comment">----------+------------+------+</span></span><br><span class="line">| actor_id | first_name | cnt  |</span><br><span class="line">+<span class="comment">----------+------------+------+</span></span><br><span class="line">|        1 | PENELOPE   |  200 |</span><br><span class="line">+<span class="comment">----------+------------+------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 这个语句的执行顺序貌似是 where -&gt; order by -&gt;select</span></span><br><span class="line"><span class="comment">-- @rownum &lt;= 2 会返回三条</span></span><br><span class="line"><span class="comment">-- 子句中表达式的执行可能和子句的执行顺序不一致？</span></span><br><span class="line"><span class="keyword">SET</span> @<span class="keyword">rownum</span> := <span class="number">0</span>;</span><br><span class="line"><span class="keyword">SELECT</span> actor_id,first_name, </span><br><span class="line">    @<span class="keyword">rownum</span> <span class="keyword">AS</span> cnt <span class="keyword">FROM</span> sakila.actor <span class="keyword">WHERE</span> @<span class="keyword">rownum</span> &lt;= <span class="number">1</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> first_name, <span class="keyword">least</span>(<span class="number">0</span>, @<span class="keyword">rownum</span> := @<span class="keyword">rownum</span> +<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Using where; Using temporary; Using filesort</span></span><br><span class="line">+<span class="comment">----------+------------+------+</span></span><br><span class="line">| actor_id | first_name | cnt  |</span><br><span class="line">+<span class="comment">----------+------------+------+</span></span><br><span class="line">|        2 | NICK       |    2 |</span><br><span class="line">|        1 | PENELOPE   |    1 |</span><br><span class="line">+<span class="comment">----------+------------+------+</span></span><br></pre></td></tr></table></figure>
<h4 id="order-by-问题留待讨论"><a class="markdownIt-Anchor" href="#order-by-问题留待讨论"></a> order by 问题留待讨论</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 想法是，当没有 order by 子句时迭代式执行</span></span><br><span class="line"><span class="keyword">for</span> row in table&#123;</span><br><span class="line">    where()</span><br><span class="line">    select()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当有 order by 语句时</span></span><br><span class="line"><span class="keyword">for</span> row in table&#123;</span><br><span class="line">    where()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> row in filtered&#123;</span><br><span class="line">    select()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">order_by()</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/02/16/kAuNf25xScyZL9e.png" alt="MySQL - SQL 语句执行顺序" /></p>
<ul>
<li>lazy UNION</li>
</ul>
<p>当<code>user</code>表找不到数据时，才查询 <code>user_archived</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">GREATEST</span>(@<span class="keyword">found</span> := <span class="number">-1</span>, <span class="keyword">id</span>) <span class="keyword">AS</span> <span class="keyword">id</span>, <span class="string">'user'</span> <span class="keyword">AS</span> which_tbl</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">id</span>, <span class="string">'user_archived'</span></span><br><span class="line">    <span class="keyword">FROM</span> user_archived <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">AND</span> @<span class="keyword">found</span> <span class="keyword">IS</span> <span class="literal">NULL</span></span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="number">1</span>, <span class="string">'reset'</span> <span class="keyword">FROM</span> DUAL <span class="keyword">WHERE</span> (@<span class="keyword">found</span> := <span class="literal">NULL</span>) <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br></pre></td></tr></table></figure>
<h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3>
<p>优化需要三管齐下：不做、少做、快速地做。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/mysql/" rel="tag"># mysql</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/02/high-perf-mysql05-md/" rel="prev" title="创建高性能的索引">
      <i class="fa fa-chevron-left"></i> 创建高性能的索引
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/02/high-perf-mysql06-01/" rel="next" title="查询性能优化-01">
      查询性能优化-01 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#查询速度为什么会变慢"><span class="nav-number">1.</span> <span class="nav-text"> 查询速度为什么会变慢</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#慢查询基础优化数据访问"><span class="nav-number">2.</span> <span class="nav-text"> 慢查询基础：优化数据访问</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#是否向数据库请求了多余的数据"><span class="nav-number">2.1.</span> <span class="nav-text"> 是否向数据库请求了多余的数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mysql-是否扫描额外的记录"><span class="nav-number">2.2.</span> <span class="nav-text"> MySQL 是否扫描额外的记录</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重构查询的方式"><span class="nav-number">3.</span> <span class="nav-text"> 重构查询的方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一个复杂查询还是多个简单查询"><span class="nav-number">3.1.</span> <span class="nav-text"> 一个复杂查询还是多个简单查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#切分查询"><span class="nav-number">3.2.</span> <span class="nav-text"> 切分查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分解关联查询"><span class="nav-number">3.3.</span> <span class="nav-text"> 分解关联查询</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#执行查询的基础"><span class="nav-number">4.</span> <span class="nav-text"> 执行查询的基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#mysql-客户端服务器通信协议"><span class="nav-number">4.1.</span> <span class="nav-text"> MySQL 客户端&#x2F;服务器通信协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查询缓存-query-cache"><span class="nav-number">4.2.</span> <span class="nav-text"> 查询缓存 Query Cache</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#优化查询处理"><span class="nav-number">4.3.</span> <span class="nav-text"> 优化查询处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查询执行引擎"><span class="nav-number">4.4.</span> <span class="nav-text"> 查询执行引擎</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#返回结果给客户端"><span class="nav-number">4.5.</span> <span class="nav-text"> 返回结果给客户端</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mysql-查询优化器的局限性"><span class="nav-number">5.</span> <span class="nav-text"> MySQL 查询优化器的局限性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#优化特定类型的查询"><span class="nav-number">6.</span> <span class="nav-text"> 优化特定类型的查询</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#优化-count-查询"><span class="nav-number">6.1.</span> <span class="nav-text"> 优化 COUNT() 查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#优化关联查询"><span class="nav-number">6.2.</span> <span class="nav-text"> 优化关联查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#优化-group-by-和-distinct"><span class="nav-number">6.3.</span> <span class="nav-text"> 优化 GROUP BY 和 DISTINCT</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#优化-limit-分页"><span class="nav-number">6.4.</span> <span class="nav-text"> 优化 LIMIT 分页</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#优化-sql_calc_found_rows"><span class="nav-number">6.5.</span> <span class="nav-text"> 优化 SQL_CALC_FOUND_ROWS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#优化-union-查询"><span class="nav-number">6.6.</span> <span class="nav-text"> 优化 UNION 查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用用户自定义变量"><span class="nav-number">6.7.</span> <span class="nav-text"> 使用用户自定义变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">6.8.</span> <span class="nav-text"> 总结</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">VC</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">16</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">VC</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://mist.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.7.1
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el: '#valine-comments',
      verify: false,
      notify: false,
      appId: 'N1lbWM73Gja5VWPf0YfwSM0w-9Nh9j0Va',
      appKey: '7NPQ5VnrCiGVu742uhUiL3kO',
      placeholder: "Just go go",
      avatar: 'mm',
      meta: guest,
      pageSize: '10' || 10,
      visitor: false,
      lang: 'en' || 'zh-cn',
      path: location.pathname,
      recordIP: false,
      serverURLs: ''
    });
  }, window.Valine);
});
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</body>
</html>
