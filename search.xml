<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>疫情风险等级爬虫小记</title>
    <url>/2040/04/covid-19-risk/</url>
    <content><![CDATA[<p>近日看到国务院印发的《全国不同风险地区企事业单位复工复产疫情防控措施指南》中提到了低风险，中风险和高风险地区，搜索发现只能通过“国务院客户端微信小程序”以区/县为单位进行查询，想了解一下全国各地的形式需要挨个查询，没有一个可以纵览全局的地图，心血来潮想要自己画一个。</p>
<h2 id="数据源"><a class="markdownIt-Anchor" href="#数据源"></a> 数据源</h2>
<p>网上常见的查询入口都是微信小程序，但是微信小程序相对封闭，咱也不属于数据获取相对不方便，想找个普通的网站服务。经过一番搜索发现国家政务服务平台也提供了一个<a href="http://gjzwfw.www.gov.cn/fwmh/healthCode/front/indexAreaRisk.do" target="_blank" rel="noopener">区/县疫情风险等级查询入口</a>，开干。</p>
<a id="more"></a>
<p>点击进入，虎躯一震，查询一个公开的疫情风险信息竟然还要先注册账户，政府网站的账户不出以外的要把身份信息扒干净。算了，麻利填完，查一个试试。</p>
<p>先查个武汉<br />
<img src="https://i.loli.net/2020/04/12/izbn4Z2PwYHXQro.png" alt="" /></p>
<p>再查个北京<br />
<img src="https://i.loli.net/2020/04/12/kgLre2YwZEcnTDh.png" alt="" /></p>
<h2 id="接口分析"><a class="markdownIt-Anchor" href="#接口分析"></a> 接口分析</h2>
<p>初步判断应该只需要一个地区的编码或者名字就可以查询了，上 <code>F12</code> 一看果然是，post方法需要<code>xzqhdm</code>和<code>Xzqhmc</code>两个参数（<code>BizType</code>应该是固定的查询类别，先不管）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">query</span>(<span class="params">city,cityName</span>)</span>&#123;</span><br><span class="line">		   $.ajax(&#123;</span><br><span class="line">	           url: <span class="string">'/fwmh/healthCode/front/healthQuery.do'</span>,</span><br><span class="line">	           data: &#123;<span class="attr">BizType</span>: <span class="string">"0117"</span>, <span class="attr">Xzqhdm</span>: city, <span class="attr">Xzqhmc</span>: cityName&#125;,</span><br><span class="line">	           type: <span class="string">"post"</span>,</span><br><span class="line">	           crossDomain: <span class="literal">true</span>,</span><br><span class="line">               ...</span><br><span class="line">           &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>翻一翻<code>select</code>控件看看参数要怎么填，应该就是身份证开头的那几位行政区划代码了，名称的格式是<code>省/市/区</code>（不过最后发现了名称参数没啥用，只要代码对了就行）。</p>
<p><img src="https://i.loli.net/2020/04/12/dOSWlweg2caoR8E.png" alt="" /></p>
<p>行政区划代码可以找现成的，也可以从这个网站上爬下来，为了保证数据一致避免不必要的麻烦，也从网站上爬吧。找到相关查询行政区划代码的脚本，发现是通过一定的层级结构查询的，以<code>000000</code>作为<code>pid</code>可以查到所以省，然后再以省的代码查到相应的市，以此类推。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        url: <span class="string">'/fwmh/healthCode/HealthCodeAreaBypParentCode.do'</span>,</span><br><span class="line">        type: <span class="string">"post"</span>,</span><br><span class="line">        crossDomain: <span class="literal">true</span>,</span><br><span class="line">        data: &#123;<span class="attr">code</span>: <span class="string">"000000"</span>&#125;,</span><br><span class="line">        ...</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="编写爬虫"><a class="markdownIt-Anchor" href="#编写爬虫"></a> 编写爬虫</h2>
<p>接口和参数都清楚了，开始写爬虫。导入<code>requests</code>包，定义两个查询接口的地址。查询需要登录，因此还要从浏览器中找到<code>cookies</code>，转换成键值对的格式作为后续请求接口的参数。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">risk_url = <span class="string">"http://gjzwfw.www.gov.cn/fwmh/healthCode/front/healthQuery.do"</span></span><br><span class="line">area_url = <span class="string">"http://gjzwfw.www.gov.cn/fwmh/healthCode/HealthCodeAreaBypParentCode.do"</span></span><br><span class="line"></span><br><span class="line">raw_cookies = <span class="string">'xxxx'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cookies_convert</span><span class="params">(raw_cookies)</span>:</span></span><br><span class="line">    cookies = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> raw_cookies.split(<span class="string">';'</span>):</span><br><span class="line">        key, value = line.split(<span class="string">'='</span>, <span class="number">1</span>)  <span class="comment"># 1代表只分一次，得到两个数据</span></span><br><span class="line">        cookies[key] = value</span><br><span class="line">    <span class="keyword">return</span> cookies</span><br><span class="line"></span><br><span class="line">cookies = cookies_convert(raw_cookies)</span><br></pre></td></tr></table></figure>
<p>查询行政区划代码并保存在’area_map.txt’文件中。<code>area_query</code>负责单次查询的处理，因为网络等各种问题，很可能返回无法正确解析的内容，因此要加一个异常处理，无法解析就重试一次。当然也要限制一下重试的次数，避免掉进死循环。</p>
<p>因为有省/市/区三级，所以获取所有区划代码的<code>get_area_map</code>函数嵌套了好几层，其实也可以通过写成递归的形式简化代码，不过这里就先将就一下吧。</p>
<p>用<code>time.sleep</code>设置一个随机的查询间隔，避免被封。</p>
<p>每查一个就要保存一下，不然遇到网络问题程序崩溃就GG了。实践中还发现这个系统的数据有点问题，有一个压根不存在的行政区划代码，相应的名称为空。为此加一行判断，代码或名称为空的就跳过。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">area_map_file = <span class="string">'area_map.txt'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">area_query</span><span class="params">(area_code, retry=<span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> retry == <span class="number">5</span>:</span><br><span class="line">        print(<span class="string">'Retry too many times! Area code: '</span>, area_code)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    area_resp = requests.post(area_url, &#123;<span class="string">'code'</span>: area_code&#125;, cookies=cookies)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        data = json.loads(area_resp.text)[<span class="string">'result'</span>]</span><br><span class="line">    <span class="keyword">except</span> json.decoder.JSONDecodeError:</span><br><span class="line">        data = area_query(area_code, retry+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_area_map</span><span class="params">()</span>:</span></span><br><span class="line">    area_map = &#123;&#125;</span><br><span class="line">    <span class="keyword">with</span> open(area_map_file, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        area_code = <span class="string">'000000'</span></span><br><span class="line">        prov_data = area_query(area_code)</span><br><span class="line">        <span class="keyword">for</span> povince <span class="keyword">in</span> prov_data:</span><br><span class="line">            prov_name = povince[<span class="string">'region_name'</span>]</span><br><span class="line">            prov_code = povince[<span class="string">'region_code'</span>]</span><br><span class="line">            city_data = area_query(prov_code)</span><br><span class="line">            <span class="keyword">for</span> city <span class="keyword">in</span> city_data:</span><br><span class="line">                city_name = city[<span class="string">'region_name'</span>]</span><br><span class="line">                city_code = city[<span class="string">'region_code'</span>]</span><br><span class="line">                <span class="comment"># 加一个延时，避免查询频率过高被封</span></span><br><span class="line">                time.sleep(random.random())</span><br><span class="line">                country_data = area_query(city_code)</span><br><span class="line">                <span class="keyword">for</span> country <span class="keyword">in</span> country_data:</span><br><span class="line">                    country_name = country[<span class="string">'region_name'</span>]</span><br><span class="line">                    country_code = country[<span class="string">'region_code'</span>]</span><br><span class="line">                    <span class="comment"># 代码或名称为空时跳过</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> (country_name <span class="keyword">and</span> country_code):</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    area_map[country_code] = prov_name + \</span><br><span class="line">                        <span class="string">'/'</span>+city_name+<span class="string">'/'</span>+country_name</span><br><span class="line">                    print(country_code, area_map[country_code])</span><br><span class="line">                    f.write(country_code+<span class="string">'\t'</span>+area_map[country_code]+<span class="string">'\n'</span>)</span><br><span class="line">    <span class="keyword">return</span> area_map</span><br></pre></td></tr></table></figure>
<p>根据行政区划代码查询风险等级的代码也是类似的。既然这么类似，后续也可以考虑从两个函数中抽象出一个带重试的API访问函数。不过总共也才两个函数，也先不优化了，ε=ε=ε=┏(゜ロ゜;)┛</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">query_risk</span><span class="params">(city_code, city_name, retry=<span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> retry == <span class="number">5</span>:</span><br><span class="line">        print(<span class="string">'Retry too many times! Area code: '</span>, city_code)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    city_data = &#123;<span class="string">'BizType'</span>: <span class="string">'0117'</span>,</span><br><span class="line">                 <span class="string">'Xzqhdm'</span>: city_code,</span><br><span class="line">                 <span class="string">'Xzqhmc'</span>: city_name&#125;</span><br><span class="line">    time.sleep(random.random())             </span><br><span class="line">    risk_resp = requests.post(risk_url, city_data, cookies=cookies)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        data = json.loads(risk_resp.text)[<span class="string">'xzqhWarnLv'</span>][<span class="string">'fxdj'</span>]</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        print(<span class="string">'Retry:'</span>, city_code, city_name)</span><br><span class="line">        data = query_risk(city_code,city_name, retry+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure>
<p>函数都定义完了，开始给我爬。</p>
<ol>
<li>先判断保存行政区划代码的文件是否存在，不存在就重新爬一下</li>
<li>读取行政区划代码用于查询风险等级</li>
<li>读取已经查询过的数据，避免重复查询，如果没有历史数据则写入表头</li>
<li>查询并保存各地区的风险水平，有些地方没有提供数据，用-1代替</li>
</ol>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查询行政区划代码和并称并保存</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(area_map_file):</span><br><span class="line">    print(<span class="string">'Area code file does not exist, uncomment the line below to get it.'</span>)</span><br><span class="line">    <span class="comment"># area_map = get_area_map()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取行政区划代码用于查询风险等级</span></span><br><span class="line"><span class="keyword">with</span> open(area_map_file, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    areas = f.readlines()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取已经查询过的数据，避免重复查询</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'risk.csv'</span>, <span class="string">'r+'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> csvfile:</span><br><span class="line">    reader = csv.DictReader(csvfile)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        exist_code = set([row[<span class="string">'code'</span>] <span class="keyword">for</span> row <span class="keyword">in</span> reader])</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="comment"># 第一次要写入表头</span></span><br><span class="line">        writer = csv.writer(csvfile)</span><br><span class="line">        writer.writerow([<span class="string">"code"</span>,<span class="string">"name"</span>,<span class="string">"risk"</span>])</span><br><span class="line">        exist_code = set()</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'risk.csv'</span>, <span class="string">'a+'</span>, newline=<span class="string">''</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> csvfile:</span><br><span class="line">    writer = csv.writer(csvfile)</span><br><span class="line">    <span class="keyword">for</span> i, line <span class="keyword">in</span> enumerate(areas):</span><br><span class="line">        code, name = line.split()</span><br><span class="line">        <span class="comment"># 跳过查询过的地区</span></span><br><span class="line">        <span class="keyword">if</span> code <span class="keyword">in</span> exist_code: <span class="keyword">continue</span></span><br><span class="line">        risk = query_risk(code, name)</span><br><span class="line">        <span class="comment"># 使用 -1 表示未知</span></span><br><span class="line">        <span class="keyword">if</span> risk == <span class="string">'null'</span>: risk = <span class="number">-1</span></span><br><span class="line">        print(str(i)+<span class="string">'/'</span>+str(len(areas)),code,name,risk)</span><br><span class="line">        writer.writerow([code,name,risk])</span><br></pre></td></tr></table></figure>
<h2 id="结果"><a class="markdownIt-Anchor" href="#结果"></a> 结果</h2>
<p>最终爬到2912个区/县的风险等级，其中24个未知，7个为中风险，剩下的全是低风险。</p>
<p><img src="https://i.loli.net/2020/04/12/R9x8HqjnOovuCKd.png" alt="" /></p>
<p>全国形式一片大好，画出来的地图也就是一只绿公鸡，没啥必要，就TJ了，ε=ε=ε=┏(゜ロ゜;)┛</p>
<p>不过还是简单调研了一下，地图绘制相关的包，可以用下面两种方案，下回可以画点其他的。</p>
<ul>
<li>matplotlib + basemap</li>
<li>pyechart.Map</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>可扩展的 MySQL</title>
    <url>/2020/04/high-perf-mysql11/</url>
    <content><![CDATA[<p>在 MySQL 的规模越来越大时，如何保证快速、高效且经济。</p>
<h2 id="什么是可扩展性"><a class="markdownIt-Anchor" href="#什么是可扩展性"></a> 什么是可扩展性</h2>
<p>容易混淆的用词：可扩展性，高可用性，性能。</p>
<p>可扩展性就是能过够通过增加资源提升容量（工作效率）的能力。表明了当需要增加资源以执行更过工作时系统能够划算地提供等同提升（equal bang for the buck）的能力。另一种说法是，可扩展性是当增加资源以处理负载和增加容量时系统能够获得的投入产出比。</p>
<p>大部分系统都没办法做到线性扩展，越高的扩展系数导致越大的线性偏差，最终达到临界点。—— 详见通用可扩展定律（Universal Scalability Law，USL）</p>
<a id="more"></a>
<p><img src="https://i.loli.net/2020/04/05/ZgOSadRsEPBhvVb.png" alt="" /></p>
<p>USL 也可能失效，如 USL 不允许比线性更好的可扩展性，但现实中可能通过增加资源使一部分 IO 密集型工作变成纯内存工作，获得超越线性的性能扩展。还有一些情况，当系统或数据集大小改变时算法的复杂度可能改变。</p>
<h2 id="扩展-mysql"><a class="markdownIt-Anchor" href="#扩展-mysql"></a> 扩展 MySQL</h2>
<ul>
<li>垂直扩展/向上扩展：买更强悍的机器</li>
<li>水平扩展/向外扩展：将任务分配到更多的机器</li>
<li>向内扩展：清理或归档很少或不需要的数据</li>
</ul>
<p>帮助规划可扩展性的问题：</p>
<ul>
<li>应用的功能完成了多少？ 许多可扩展性解决方案可能会导致实现某些功能更加困难。如果应用的某些核心功能还没开始实现很难确定扩展方案。喵，设计和实现相互依赖，只能滚动前进了。</li>
<li>预期的最大负载是多少？ 应用应当在最大负载下也能正常工作。、</li>
<li>如果依赖系统的每个部分来分担负载，在某个部分失效时会发生什么呢？ 如果依赖备库来分担读负载，当其中一个失效时，是否还能正常处理请求？是否需要禁用某些功能？</li>
</ul>
<h3 id="向上扩展"><a class="markdownIt-Anchor" href="#向上扩展"></a> 向上扩展</h3>
<p>理想情况下是计划先行、拥有足够的开发者和预算，但实际情况并非如此。在深入 MySQL 扩展之前可以做一些准备工作：</p>
<ul>
<li>性能优化</li>
<li>购买更强的硬件：这在软件生命周期的早期有效。当前合理的“收益递减点”的机器配置大约是 256GB RAM，32 核以及一个 PCIe flash（存储）驱动。如果继续提升，性价比降低。（注意书的时代背景，数据可能过时）</li>
</ul>
<h3 id="向外扩展"><a class="markdownIt-Anchor" href="#向外扩展"></a> 向外扩展</h3>
<p>向外扩展策略划分为三个部分：复制、拆分以及数据分片。</p>
<p>最常见的做法是通过复制吧数据分发到多个备库，备库用于读扩展。</p>
<p>另一种比较常见的向外扩展方法是将工作负载分布到多个“节点”，一个节点就是一个功能部件，可能是一台服务器，也可以是多台机器构成，多数情况下，一个节点内的所有服务器应该拥有相同的数据。书中推荐把“主-主复制”架构作为一个节点。</p>
<h4 id="按功能拆分"><a class="markdownIt-Anchor" href="#按功能拆分"></a> 按功能拆分</h4>
<p>按功能拆分意味着不同的节点执行不同的任务。但不能通过功能划分无限地扩展，如果一个功能区域被绑定到单个 MySQL 节点，就只能进行垂直扩展。</p>
<p><img src="https://i.loli.net/2020/04/05/4dEwaX3qnUZzFgv.png" alt="" /></p>
<h4 id="数据分片"><a class="markdownIt-Anchor" href="#数据分片"></a> 数据分片</h4>
<p>数据分片是最通用最成功的方法，它将数据分割成小块存储到不同的节点中。</p>
<p>数据分片通常和功能划分结合使用， 部分全局数据（城市列表或登录数据）不会被分片。<br />
<img src="https://i.loli.net/2020/04/05/SXwR3ZDdnyJtT2U.png" alt="" /></p>
<h4 id="选择分区键partitioning-key"><a class="markdownIt-Anchor" href="#选择分区键partitioning-key"></a> 选择分区键（partitioning key）</h4>
<p>一个好的分区键常常是数据库中非常重要的实体的主键。选择分区键时要尽可能跨分片查询，同时要让分片足够小，且分布均匀。</p>
<p><img src="https://i.loli.net/2020/04/05/KNCbY2zWSl5JFr6.png" alt="" /></p>
<h4 id="多个分区键"><a class="markdownIt-Anchor" href="#多个分区键"></a> 多个分区键</h4>
<p>有多个分区键时要设计一定的冗余字段，减少分片查询</p>
<h4 id="跨分片查询"><a class="markdownIt-Anchor" href="#跨分片查询"></a> 跨分片查询</h4>
<p>跨分片查询可以借助汇总表来执行，遍历所以分片来形成汇总表，然后将结果缓存。</p>
<h4 id="分片数据-分片和节点"><a class="markdownIt-Anchor" href="#分片数据-分片和节点"></a> 分片数据、分片和节点</h4>
<p>分片和节点并不一定是一对一的关系，应该近可能让分片的大小比节点容量小，这样就可以在单个节点上存储多个分片。</p>
<p>小的分片更容易管理，在当 100G 的表上增加索引的时间比在 100 个 1G 分片上执行的总时间更长。小分片也更加便于转移。</p>
<h4 id="在节点上部署分片"><a class="markdownIt-Anchor" href="#在节点上部署分片"></a> 在节点上部署分片</h4>
<h4 id="固定分配"><a class="markdownIt-Anchor" href="#固定分配"></a> 固定分配</h4>
<h4 id="动态分配"><a class="markdownIt-Anchor" href="#动态分配"></a> 动态分配</h4>
<h4 id="混合动态分配和固定分配"><a class="markdownIt-Anchor" href="#混合动态分配和固定分配"></a> 混合动态分配和固定分配</h4>
<h4 id="显式分配"><a class="markdownIt-Anchor" href="#显式分配"></a> 显式分配</h4>
<h4 id="分片数据均衡"><a class="markdownIt-Anchor" href="#分片数据均衡"></a> 分片数据均衡</h4>
<h4 id="生成全局唯一-id"><a class="markdownIt-Anchor" href="#生成全局唯一-id"></a> 生成全局唯一 ID</h4>
<h4 id="分片工具"><a class="markdownIt-Anchor" href="#分片工具"></a> 分片工具</h4>
<h3 id="通过多实例扩展"><a class="markdownIt-Anchor" href="#通过多实例扩展"></a> 通过多实例扩展</h3>
<p>不要在一太性能强悍的服务器上只运行一个数据库实例，可以让数据分片足够小，在每台机器上放置多个分片，充分发挥硬件性能。</p>
<h3 id="通过集群扩展"><a class="markdownIt-Anchor" href="#通过集群扩展"></a> 通过集群扩展</h3>
<p>作为关系型数据库，MySQL 本身难以通过集群扩展。目前见到的通常都是将 NoSQL 和 SQL 结合的技术。如 MySQL Cluster（NDB Cluster）并不是一个 SQL 数据库，它是一个可扩展的数据库，有一套独立的 API，但也可以在前端使用 MySQL 存储引擎支持 SQL 查询。</p>
<h3 id="向内扩展"><a class="markdownIt-Anchor" href="#向内扩展"></a> 向内扩展</h3>
<p>这种策略只能作为短期的缓兵之计，难以应对数据的高速增长。</p>
<p>清理数据时应考虑以下几点：</p>
<ul>
<li>对应用的影响：操作数据时平衡归档的行数和事务的大小，避免影响正常业务</li>
<li>要归档的行：数据不再使用后可以立即清除也可以通过应用定期清除。可以吧归档数据放在核心表的同数据库中，通过视图访问，也可以完全转移到其他数据库</li>
<li>维护数据一致性：当表之间存在关系时，需要考虑表的的归档顺序。在应用层有层次联系时，归档的顺序应该与其一致。归档过程中可以暂时关闭外键约束。</li>
<li>避免数据丢失：为避免数据丢失，删数据之前要保证数据已经在目标机器上保存好（数据库或文件的形式都行）。可以将归档任务设计为随时启动或关闭，并且不会引起不一致或索引冲突。</li>
<li>解除归档：通过设置检查点确定数据是否需要归档，并支持回退。比如在登录验证时，如果用户不存在导致登录失败，可以检查归档数据中是否存在该用户，如果有，取回来。</li>
</ul>
<p>即使不把老数据转移，将活跃数据和非活跃数据隔离也有助于提高缓存效率，也可以对不同的数据使用不同的硬件或架构。</p>
<ul>
<li>分表</li>
<li>分区</li>
<li>基于时间的数据分区：新数据存在大内存和高速硬盘的主机上，大量的老数据存储在大容量主机上。</li>
</ul>
<p>注：分表和分区的区别，分表将表在逻辑拆分成不同的表；分区还是保持原来的逻辑表但在存储时将数据分成小块，分区存放。</p>
<h2 id="负载均衡"><a class="markdownIt-Anchor" href="#负载均衡"></a> 负载均衡</h2>
<p>典型的大型网站负载均衡设置，做两层负载均衡，一个负责应用访问负载均衡，一个负载 MySQL 读取查询负载均衡。<br />
<img src="https://i.loli.net/2020/04/11/mYawjnNU3BvxsJk.png" alt="" /></p>
<p>负载均衡的五个要点：</p>
<ul>
<li>可扩展性：有助于读写分离时配置从多个备库读数据</li>
<li>高效性：有助于更有效地使用资源</li>
<li>可用性：时刻保持可用的服务器</li>
<li>透明性：客户端无须关注负载均衡设置，访问一个逻辑服务器即可</li>
<li>一致性：如果应用是有状态的（数据库事务，网站会话等），那么负载均衡应该将相关查询指向同一个服务器。应用无须跟踪连接是是哪个服务器。</li>
</ul>
<h3 id="直接连接"><a class="markdownIt-Anchor" href="#直接连接"></a> 直接连接</h3>
<p>在保持应用和数据库之前的情况下进行负载均衡，应用高效执行数据查询路由。</p>
<p>异步复制容易产生脏数据，常见的读/写分离方法：</p>
<ul>
<li>基于查询分离：将不能容忍脏数据的分配到主库上，不常用</li>
<li>基于脏数据分离：让应用检查复制延迟，一确定备库数据是否过时，定时统一更新。报表类应用常用策略</li>
<li>基于会话分离</li>
<li>基于版本分离</li>
<li>基于全局版本/会话分离</li>
</ul>
<h3 id="引入中间件"><a class="markdownIt-Anchor" href="#引入中间件"></a> 引入中间件</h3>
<h4 id="负载均衡器"><a class="markdownIt-Anchor" href="#负载均衡器"></a> 负载均衡器</h4>
<p>较少有专门为 MySQL 设计的负载均衡器。可使用多用途负载均衡器，但缺少 MySQL 特性，使用是有限制</p>
<h4 id="负载均衡算法"><a class="markdownIt-Anchor" href="#负载均衡算法"></a> 负载均衡算法</h4>
<ul>
<li>随机</li>
<li>轮询</li>
<li>最少连接数</li>
<li>最快响应</li>
<li>哈希</li>
<li>权重</li>
</ul>
]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql 复制</title>
    <url>/2020/03/high-perf-mysql10/</url>
    <content><![CDATA[<h2 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h2>
<p>复制功能不仅有利于构建高性能的应用，同时也是高可用、可扩展性、容灾恢复、备份以及数据仓库等工作的基础。</p>
<p>MySQL 支持两种复制方式：</p>
<ul>
<li>基于行的复制</li>
<li>基于语句的复制（也称为逻辑复制）</li>
</ul>
<p>两种方式都是通过在主库上记录二进制日志，在备库中重放日志实现异步的数据复制，因此存在延迟。</p>
<p>MySQL 的复制大部分后向兼容，新版本的服务器可以作为老版本服务器的备库，但反之不行，因为它可能无法解析新版中的新特性或语法。对于小版本号升级通常是兼容的。</p>
<a id="more"></a>
<blockquote>
<p>这里记下经历过的一个坑，oracle 10g 小版本不同也不兼容无法恢复 rman 备份。主库版本是 10.2.0.5，尝试在 10.2.0.1、10.2.0.3 下都无法恢复备份。MySQL 也说了通常，最好还是看一下更新的 changelog。</p>
</blockquote>
<p>复制主要开销在于：</p>
<ul>
<li>备库从主库读取二进制日志文件时的 IO 开销</li>
<li>从高吞吐主库复制到多个备库时唤醒复制线程的开销</li>
</ul>
<p>复制的常见用途</p>
<ul>
<li>数据分布：在不同的物理位置分布数据备份</li>
<li>负载均衡：对读密集型应用进行优化</li>
<li>备份：复制可以作为备份的补充，但不能取代备份</li>
<li>高可用性和故障切换：避免单点失败造成的系统宕机</li>
<li>MySQL 升级测试：用高版本 MySQL 作为备库，进行新版本测试</li>
</ul>
<p>复制的三个步骤：</p>
<ol>
<li>主库把数据更改记录到二进制日志中
<ul>
<li>发生在事务提交后实际更新数据之前，按照事务提交顺序而不是语句执行顺序记录</li>
</ul>
</li>
<li>备库将主库上的日志复制到自己的中继日志（Relay Log）中</li>
<li>备库读取中继日志中的事件，将其重放到备库数据之上
<ul>
<li>在主库上并发运行的查询在备库上只能串行化执行，因为只有一个 SQL 线程来重放中继日志中的事件，这会成为很多工作负载的性能瓶颈</li>
</ul>
</li>
</ol>
<p><img src="https://i.loli.net/2020/03/13/PKl7ELqwzZdOiFk.png" alt="" /></p>
<h2 id="配置"><a class="markdownIt-Anchor" href="#配置"></a> 配置</h2>
<p>假设有 server1（192.168.0.1），server2（192.168.0.2）</p>
<ol>
<li>创建复制账号</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">REPLICATION</span> <span class="keyword">SLAVE</span>, <span class="keyword">REPLICATION</span> <span class="keyword">CLIENT</span> <span class="keyword">ON</span> *.*</span><br><span class="line"><span class="keyword">TO</span> repl@<span class="string">'192.168.0.%'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'PASSWORD'</span>;</span><br></pre></td></tr></table></figure>
<p>在主库和备库都创建这个账号，尽管这个账号无法执行 select 等查询，但可以从二进制日志获取数据。</p>
<blockquote>
<p>复制账号事实上只需要主库上的<code>REPLICATION SLAVE</code>权限，不一定需要每一端服务器都有<code>REPLICATION CLIENT</code>权限，如此设置原因有：</p>
<ul>
<li>用来监控和管理复制的账号需要此权限，针对这两种目的使用同一个账号更方便</li>
<li>备库上的设置和主库完全相同，方便交换主备库</li>
</ul>
</blockquote>
<ol start="2">
<li>配置主库和备库</li>
</ol>
<p>在主库的<code>my.cnf</code>文件中设置如下，重启服务器</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开启二进制日志</span></span><br><span class="line">log_bin = mysql-bin </span><br><span class="line"><span class="comment"># 指定唯一的 server id</span></span><br><span class="line">server_id = 10</span><br></pre></td></tr></table></figure>
<p>备库中类似，同样需要重启：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">log_bin = mysql-bin </span><br><span class="line">server_id = 2</span><br><span class="line"><span class="comment"># 指定中继日志的位置和名称</span></span><br><span class="line">relay_log = /var/lib/mysql/mysql-relay-bin</span><br><span class="line"><span class="comment"># 以下两个不是必须</span></span><br><span class="line">log_slave_updates = 1</span><br><span class="line">read_only = 1</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>启动复制</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">CHANGE MASTER TO MASTER_HOST=<span class="string">'server1'</span>,</span><br><span class="line">MASTER_USER=<span class="string">'repl'</span>,</span><br><span class="line">MASTER_PASSWORD=<span class="string">'PASSWORD'</span>,</span><br><span class="line">MASTER_LOG_FILE=<span class="string">'mysql-bin.000001'</span>,</span><br><span class="line">MASTER_LOG_POS=0;</span><br></pre></td></tr></table></figure>
<p>可以通过<code>SHOW SLAVE STATUS</code>查看是否成功，使用<code>START SLAVE</code>开始复制。</p>
<h3 id="新备库初始化"><a class="markdownIt-Anchor" href="#新备库初始化"></a> 新备库初始化</h3>
<p>当主库已经运行一段时间要新增一个备库的时候，需要初始化备库，保持主库和备库同步需要满足如下条件：</p>
<ul>
<li>在某个时间点主库的快照</li>
<li>主库当前的二进制文件，和获得数据快照时在该二进制日志文件中的偏移量</li>
<li>从快照时间到现在的二进制日志</li>
</ul>
<p>从其他服务器克隆备库的方法：</p>
<ul>
<li>冷备份，重启主库后使用一个新的二进制日志文件，备库指向这个新文件</li>
<li>热备份，如果仅使用了 MyISAM 标，可在主库运行时使用<code>mysqlhotcopy</code>或<code>rsync</code>来复制数据</li>
<li>MySQLdump，如果只有 InnoDB 表，可使用如下语句导出数据，将其加载到主库后设置相应的二进制日志坐标</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqldump --single-transaction --all-databases \</span><br><span class="line">--master-data&#x3D;1--host&#x3D;server1 | mysql --host&#x3D;server2</span><br></pre></td></tr></table></figure>
<ul>
<li>使用快照或备份，确保从备份时间开始的二进制日志都存在，恢复备份后，使用<code>CHANGE MATER TO</code>指定二进制日志坐标</li>
<li>其他热备工具如 Xtrabackup</li>
<li>使用另外的备库，注意不能使用<code>SHOW MATER STATUS</code>来获取主库的日志坐标，而是在获取快照时使用<code>SHOW SLAVE STATUS</code>来获取备库在主库上的执行位置。</li>
</ul>
<h2 id="复制的原理"><a class="markdownIt-Anchor" href="#复制的原理"></a> 复制的原理</h2>
<p>基于语句的复制（统计查询并记录开销大）和基于行的复制（全表更新开销大）各有优缺点，MySQL 能在两种模式间动态切换，默认情况下使用基于语句的复制。</p>
<p>基于语句的复制</p>
<ul>
<li>优点：主备模式不同时，逻辑复制能在多种情况下工作。例如，主备上的表的定义不同但数据类型兼容、列的顺序不同等情况。很容易修改备库上的 schema，将其升级成主库</li>
<li>缺点：在使用触发器或者存储过程的时候比较容易出问题</li>
</ul>
<p>基于行的复制</p>
<ul>
<li>优点：几乎没有无法处理的场景，除了修改 schema。这种方式可以减少锁的使用。</li>
<li>缺点：无法知道执行了哪些 SQL</li>
</ul>
<p>设置<code>log_slave_updates</code>选项可以让备库变成其他服务器的主库，实现复制事件的传递<br />
<img src="https://i.loli.net/2020/03/14/gqfI9St6ov3ar5N.png" alt="" /></p>
<p>复制过滤选项允许仅复制服务器上的部分数据，有两种过滤方式：</p>
<ul>
<li>在主库上过滤记录到二进制日志中的事件</li>
<li>在备库上过滤记录到中继日志的事件<br />
<img src="https://i.loli.net/2020/03/14/qsNnhFJKXct9kRw.png" alt="" /></li>
</ul>
<p>使用复制过滤比较容易出问题，要慎重。更好的办法是阻止一些特殊的语句被复制，通常是设置<code>SQL_LOG_BIN=0</code>。</p>
<h2 id="复制拓扑"><a class="markdownIt-Anchor" href="#复制拓扑"></a> 复制拓扑</h2>
<p>基本原则：</p>
<ul>
<li>一个备库只能有一个相应的主库</li>
<li>每个备库都必须有唯一的服务器 ID</li>
<li>一个主库可以有多个备库</li>
<li><code>log_slave_updates</code>选项，可以让备库传递复制</li>
</ul>
<h3 id="一主多备"><a class="markdownIt-Anchor" href="#一主多备"></a> 一主多备</h3>
<p>结构简单，备库之间没有交互，通常用途：</p>
<ul>
<li>为不同角色使用不同的备库（如添加不同的索引或使用不同的存储引擎）</li>
<li>把一个备库作为候补主库</li>
<li>灾备</li>
<li>测试、培训、开发等</li>
</ul>
<h3 id="主-主复制"><a class="markdownIt-Anchor" href="#主-主复制"></a> 主 - 主复制</h3>
<p>主动 - 主动模式：在并发修改数据的时候容易起冲突<br />
<img src="https://i.loli.net/2020/03/14/G7gwk3uDPpQjs1V.png" alt="" /></p>
<p>主动 - 被动模式：其中一台服务器为只读<br />
<img src="https://i.loli.net/2020/03/14/eqC9LlbSkNDPXgO.png" alt="" /><br />
服务器的配置是对称的，使得切换主动和被动服务器非常方便，便于维护。</p>
<p>例如，<code>ALTER TABLE</code>操作可能会锁住整个表，非常耗时，影响服务。在主-主配置下，可以先停止主动服务器上的备库复制线程（从被动库复制），在被动库上执行耗时操作后交换角色，重启先前主动库上的复制线程，后台执行操作。这样两个库上的操作都在“后台”完成。</p>
<p>配置：</p>
<ol>
<li>确保两机有相同的数据</li>
<li>启用二进制日志，选择唯一 ID，创建复制账号</li>
<li>启用备库更新的日志记录，用于故障转移和故障恢复</li>
<li>把被动库配置成只读，防止数据冲突</li>
<li>启动实例</li>
<li>将对方设置为备库</li>
</ol>
<p>主动服务器上发生更新后，更新被记录在二进制日志中，通过复制传递到被动服务器的中继日志中。被动服务器重放查询并记录到自己的二进制日志中。由于时间的服务器 ID 和主动服务器的相同，主动服务器将忽略这些事件。</p>
<h3 id="有备库的主-主结构"><a class="markdownIt-Anchor" href="#有备库的主-主结构"></a> 有备库的主 - 主结构</h3>
<p><img src="https://i.loli.net/2020/03/14/lucwmEgK7fDnWhZ.png" alt="" /></p>
<h3 id="环形复制"><a class="markdownIt-Anchor" href="#环形复制"></a> 环形复制</h3>
<p>环形结构没有双主结构的一些有点，如对称配置和简单的故障转移，并且完全依赖于环上的每一个可用节点，增加了系统失效的几率，非常脆弱，应该避免使用。为每个节点增加备库可以减少风险。<br />
<img src="https://i.loli.net/2020/03/14/PHgKaAmvuCORjJG.png" alt="" /></p>
<h3 id="分发主库"><a class="markdownIt-Anchor" href="#分发主库"></a> 分发主库</h3>
<p>当备库较多时，为了减小主库的负担，指定一个库作为分发主库，从主库获取日志后分发给其他备库。分发主库使用 blackhole 引擎，不执行实际操作。<br />
<img src="https://i.loli.net/2020/03/14/KLoI4JTMr6hxzpm.png" alt="" /></p>
<h3 id="树结构"><a class="markdownIt-Anchor" href="#树结构"></a> 树结构</h3>
<p><img src="https://i.loli.net/2020/03/14/DQmJUlYt6PRNxoM.png" alt="" /></p>
<h3 id="定制化方案"><a class="markdownIt-Anchor" href="#定制化方案"></a> 定制化方案</h3>
<ul>
<li>选择性复制：每个备库只拥有主库的部分数据，将数据驻留在内存中。有点类似水平数据划分，但是主库中拥有所有数据。</li>
<li>分离功能：将 OLTP 服务器的数据复制到专门的 OLAP 备库上，这个备库可以使用不同的硬件、配置、索引或存储引擎</li>
<li>数据归档：选择性阻止 delete 语句的传递，在备库上保留猪肚上删除过的数据</li>
<li>全文检索：在备库中使用 MyISAM 支持全文检索，主库使用支持事务的 InnoDB</li>
<li>模拟多主库复制<br />
<img src="https://i.loli.net/2020/03/14/sRBtKmiPOTgqfuI.png" alt="" /><br />
<img src="https://i.loli.net/2020/03/14/T5PxH3v87iA6EZg.png" alt="" /></li>
<li>创建日志服务器：使用复制代替<code>mysqlbinlog</code>工具实现备份恢复</li>
</ul>
<h2 id="复制和容量规划"><a class="markdownIt-Anchor" href="#复制和容量规划"></a> 复制和容量规划</h2>
<p>考虑备库吞吐量的使用不能只使用总查询/备库数量，每台机器还需要加上主库分发的写数据的工作量。备库的扩展不是线性的，查询数量增加 4 倍可能要增加 17 倍的服务器。</p>
<p>复制无法扩展写操作，虽然主-主结构理论上可以提升写入性能（复制时写入是串行化的，效率更高）但这么做提升非常有效而且风险很大。数据分区是唯一可以扩展写入的方法。</p>
<p>可以人为地制造延迟，测量备库的性能。比如在12点将备库停止，1点重新开启，发现备库在2点时追上的主库的进度保持同步，则说明备库的性能极限能承担两倍于现在的负载。</p>
<h2 id="复制管理和维护"><a class="markdownIt-Anchor" href="#复制管理和维护"></a> 复制管理和维护</h2>
<p>管理和维护工作应该尽量自动化，涉及的工作通常有：</p>
<ul>
<li>监控复制</li>
<li>测量备库延迟</li>
<li>确认主备是否一致</li>
<li>未同步的备库修复</li>
<li>更换主库</li>
<li>主-主结构中交换角色</li>
</ul>
<h2 id="复制的问题和解决方案"><a class="markdownIt-Anchor" href="#复制的问题和解决方案"></a> 复制的问题和解决方案</h2>
<p>涉及到非常多细节，在此详细记录，实际用到时查阅相关资料。</p>
<h2 id="高级特性"><a class="markdownIt-Anchor" href="#高级特性"></a> 高级特性</h2>
<h3 id="半同步复制"><a class="markdownIt-Anchor" href="#半同步复制"></a> 半同步复制</h3>
<p>半同步复制在提交过程中增加了一个延迟：提交事务时，在客户端接收到查询结束反馈前必须保证二进制日志已经传输到至少一台备库上。主库将事务提交到磁盘之后会增加一些延迟，同样的也增加了客户端的延迟，因此其执行事务的速度受到复制速度的限制。</p>
<p>特别注意：</p>
<ul>
<li>主库不会阻塞事务提交，只有通知客户端被延迟了</li>
<li>备库在接收到事务后就发送反馈，而不是等到事务执行完才发送</li>
<li>如果备库一直没有会应已收到事件，会超时并转化为正常的异步复制</li>
</ul>
<p>半同步复制在某些场景下能提供足够的灵活性以改善性能，在主库关闭 <code>sync_binlog</code> 的情况下保证安全。写入远程的内存（备库反馈）比写入本地的磁盘要更快。</p>
<h3 id="复制心跳"><a class="markdownIt-Anchor" href="#复制心跳"></a> 复制心跳</h3>
<p>在主备库之间建立联系，如果网络断开，备库会注意到丢失的心跳数据。</p>
]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>查询性能优化-02</title>
    <url>/2020/02/high-perf-mysql06-02/</url>
    <content><![CDATA[<h2 id="优化特定类型的查询"><a class="markdownIt-Anchor" href="#优化特定类型的查询"></a> 优化特定类型的查询</h2>
<h3 id="优化-count-查询"><a class="markdownIt-Anchor" href="#优化-count-查询"></a> 优化 COUNT() 查询</h3>
<p>在COUNT()的括号中指定了列或者列的表达式，则统计的就是这个表达式有值的结果数。</p>
<p>对于没有任何WHERE条件的COUNT(*)，MyISAM可以直接返回结果。</p>
<p>可以利用MyISAM此特性对特定语句进行优化</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 原查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> world.city <span class="keyword">where</span> <span class="keyword">ID</span> &gt; <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 优化 只需要扫描前5条就行</span></span><br><span class="line"><span class="keyword">SELECT</span> (<span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> world.city) - <span class="keyword">COUNT</span>(*) </span><br><span class="line"><span class="keyword">FROM</span> world.city <span class="keyword">where</span> <span class="keyword">ID</span> &lt;= <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p>一个查询中统计一个列不同值的数量</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(color = <span class="string">'blue'</span> <span class="keyword">OR</span> <span class="literal">NULL</span>) <span class="keyword">AS</span> blue, <span class="keyword">COUNT</span>(color = <span class="string">'red'</span> <span class="keyword">OR</span> <span class="literal">NULL</span>) <span class="keyword">AS</span> red <span class="keyword">FROM</span> items;</span><br></pre></td></tr></table></figure>
<p>在对精度要求不高的时候可以使用近似值代替</p>
<a id="more"></a>
<h3 id="优化关联查询"><a class="markdownIt-Anchor" href="#优化关联查询"></a> 优化关联查询</h3>
<ul>
<li>确保ON或者USING子句中的列上有索引。创建索引的时候要考虑关联的顺序，当表A和表B通过列c关联的时候，如果优化器的关联顺序是B、A，则只需要在A.c（内层）上创建索引。</li>
<li>确保GROUP BY和ORDER BY中的表达式只涉及一个表中的列，这样MySQL才能使用索引进行优化。</li>
<li>升级时注意，关联语法、运算符优先级等可能发生变化。</li>
</ul>
<h3 id="优化-group-by-和-distinct"><a class="markdownIt-Anchor" href="#优化-group-by-和-distinct"></a> 优化 GROUP BY 和 DISTINCT</h3>
<p>在GROUP BY子句中使用查找表的标识列分组的效率比其他列高。但当所需字段为非分组列时，部分服务器可能禁用这种写法（ORACLE是不支持的），强行使用也可能带来问题。</p>
<p>如果没有ORDER BY子句显式地指定排序列，当使用GROUP BY子句时，结果集会自动按照分组的字段进行排列。如果不关心结果集的顺序，这种默认排序有导致了需要文件排序操作，则可以使用 ORDER BY NULL，让MySQL不进行文件排序。</p>
<p>可以直接在GROUP BY子句中使用DESC或ASC指定排序方向。</p>
<p>尽可能将 GROUP BY WITH ROLLUP的 ROLLUP 部分放在应用程序中进行。</p>
<h3 id="优化-limit-分页"><a class="markdownIt-Anchor" href="#优化-limit-分页"></a> 优化 LIMIT 分页</h3>
<p>分页查询中，非常靠后的页偏移量很大，很多的记录被抛弃，代价很高。</p>
<p>优化此类分页查询的最简单办法就是尽可能地使用索引覆盖扫描，而不是所有的列，然后再进行一次关联操作返回需要的列。</p>
<p>对于部分情况（主键排序），可以记录上次查询中最后一条记录的ID作为下一次查询的条件，避免使用偏移量。如</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> rental</span><br><span class="line"><span class="keyword">WHERE</span> rental_id &lt; <span class="number">16030</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> rental_id <span class="keyword">DESC</span> <span class="keyword">LIMIT</span> <span class="number">20</span>。</span><br></pre></td></tr></table></figure>
<h3 id="优化-sql_calc_found_rows"><a class="markdownIt-Anchor" href="#优化-sql_calc_found_rows"></a> 优化 SQL_CALC_FOUND_ROWS</h3>
<p>分页时可以在LIMIT语句中加上 SQL_CALC_FOUND_ROWS hint，可以获得所有满足条件的行数以便计算页数，但事实上它就是通过扫描所有行实现的，因此改提示的代价很高。</p>
<p>实践中可以不显示页数，只显示下一页，假设每页显示20条，那么就一次查询21条，如果21条存在则激活“下一页”按钮。另一种做法是一次缓存较多的数据。</p>
<h3 id="优化-union-查询"><a class="markdownIt-Anchor" href="#优化-union-查询"></a> 优化 UNION 查询</h3>
<p>WHERE、LIMIT、ORDER BY等子句需要手动“下推”</p>
<p>除非必须消除重复行，否则使用 UNION ALL 避免唯一性检查</p>
<h3 id="使用用户自定义变量"><a class="markdownIt-Anchor" href="#使用用户自定义变量"></a> 使用用户自定义变量</h3>
<p>用户自定义变量是一个用来存储内容的临时容器，在连接MySQL的整个过程中都存在。可以使用SET和SELECT语句来定义：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&gt; SET @one      := 1;</span><br><span class="line">&gt; SET @min_actor:= (SELECT MIN(actor_id) FROM actor);</span><br><span class="line">&gt; SET @last_week:= CURRENT_DATE - INTERVAL 1 WEEK;</span><br></pre></td></tr></table></figure>
<p>然后可以在任何使用表达式的地方使用这些自定义变量。</p>
<p>不能使用用户自定义变量的场景：</p>
<ul>
<li>使用自定义变量的查询无法使用查询缓存。</li>
<li>不能在使用常量或标识符的地方使用自定义变量，如表名、列名和LIMIT子句中。</li>
<li>用户自定义变量的生命周期为一个连接，不可以跨连接通信。</li>
<li>如果使用连接池或者持久化连接，自定义变量可能让看起来毫无关系的代码发生交互。</li>
<li>不能显式声明变量类型，其为动态类型。</li>
<li>优化器在某些场景可能会将这些变量优化掉，导致意想不到的错误。</li>
<li>赋值表达式需要使用括号，<code>:=</code>的优先级很低。</li>
<li>使用未定义变量不会报语法错误</li>
</ul>
<p>总之使用时要注意<strong>赋值的顺序和赋值的时间</strong></p>
<p>应用场景：</p>
<ul>
<li>优化排名语句</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> @curr_cnt := <span class="number">0</span> , @prev_cnt := <span class="number">0</span> , @<span class="keyword">rank</span> := <span class="number">0</span>;</span><br><span class="line"><span class="keyword">SELECT</span> actor_id, </span><br><span class="line">    @curr_cnt := cnt <span class="keyword">AS</span> cnt, </span><br><span class="line">    @<span class="keyword">rank</span>     := <span class="keyword">IF</span>(@prev_cnt &lt;&gt; @curr_cnt, @<span class="keyword">rank</span> + <span class="number">1</span>, @<span class="keyword">rank</span>) <span class="keyword">AS</span> <span class="keyword">rank</span>,</span><br><span class="line">    @prev_cnt := @curr_cnt <span class="keyword">AS</span> dummy</span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> actor_id, <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> cnt </span><br><span class="line">    <span class="keyword">FROM</span> sakila.film_actor </span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> actor_id</span><br><span class="line">    <span class="keyword">ORDER</span> <span class="keyword">BY</span> cnt <span class="keyword">DESC</span></span><br><span class="line">    <span class="keyword">LIMIT</span> <span class="number">10</span> </span><br><span class="line">)<span class="keyword">AS</span> der;</span><br></pre></td></tr></table></figure>
<ul>
<li>更新的同时获取数据</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> t1 <span class="keyword">SET</span> lastUpdated = <span class="keyword">NOW</span>() <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">AND</span> @<span class="keyword">now</span> = <span class="keyword">NOW</span>();</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="keyword">now</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>统计更新和插入的数量</li>
</ul>
<p>当使用了 <code>INSERT ON DUPLICATE KEY UPDATE</code>时想知道更新数可以使用</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1(c1, c2) <span class="keyword">VALUES</span>(<span class="number">4</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">1</span>), (<span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">DUPLICATE</span> <span class="keyword">KEY</span> <span class="keyword">UPDATE</span></span><br><span class="line">    c1 = <span class="keyword">VALUES</span>(c1) + (<span class="number">0</span> * (@x := @x + <span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<ul>
<li>确定取值的顺序</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> @<span class="keyword">rownum</span> := <span class="number">0</span>;</span><br><span class="line"><span class="comment">-- where 语句 在 select 之前执行</span></span><br><span class="line"><span class="keyword">SELECT</span> actor_id, @<span class="keyword">rownum</span> := @<span class="keyword">rownum</span> + <span class="number">1</span> <span class="keyword">AS</span> cnt</span><br><span class="line"><span class="keyword">FROM</span> sakila.actor</span><br><span class="line"><span class="keyword">WHERE</span> @<span class="keyword">rownum</span> &lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--  Using where; Using index </span></span><br><span class="line">+<span class="comment">----------+------+</span></span><br><span class="line">| actor_id | cnt  |</span><br><span class="line">+<span class="comment">----------+------+</span></span><br><span class="line">|       58 |    1 |</span><br><span class="line">|       92 |    2 |</span><br><span class="line">+<span class="comment">----------+------+</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> @<span class="keyword">rownum</span> := <span class="number">0</span>;</span><br><span class="line"><span class="comment">-- 让赋值和取值发生在查询的同一个阶段（子句）可结果以上问题</span></span><br><span class="line"><span class="keyword">SELECT</span> actor_id, @<span class="keyword">rownum</span> <span class="keyword">AS</span> cnt</span><br><span class="line"><span class="keyword">FROM</span> sakila.actor</span><br><span class="line"><span class="keyword">WHERE</span> (@<span class="keyword">rownum</span> := @<span class="keyword">rownum</span> + <span class="number">1</span>) &lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Using where; Using index</span></span><br><span class="line">+<span class="comment">----------+------+</span></span><br><span class="line">| actor_id | cnt  |</span><br><span class="line">+<span class="comment">----------+------+</span></span><br><span class="line">|       58 |    1 |</span><br><span class="line">+<span class="comment">----------+------+</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> @<span class="keyword">rownum</span>:=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">SELECT</span> actor_id,first_name, </span><br><span class="line">    @<span class="keyword">rownum</span> <span class="keyword">AS</span> cnt <span class="keyword">FROM</span> sakila.actor <span class="keyword">WHERE</span> (@<span class="keyword">rownum</span> := @<span class="keyword">rownum</span> + <span class="number">1</span>) &lt;= <span class="number">1</span> </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> first_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Using where; Using filesort</span></span><br><span class="line">+<span class="comment">----------+------------+------+</span></span><br><span class="line">| actor_id | first_name | cnt  |</span><br><span class="line">+<span class="comment">----------+------------+------+</span></span><br><span class="line">|        1 | PENELOPE   |  200 |</span><br><span class="line">+<span class="comment">----------+------------+------+</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 这个语句的执行顺序貌似是 where -&gt; order by -&gt;select</span></span><br><span class="line"><span class="comment">-- @rownum &lt;= 2 会返回三条</span></span><br><span class="line"><span class="comment">-- 子句中表达式的执行可能和子句的执行顺序不一致？</span></span><br><span class="line"><span class="keyword">SET</span> @<span class="keyword">rownum</span> := <span class="number">0</span>;</span><br><span class="line"><span class="keyword">SELECT</span> actor_id,first_name, </span><br><span class="line">    @<span class="keyword">rownum</span> <span class="keyword">AS</span> cnt <span class="keyword">FROM</span> sakila.actor <span class="keyword">WHERE</span> @<span class="keyword">rownum</span> &lt;= <span class="number">1</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> first_name, <span class="keyword">least</span>(<span class="number">0</span>, @<span class="keyword">rownum</span> := @<span class="keyword">rownum</span> +<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Using where; Using temporary; Using filesort</span></span><br><span class="line">+<span class="comment">----------+------------+------+</span></span><br><span class="line">| actor_id | first_name | cnt  |</span><br><span class="line">+<span class="comment">----------+------------+------+</span></span><br><span class="line">|        2 | NICK       |    2 |</span><br><span class="line">|        1 | PENELOPE   |    1 |</span><br><span class="line">+<span class="comment">----------+------------+------+</span></span><br></pre></td></tr></table></figure>
<h4 id="order-by-问题留待讨论"><a class="markdownIt-Anchor" href="#order-by-问题留待讨论"></a> order by 问题留待讨论</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 想法是，当没有order by子句时迭代式执行</span></span><br><span class="line"><span class="keyword">for</span> row in table&#123;</span><br><span class="line">    where()</span><br><span class="line">    select()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当有order by 语句时</span></span><br><span class="line"><span class="keyword">for</span> row in table&#123;</span><br><span class="line">    where()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> row in filtered&#123;</span><br><span class="line">    select()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">order_by()</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/02/16/kAuNf25xScyZL9e.png" alt="MySQL - SQL语句执行顺序" /></p>
<ul>
<li>lazy UNION</li>
</ul>
<p>当<code>user</code>表找不到数据时，才查询 <code>user_archived</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">GREATEST</span>(@<span class="keyword">found</span> := <span class="number">-1</span>, <span class="keyword">id</span>) <span class="keyword">AS</span> <span class="keyword">id</span>, <span class="string">'user'</span> <span class="keyword">AS</span> which_tbl</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">id</span>, <span class="string">'user_archived'</span></span><br><span class="line">    <span class="keyword">FROM</span> user_archived <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">AND</span> @<span class="keyword">found</span> <span class="keyword">IS</span> <span class="literal">NULL</span></span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="number">1</span>, <span class="string">'reset'</span> <span class="keyword">FROM</span> DUAL <span class="keyword">WHERE</span> (@<span class="keyword">found</span> := <span class="literal">NULL</span>) <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br></pre></td></tr></table></figure>
<h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3>
<p>优化需要三管齐下：不做、少做、快速地做。</p>
]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>查询性能优化-01</title>
    <url>/2020/02/high-perf-mysql06-01/</url>
    <content><![CDATA[<p>表结构优化、索引优化、查询优化缺一不可，需要齐头并进。</p>
<h2 id="查询速度为什么会变慢"><a class="markdownIt-Anchor" href="#查询速度为什么会变慢"></a> 查询速度为什么会变慢</h2>
<p>查询需要在不同的地方花费时间，包括网络，CPU计算，生成统计信息和执行计划，锁等待等操作，尤其是底层存储引擎检索数据，这些检索需要内存操作、CPU 操作和内存不足时的IO操作。</p>
<h2 id="慢查询基础优化数据访问"><a class="markdownIt-Anchor" href="#慢查询基础优化数据访问"></a> 慢查询基础：优化数据访问</h2>
<p>分析步骤</p>
<ol>
<li>确认应用程序是否检索大量不必要的的数据。太多行或太多列。</li>
<li>确认MySQL服务器层是否在分析大量不必要的数据行。</li>
</ol>
<h3 id="是否向数据库请求了多余的数据"><a class="markdownIt-Anchor" href="#是否向数据库请求了多余的数据"></a> 是否向数据库请求了多余的数据</h3>
<ul>
<li>
<p>查询不需要的记录<br />
使用 SELECT 查询所有结果，获取前面的N行后关闭，实际上MySQL已经查询出全部结果。需要多少查多少，用 LIMIT 进行限制。</p>
</li>
<li>
<p>取出全部列<br />
不要使用 <code>SELECT * FROM a INNER JOIN b INNER JOIN C;</code>这样的语句。很多时候取出全部列是不必要的。并且，取出全部列会让优化器无法完成索引覆盖这类优化，还会为服务器带来额外的IO<br />
内存和CPU的消耗。<br />
有时候出于开发效率，应用程序可以通过缓存进行复用等角度也可以查询这些多余的数据。需要进行权衡</p>
</li>
<li>
<p>重复查询相同的数据<br />
利用缓存，减少重复查询。</p>
</li>
</ul>
<a id="more"></a>
<h3 id="mysql-是否扫描额外的记录"><a class="markdownIt-Anchor" href="#mysql-是否扫描额外的记录"></a> MySQL 是否扫描额外的记录</h3>
<p>衡量查询开销的三个指标：</p>
<ul>
<li>响应时间</li>
<li>扫描的行数</li>
<li>返回的行数</li>
</ul>
<p><strong>响应时间</strong> = 服务时间 + 排队时间。服务时间是数据库处理查询真正花的时间。排队时间是为了等待某些资源花费的时间——可能是IO，也可能是锁等等。可以使用“快速上限估计法”估算查询响应时间：了解一个查询需要哪些索引以及它的执行计划，然后计算大概需要多少个顺序和随机IO，乘以其在具体硬件条件下一次IO消耗的时间。</p>
<p><strong>扫描的行数和返回的行数</strong>对查询速度的影响很大。但并不是所有的行的访问代价都是相同的，较短的行的访问速度快，内存中的行比磁盘中的行访问速度快。扫描行与返回行的比值通常很小，一般在1:1和10:1之间。</p>
<p>MySQL中有好几种<strong>访问方式</strong>可以返回一行结果，有些要扫描很多行，有些甚至无需扫描行。<br />
EXPLAIN 语句中的 type 列反应了<strong>访问类型</strong>。速度从慢到快，扫描行数从多到少分别是：</p>
<ul>
<li>全表扫描</li>
<li>索引扫描</li>
<li>范围扫描</li>
<li>唯一索引查询</li>
<li>常数引用</li>
</ul>
<p>一般 MySQL 能使用如下三种方式应用 WHERE 条件，从好到坏依次为：</p>
<ul>
<li>在索引中使用 WHERE 语句过滤不匹配的记录。（在存储引擎层完成）</li>
<li>使用索引覆盖扫描（在 Extra 列中出现 Using index）来返回记录，直接从索引中过滤不需要的记录，并返回命中的结果，在 MySQL 服务器完成，但无须回表查询。</li>
<li>在数据表中返回数据，然后过滤不满足条件的记录（在 Extra 列中出现 Using Where）。在 MySQL 服务器完成，先从数据表读出数据然后过滤。</li>
</ul>
<p>如果发现查询需要扫描大量的数据，但只返回很少的行，可以尝试一下技巧：</p>
<ul>
<li>使用索引覆盖扫描，把需要的列都放到索引中</li>
<li>改变表结构，如使用单独的汇总表</li>
<li>重写这个复杂的查询，让优化器能以更优化的方式执行。</li>
</ul>
<h2 id="重构查询的方式"><a class="markdownIt-Anchor" href="#重构查询的方式"></a> 重构查询的方式</h2>
<h3 id="一个复杂查询还是多个简单查询"><a class="markdownIt-Anchor" href="#一个复杂查询还是多个简单查询"></a> 一个复杂查询还是多个简单查询</h3>
<p>传统的实现中强调数据库完成尽可能多的工作，其逻辑在于认为网络通信<br />
查询解析和优化是一件代价很高的事情。但这对于MySQL不适用，MySQL在设计上让连接和断开链接都很轻量，对小结果集友好。</p>
<p>在其他条件相同的时候，使用尽可能少的查询更有利。但有的时候，将一个大查询分解成为多个小查询是必要的。</p>
<h3 id="切分查询"><a class="markdownIt-Anchor" href="#切分查询"></a> 切分查询</h3>
<p>如定期删除数据时，用一个大的语句一次性完成需要锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 大查询</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> message <span class="keyword">WHERE</span> created &lt; DATA_SUB(<span class="keyword">NOW</span>(), INTERBAL <span class="number">3</span> <span class="keyword">MONTH</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 小查询 一次删除一万条</span></span><br><span class="line">rows_affected = 0</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    rows_affected = do_query(</span><br><span class="line">        <span class="string">"DELETE FROM message WHERE created &lt; DATA_SUB(NOW(), INTERBAL 3 MONTH) </span></span><br><span class="line"><span class="string">        LIMIT 10000"</span></span><br><span class="line">    ) </span><br><span class="line">&#125; <span class="keyword">while</span> rows_affected &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h3 id="分解关联查询"><a class="markdownIt-Anchor" href="#分解关联查询"></a> 分解关联查询</h3>
<p>分解关联查询将关联操作转移到应用程序中，优势如下：</p>
<ul>
<li>让缓存的效率更高。很多应用程序会缓存单表查询的结果进行复用。另外，对于 MySQL 的查询缓存（query cacheA）来说，关联中的表发生了变化就无法使用缓存了，拆分后如果某个表很少改变，那就可以重复利用查询缓存。</li>
<li>单个查询减少锁的竞争。</li>
<li>在应用层关联更容易对数据库进行拆分，更容易提高性能和扩展性</li>
<li>拆分查询有时可以指定查询条件中的查询顺序（使用 IN()），提高效率</li>
<li>减少冗余记录的查询</li>
<li>拆分后相当于在应用中实现了哈希关联，而不是使用嵌套循环关联（<strong>MySQL新版本中已经实现了哈希关联</strong>）</li>
</ul>
<h2 id="执行查询的基础"><a class="markdownIt-Anchor" href="#执行查询的基础"></a> 执行查询的基础</h2>
<p><img src="https://i.loli.net/2020/02/13/wi3ozX8YHSvcpex.png" alt="" /></p>
<h3 id="mysql-客户端服务器通信协议"><a class="markdownIt-Anchor" href="#mysql-客户端服务器通信协议"></a> MySQL 客户端/服务器通信协议</h3>
<p>MySQL 客户端和服务器之间的通信协议是“半双工”的。发送和接受无法同时进行，无法也无须将一个消息切成小块独立发送。</p>
<p>这种协议让通信简单快速，也从很多地方限制了MySQL。一个明显的限制是无法进行流量控制，一段发送的消息全部发完另一端才能响应。多数连接 MySQL 的库函数可以获取全部结果难道缓存中或逐行获取数据。默认一般是全部获取到内存中。MySQL 通常要等所有数据发送完成后才能释放资源，接收全部数据并缓存可以尽早释放相应的资源。对于很大的查询结果集，为了减少内存的消耗可以不缓存而直接处理，但相应的服务器被该资源长时间占用。</p>
<p>一个 MySQL 连接为一个线程，使用 <code>SHOW FULL PROCESSLIST;</code> 命令可以查询线程状态。</p>
<h3 id="查询缓存-query-cache"><a class="markdownIt-Anchor" href="#查询缓存-query-cache"></a> 查询缓存 Query Cache</h3>
<p>如果查询缓存是打开的，MySQL 会优先检查是否命中缓存中的数据。这个检查通过一个对大小写敏感的哈希查找实现，即使有一个字节不同（包括注释和空格）。</p>
<p>如果命中了查询缓存，会检查用户权限，通过则直接从缓存中获取结果。</p>
<h3 id="优化查询处理"><a class="markdownIt-Anchor" href="#优化查询处理"></a> 优化查询处理</h3>
<p>将一个 SQL 转换为一个执行计划包括几个子阶段：解析 SQL，预处理，优化 SQL 执行计划。</p>
<p>语法解析器对语句进行语法验证，生成解析树。</p>
<p>预处理器则根据一些 MySQL 规则进一步检查解析树是否合法，如检查数据表和列是否存在，名字和别名是否有歧义。然后进行权限验证。</p>
<p>优化器将检查合法的语法树转化为执行计划。MySQL 使用基于成本的优化器。最初，成本的最小单位是随机读取一个4K数据页的成本，后来成本计算公式变得更加复杂，并引入了一些因子来进行估算，如执行一次 WHERE 比较的成本。可以通过 <code>SHOW STATUS LIKE 'Last_query_cost';</code> 得知上条语句的查询成本。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&gt;  SELECT COUNT(*) FROM sakila.film_actor;</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">| count(*) |</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">|     5462 |</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">&gt; <span class="keyword">SHOW</span> <span class="keyword">STATUS</span> <span class="keyword">LIKE</span> <span class="string">'Last_query_cost'</span>;</span><br><span class="line">+<span class="comment">-----------------+-------------+</span></span><br><span class="line">| Variable_name   | Value       |</span><br><span class="line">+<span class="comment">-----------------+-------------+</span></span><br><span class="line">| Last_query_cost | 1104.399000 |</span><br><span class="line">+<span class="comment">-----------------+-------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>结果表示 MySQL 的优化器认为大概需要 1104 个数据页的随机查找才能完成上面的查询。这通过每个表或索引的页面个数、索引的基数、索引和数据行的长度、索引分布情况计算得出。</p>
<p>导致 MySQL 优化器选择错误执行计划的可能原因：</p>
<ul>
<li>统计信息不准确。InnoDB 因其 MVCC 架构不能维护一个数据表的准确行数统计信息。</li>
<li>执行计划中的成本不等于实际成本。收到页面读取方式（顺序/随机）、页面存储位置（内存/磁盘），是否缓存等影响。</li>
<li>成本模型无法真实反应执行速度</li>
<li>MySQL 没有考虑其它并发执行的查询的影响。</li>
<li>有时基于固定规则执行。如存在全文搜索 MATCH() 子句，则存在全文索引的时候就使用全文索引。</li>
<li>不考虑其他不受控制的操作的成本。如执行存储过程或用户自定义函数的成本。</li>
<li>无法估计可能的执行计划</li>
</ul>
<p>MySQL 能处理的优化类型：</p>
<ul>
<li>重新定义关联表的顺序</li>
<li>将外连接转化为内链接</li>
<li>使用等价变换规则。如将 <code>(a&lt;b AND b&lt;c) AND a=5</code> 改写为 <code>b&gt;5 AND b=c AND a=5</code></li>
<li>优化 COUNT(), MIN()和MAX()。有时，要找某一列的最小值需要查询B 树索引的最左端（EXPLAIN 中看到 Select tables optimized away），类似的，最大值找索引的最后一个记录。MyISAM 维护了数据表行数的精确值，对于没有筛选条件的 COUNT(*) 查询可以直接使用。</li>
<li>预估并转化为常数表达式。检测到表达式可以转化为常数时，将其转化。对数学表达式，甚至一个查询（如带MIN()，MAX()，主键或唯一键查找语句) 都能转化为常数。</li>
<li>覆盖索引扫描</li>
<li>子查询优化</li>
<li>提前终止查询。如 LIMIT 子句或条件不成立返回空结果。</li>
<li>等值传播。如果两个列的值通过等式关联，则把一个列的WHERE条件传递到另一个列上使得存储引擎可以更高效地过滤数据。</li>
<li>列表 IN() 的比较。MySQL 中 IN() 并非不等同于多个OR条件子句。MySQL将 IN() 列表中的数据先进行排序，然后通过二分查找的方式确定列表中的值是否满足条件，IN()列表中有大量取值时速度相较OR快很多。</li>
</ul>
<p><strong>嵌套循环关联</strong>：先在一个表中循环取出单条数据，然后再嵌套循环到下一个表中寻找匹配的行，依次下去，直到找到所有表中匹配的行为止。然后根据各个表匹配的行，返回需要的各个列。MySQL 会尝试在最有一个关联表中找到所有匹配的行，然后回溯到上一层关联表继续查找。<br />
本质上，MySQL 对多有类型的查询都以这样的方式运行。FROM 子句遇到子查询是，先执行子查询并将结果放在一个临时表中，然后将临时表当作普通表一样对待。<em>在MySQL 中每一个查询，每一个片段（包括子查询，甚至单表select）都可能是关联。</em></p>
<p><strong>执行计划</strong>：MySQL 生成查询的一颗指令树，然后通过存储引擎完成这颗指令树并返回结果。最终的执行计划包含了查询的所有信息。在对某个查询执行<code>EXPLAIN EXTENDED</code>后，再执行<code>SHOW WARNINGS</code>就可以看到重构的查询，其与原查询语义相同，但查询语句可能不同。</p>
<p>MySQL的执行计划是一颗左侧深度优先的树。<br />
<img src="https://i.loli.net/2020/02/13/8xDFghPGLit1Wp9.png" alt="" /></p>
<p><strong>关联查询优化器</strong>通过评估多表关联时不同顺序的成本来选择代价最小的关联顺序。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 自动优化顺序</span></span><br><span class="line"><span class="keyword">SELECT</span> film.film_id, film.title, film.release_year, actor.actor_id, actor.last_name</span><br><span class="line"><span class="keyword">FROM</span> film</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> film_actor <span class="keyword">USING</span>(film_id)</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> actor <span class="keyword">USING</span>(actor_id)</span><br><span class="line"></span><br><span class="line">+<span class="comment">------+-------------+------------+--------+------------------------+---------------------+---------+---------------------------+------+-------------+</span></span><br><span class="line">| <span class="keyword">id</span>   | select_type | <span class="keyword">table</span>      | <span class="keyword">type</span>   | possible_keys          | <span class="keyword">key</span>                 | key_len | <span class="keyword">ref</span>                       | <span class="keyword">rows</span> | Extra       |</span><br><span class="line">+<span class="comment">------+-------------+------------+--------+------------------------+---------------------+---------+---------------------------+------+-------------+</span></span><br><span class="line">|    <span class="number">1</span> | SIMPLE      | actor      | <span class="keyword">index</span>  | PRIMARY                | idx_actor_last_name | <span class="number">137</span>     | <span class="literal">NULL</span>                      |  <span class="number">200</span> | <span class="keyword">Using</span> <span class="keyword">index</span> |</span><br><span class="line">|    <span class="number">1</span> | SIMPLE      | film_actor | <span class="keyword">ref</span>    | PRIMARY,idx_fk_film_id | PRIMARY             | <span class="number">2</span>       | sakila.actor.actor_id     |   <span class="number">13</span> | <span class="keyword">Using</span> <span class="keyword">index</span> |</span><br><span class="line">|    <span class="number">1</span> | SIMPLE      | film       | eq_ref | PRIMARY                | PRIMARY             | <span class="number">2</span>       | sakila.film_actor.film_id |    <span class="number">1</span> |             |</span><br><span class="line">+<span class="comment">------+-------------+------------+--------+------------------------+---------------------+---------+---------------------------+------+-------------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 固定顺序</span></span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> <span class="keyword">STRAIGHT_JOIN</span> film.film_id, film.title, film.release_year, actor.actor_id, actor.last_name</span><br><span class="line"><span class="keyword">FROM</span> film</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> film_actor <span class="keyword">USING</span>(film_id)</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> actor <span class="keyword">USING</span>(actor_id)</span><br><span class="line"></span><br><span class="line">+<span class="comment">------+-------------+------------+--------+------------------------+----------------+---------+----------------------------+------+-------------+</span></span><br><span class="line">| <span class="keyword">id</span>   | select_type | <span class="keyword">table</span>      | <span class="keyword">type</span>   | possible_keys          | <span class="keyword">key</span>            | key_len | <span class="keyword">ref</span>                        | <span class="keyword">rows</span> | Extra       |</span><br><span class="line">+<span class="comment">------+-------------+------------+--------+------------------------+----------------+---------+----------------------------+------+-------------+</span></span><br><span class="line">|    <span class="number">1</span> | SIMPLE      | film       | <span class="keyword">ALL</span>    | PRIMARY                | <span class="literal">NULL</span>           | <span class="literal">NULL</span>    | <span class="literal">NULL</span>                       | <span class="number">1000</span> |             |</span><br><span class="line">|    <span class="number">1</span> | SIMPLE      | film_actor | <span class="keyword">ref</span>    | PRIMARY,idx_fk_film_id | idx_fk_film_id | <span class="number">2</span>       | sakila.film.film_id        |    <span class="number">2</span> | <span class="keyword">Using</span> <span class="keyword">index</span> |</span><br><span class="line">|    <span class="number">1</span> | SIMPLE      | actor      | eq_ref | PRIMARY                | PRIMARY        | <span class="number">2</span>       | sakila.film_actor.actor_id |    <span class="number">1</span> |             |</span><br><span class="line">+<span class="comment">------+-------------+------------+--------+------------------------+----------------+---------+----------------------------+------+-------------+</span></span><br></pre></td></tr></table></figure>
<p>通过对比两种关联顺序，相比原顺序，优化后的顺序第一个关联表只需要扫描更少的行数，而第二和第三个关联表都是根据索引查询速度很快，因而优化后查询速度更快。通过 Last_query_cost也可以看出来。</p>
<p><strong>排序优化</strong>。从性能角度考虑，应尽可能避免排序或者尽可能避免对大量数据及逆行排序。</p>
<p>当不能使用索引生成排序结果的时候，MySQL将利用内存或磁盘进行排序（文件排序 filesort）。</p>
<p>内存足够时，MySQL 使用内存进行“快速排序”。内存不够时，将数据分块 ，对每个独立的块使用“快速排序”，结果保存在磁盘上，将排好的块进行合并，返回排序结果。</p>
<p>MySQL的两种排序算法：</p>
<ul>
<li>两次传输排序：读取行指针和需要排序的行，完成排序后根据结果读取需要的数据行。第二次读取数据行会产生大量的随机IO，成本高。</li>
<li>单次传输排序：读取查询所需的所有列，然后根据给定列进行排序，最后直接返回排序结果。此算法只需一次顺序IO读取所有数据。缺点是，如果需要返回的列非常多、非常大会占用大量的空间，造成浪费。单条排序记录很大所以可能有更多的排序块需要合并。</li>
</ul>
<p>进行文件排序时，占用的临时空间可能很大。MySQL 为每行排序数据分配一个足以容纳其最长字符串的定长空间。</p>
<p>在关联查询中如果需要排序，分两种情况处理。</p>
<ul>
<li>ORDER BY 子句中的所有列来自关联的第一个表。MySQL 在关联第一个变的时候就进行文件排序，Extra 字段为 <code>Using filesort</code>。</li>
<li>除此之外。MySQL先进行所有关联再进行文件排序。Extra 字段为 <code>Using temporary; Using filesort</code>。</li>
</ul>
<p>LIMIT 子句在排序之后应用。MySQL 5.6进行了改进，不再对所有结果进行排序，而是根据实际情况，选择抛弃不满足条件的结果，然后进行排序。</p>
<h3 id="查询执行引擎"><a class="markdownIt-Anchor" href="#查询执行引擎"></a> 查询执行引擎</h3>
<p>查询执行过程有大量操作需要通过调用存储引擎的接口（handler API）完成。查询中的每一个表由一个handler的实例表示。MySQL 在优化阶段就为每个表创建了一个handler实例。</p>
<p>并不是所有操作都由handler完成，如果是所有存储引擎共有的特性则由服务器层实现。</p>
<h3 id="返回结果给客户端"><a class="markdownIt-Anchor" href="#返回结果给客户端"></a> 返回结果给客户端</h3>
<p>MySQL 返回结果集是一个增量、逐步返回的过程。如在关联操作中，一旦服务器处理完最后一个关联表，开始生成第一条结果时，MySQL就可以开始向客户端逐步返回结果集了。这样处理服务器无须存储太多结果，节省内存，另外也能让客户端第一时间获得结果。</p>
<p>结果集的每一行都会以一个满足MySQL通信协议的封包发送，再通过TCP协议传输，传输过程中可能对MySQL的封包进行缓存然后批量传输。</p>
<h2 id="mysql-查询优化器的局限性"><a class="markdownIt-Anchor" href="#mysql-查询优化器的局限性"></a> MySQL 查询优化器的局限性</h2>
<ul>
<li>关联子查询</li>
</ul>
<p>MySQL 的<code>IN(sub query)</code>语句效率不高，可改写为关联查询。<strong>MariaDB 进行了一定的优化，可以跟踪一下。</strong></p>
<p>使用子查询有时候也会比关联查询更加清晰、快速：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 关联查询，需要 DISTICT 剔除重复数据</span></span><br><span class="line"><span class="comment">-- 查询过程中会产生临时中间表，影响效率</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> film.film_id <span class="keyword">FROM</span> film </span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> film_actor <span class="keyword">USING</span>(film_id)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 子查询</span></span><br><span class="line"><span class="keyword">SELECT</span>  film.film_id <span class="keyword">FROM</span> film </span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span>(<span class="keyword">SELECT</span> * <span class="keyword">from</span> film_actor</span><br><span class="line"><span class="keyword">WHERE</span> film.film_id = film_actor.film_id)</span><br></pre></td></tr></table></figure>
<ul>
<li>UNION 的限制</li>
</ul>
<p>有时候MySQL无法将限制条件从外层“下推”到内层，使得原本能够限制部分返回结果的条件无法应用到每层查询的优化上。</p>
<p>如当使用 UNION 和 LIMIT语句，将两个结果集合并后取部分结果集，MySQL会将两个表的所有结果都存放到临时表中，可以在两个UNION子查询中都添加LIMIT进行优化。</p>
<ul>
<li>索引合并优化</li>
</ul>
<p>当 WHERE 子句中包含多个复杂条件的时候，MySQL能够访问单个表的多个索引以合并和交叉过滤的方式定位需要查找的行。、</p>
<ul>
<li>等值传递</li>
</ul>
<p>当有一个很大了IN()列表时，等值传播的特性会带来很大开销。</p>
<ul>
<li>并行执行</li>
</ul>
<p>MySQL 无法并行执行查询</p>
<ul>
<li>哈希关联</li>
</ul>
<p>MariaDB 支持 hash join。<br />
MySQL 8.0.18 版本增加了对 hash join 的支持。</p>
<p>版本对照</p>
<table>
<thead>
<tr>
<th>MariaDB</th>
<th>MySQL</th>
</tr>
</thead>
<tbody>
<tr>
<td>10.0-1</td>
<td>5.6</td>
</tr>
<tr>
<td>10.1-3</td>
<td>5.7</td>
</tr>
<tr>
<td>10.3-4</td>
<td>8.0</td>
</tr>
</tbody>
</table>
<ul>
<li>松散索引扫描</li>
</ul>
<p>相当于Oracle中的跳跃索引扫描（skip index scan）</p>
<p>MySQL 只在某些特定场景下可以使用松散索引扫描，如在一个分组查询中找到最大（小）值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> actor_id, <span class="keyword">MAX</span>(film_id)</span><br><span class="line"><span class="keyword">FROM</span> film_actor</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> actor_id</span><br></pre></td></tr></table></figure>
<p>有索引(actor_id, film_id)，可以跳跃式的扫描每个actor_id段的最后一个记录，就是相应的 <code>MAX(film_id)</code>。</p>
<ul>
<li>最大值和最小值优化</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MIN</span>(actor_id) <span class="keyword">FROM</span> actor <span class="keyword">WHERE</span> first_name = <span class="string">'PENELOPE'</span>;</span><br></pre></td></tr></table></figure>
<p>以上查询中，<code>first_name</code>字段没有索引，MySQL会进行全表扫描。而事实上因为主键actor_id是升序排列的，因此在找到第一个满足<code>first_name = 'PENELOPE'</code>的记录时就可以结束查询。因此可以改写为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> actor_id <span class="keyword">FROM</span> actor <span class="keyword">USE</span> <span class="keyword">INDEX</span>(PRIMARY)</span><br><span class="line"><span class="keyword">WHERE</span> first_name = <span class="string">'PENELOPE'</span> <span class="keyword">LIMIT</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>在同一张表上查询和更新</li>
</ul>
<p>MySQL不允许对同一张表同时进行查询和更新。但是可以通过使用生成表的形式绕过限制，关联时不是关联自身，而是关联临时表。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> tb <span class="keyword">as</span> outer_tb</span><br><span class="line">    <span class="keyword">set</span> cnt = (</span><br><span class="line">        <span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> tb <span class="keyword">AS</span> inner_tb</span><br><span class="line">        <span class="keyword">WHERE</span> inner_tb.type = outer_tb.type</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ERROR 1093 (HY000): Table 'outer_tb' is specified twice, both as a target for 'UPDATE' and as a separate source for data</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> tb</span><br><span class="line">    <span class="keyword">INNER</span> <span class="keyword">JOIN</span>(</span><br><span class="line">        <span class="keyword">SELECT</span> <span class="keyword">type</span>, <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> cnt</span><br><span class="line">        <span class="keyword">FROM</span> tb</span><br><span class="line">        <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">type</span></span><br><span class="line">    ) <span class="keyword">AS</span> der <span class="keyword">USING</span>(<span class="keyword">type</span>)</span><br><span class="line"><span class="keyword">SET</span> tb.cnt = der.cnt;</span><br></pre></td></tr></table></figure>
<ul>
<li>hint
<ul>
<li>HIGH_PRIORITY / LOW_PRIORITY</li>
<li>DELAYED</li>
<li>STRAIGHT_JOIN</li>
<li>SQL_SMALL_RESULT / SQL_BIG_RESULT：前者告诉优化器结果集会很小，可以将结果放在林村中的索引临时表，避免排序操作；后者说明结果集非常大，建议使用磁盘临时表进行排序操作。</li>
<li>SQL_BUFFER_RESULT</li>
<li>SQL_CACHE / SQL_NO_CACHE</li>
<li>SQL_CALC_FOUND_ROWS</li>
<li>FOR UPDATE / LOCK IN SHARE MODE</li>
<li>USE INDEX / IGNORE INDEX / FORCE INDEX</li>
</ul>
</li>
</ul>
<p>因版本而异，详见官方手册</p>
]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>查询性能优化</title>
    <url>/2020/02/high-perf-mysql06-md/</url>
    <content><![CDATA[<p>表结构优化、索引优化、查询优化缺一不可，需要齐头并进。</p>
<h2 id="查询速度为什么会变慢"><a class="markdownIt-Anchor" href="#查询速度为什么会变慢"></a> 查询速度为什么会变慢</h2>
<p>查询需要在不同的地方花费时间，包括网络，CPU 计算，生成统计信息和执行计划，锁等待等操作，尤其是底层存储引擎检索数据，这些检索需要内存操作、CPU 操作和内存不足时的 IO 操作。</p>
<h2 id="慢查询基础优化数据访问"><a class="markdownIt-Anchor" href="#慢查询基础优化数据访问"></a> 慢查询基础：优化数据访问</h2>
<p>分析步骤</p>
<ol>
<li>确认应用程序是否检索大量不必要的的数据，太多行或太多列。</li>
<li>确认 MySQL 服务器层是否在分析大量不必要的数据行。</li>
</ol>
<h3 id="是否向数据库请求了多余的数据"><a class="markdownIt-Anchor" href="#是否向数据库请求了多余的数据"></a> 是否向数据库请求了多余的数据</h3>
<ul>
<li>
<p>查询不需要的记录<br />
使用 SELECT 查询所有结果，获取前面的 N 行后关闭，实际上 MySQL 已经查询出全部结果。需要多少查多少，用 LIMIT 进行限制。</p>
</li>
<li>
<p>取出全部列<br />
不要使用 <code>SELECT * FROM a INNER JOIN b INNER JOIN C;</code>这样的语句。很多时候取出全部列是不必要的。并且，取出全部列会让优化器无法完成索引覆盖这类优化，还会为服务器带来额外的 IO、内存和 CPU 的消耗。<br />
有时候出于开发效率，应用程序可以通过缓存进行复用等角度也可以查询这些多余的数据，需要进行权衡。</p>
</li>
<li>
<p>重复查询相同的数据<br />
利用缓存，减少重复查询。</p>
</li>
</ul>
<a id="more"></a>
<h3 id="mysql-是否扫描额外的记录"><a class="markdownIt-Anchor" href="#mysql-是否扫描额外的记录"></a> MySQL 是否扫描额外的记录</h3>
<p>衡量查询开销的三个指标：</p>
<ul>
<li>响应时间</li>
<li>扫描的行数</li>
<li>返回的行数</li>
</ul>
<p><strong>响应时间</strong> = 服务时间 + 排队时间。服务时间是数据库处理查询真正花的时间。排队时间是为了等待某些资源花费的时间——可能是 IO，也可能是锁等等。可以使用“快速上限估计法”估算查询响应时间：了解一个查询需要哪些索引以及它的执行计划，然后计算大概需要多少个顺序和随机 IO，乘以其在具体硬件条件下一次 IO 消耗的时间。</p>
<p><strong>扫描的行数和返回的行数</strong>对查询速度的影响很大。但并不是所有的行的访问代价都是相同的，较短的行的访问速度快，内存中的行比磁盘中的行访问速度快。扫描行与返回行的比值通常很小，一般在 1:1 和 10:1 之间。</p>
<p>MySQL 中有好几种<strong>访问方式</strong>可以返回一行结果，有些要扫描很多行，有些甚至无需扫描行。<br />
EXPLAIN 语句中的 type 列反应了<strong>访问类型</strong>。速度从慢到快，扫描行数从多到少分别是：</p>
<ul>
<li>全表扫描</li>
<li>索引扫描</li>
<li>范围扫描</li>
<li>唯一索引查询</li>
<li>常数引用</li>
</ul>
<p>一般 MySQL 能使用如下三种方式应用 WHERE 条件，从好到坏依次为：</p>
<ul>
<li>在索引中使用 WHERE 语句过滤不匹配的记录。（在存储引擎层完成）</li>
<li>使用索引覆盖扫描（在 Extra 列中出现 Using index）来返回记录，直接从索引中过滤不需要的记录，并返回命中的结果，在 MySQL 服务器完成，但无须回表查询。</li>
<li>在数据表中返回数据，然后过滤不满足条件的记录（在 Extra 列中出现 Using Where）。在 MySQL 服务器完成，先从数据表读出数据然后过滤。</li>
</ul>
<p>如果发现查询需要扫描大量的数据，但只返回很少的行，可以尝试一下技巧：</p>
<ul>
<li>使用索引覆盖扫描，把需要的列都放到索引中</li>
<li>改变表结构，如使用单独的汇总表</li>
<li>重写这个复杂的查询，让优化器能以更优化的方式执行。</li>
</ul>
<h2 id="重构查询的方式"><a class="markdownIt-Anchor" href="#重构查询的方式"></a> 重构查询的方式</h2>
<h3 id="一个复杂查询还是多个简单查询"><a class="markdownIt-Anchor" href="#一个复杂查询还是多个简单查询"></a> 一个复杂查询还是多个简单查询</h3>
<p>传统的实现中强调数据库完成尽可能多的工作，其逻辑在于认为网络通信<br />
查询解析和优化是一件代价很高的事情。但这对于 MySQL 不适用，MySQL 在设计上让连接和断开链接都很轻量，对小结果集友好。</p>
<p>在其他条件相同的时候，使用尽可能少的查询更有利。但有的时候，将一个大查询分解成为多个小查询是必要的。</p>
<h3 id="切分查询"><a class="markdownIt-Anchor" href="#切分查询"></a> 切分查询</h3>
<p>如定期删除数据时，用一个大的语句一次性完成需要锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 大查询</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> message <span class="keyword">WHERE</span> created &lt; DATA_SUB(<span class="keyword">NOW</span>(), INTERBAL <span class="number">3</span> <span class="keyword">MONTH</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 小查询 一次删除一万条</span></span><br><span class="line">rows_affected = 0</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    rows_affected = do_query(</span><br><span class="line">        <span class="string">"DELETE FROM message WHERE created &lt; DATA_SUB(NOW(), INTERBAL 3 MONTH) </span></span><br><span class="line"><span class="string">        LIMIT 10000"</span></span><br><span class="line">    ) </span><br><span class="line">&#125; <span class="keyword">while</span> rows_affected &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h3 id="分解关联查询"><a class="markdownIt-Anchor" href="#分解关联查询"></a> 分解关联查询</h3>
<p>分解关联查询将关联操作转移到应用程序中，优势如下：</p>
<ul>
<li>让缓存的效率更高。很多应用程序会缓存单表查询的结果进行复用。另外，对于 MySQL 的查询缓存（query cacheA）来说，关联中的表发生了变化就无法使用缓存了，拆分后如果某个表很少改变，那就可以重复利用查询缓存。</li>
<li>单个查询减少锁的竞争。</li>
<li>在应用层关联更容易对数据库进行拆分，更容易提高性能和扩展性</li>
<li>拆分查询有时可以指定查询条件中的查询顺序（使用 IN()），提高效率</li>
<li>减少冗余记录的查询</li>
<li>拆分后相当于在应用中实现了哈希关联，而不是使用嵌套循环关联（<strong>MySQL 新版本中已经实现了哈希关联</strong>）</li>
</ul>
<h2 id="执行查询的基础"><a class="markdownIt-Anchor" href="#执行查询的基础"></a> 执行查询的基础</h2>
<p><img src="https://i.loli.net/2020/02/13/wi3ozX8YHSvcpex.png" alt="" /></p>
<h3 id="mysql-客户端服务器通信协议"><a class="markdownIt-Anchor" href="#mysql-客户端服务器通信协议"></a> MySQL 客户端/服务器通信协议</h3>
<p>MySQL 客户端和服务器之间的通信协议是“半双工”的。发送和接受无法同时进行，无法也无须将一个消息切成小块独立发送。</p>
<p>这种协议让通信简单快速，也从很多地方限制了 MySQL。一个明显的限制是无法进行流量控制，一段发送的消息全部发完另一端才能响应。多数连接 MySQL 的库函数可以获取全部结果难道缓存中或逐行获取数据。默认一般是全部获取到内存中。MySQL 通常要等所有数据发送完成后才能释放资源，接收全部数据并缓存可以尽早释放相应的资源。对于很大的查询结果集，为了减少内存的消耗可以不缓存而直接处理，但相应的服务器被该资源长时间占用。</p>
<p>一个 MySQL 连接为一个线程，使用 <code>SHOW FULL PROCESSLIST;</code> 命令可以查询线程状态。</p>
<h3 id="查询缓存-query-cache"><a class="markdownIt-Anchor" href="#查询缓存-query-cache"></a> 查询缓存 Query Cache</h3>
<p>如果查询缓存是打开的，MySQL 会优先检查是否命中缓存中的数据。这个检查通过一个对大小写敏感的哈希查找实现，即使有一个字节不同（包括注释和空格）。</p>
<p>如果命中了查询缓存，会检查用户权限，通过则直接从缓存中获取结果。</p>
<h3 id="优化查询处理"><a class="markdownIt-Anchor" href="#优化查询处理"></a> 优化查询处理</h3>
<p>将一个 SQL 转换为一个执行计划包括几个子阶段：解析 SQL，预处理，优化 SQL 执行计划。</p>
<p>语法解析器对语句进行语法验证，生成解析树。</p>
<p>预处理器则根据一些 MySQL 规则进一步检查解析树是否合法，如检查数据表和列是否存在，名字和别名是否有歧义。然后进行权限验证。</p>
<p>优化器将检查合法的语法树转化为执行计划。MySQL 使用基于成本的优化器。最初，成本的最小单位是随机读取一个 4K 数据页的成本，后来成本计算公式变得更加复杂，并引入了一些因子来进行估算，如执行一次 WHERE 比较的成本。可以通过 <code>SHOW STATUS LIKE 'Last_query_cost';</code> 得知上条语句的查询成本。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&gt;  SELECT COUNT(*) FROM sakila.film_actor;</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">| count(*) |</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">|     5462 |</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">&gt; <span class="keyword">SHOW</span> <span class="keyword">STATUS</span> <span class="keyword">LIKE</span> <span class="string">'Last_query_cost'</span>;</span><br><span class="line">+<span class="comment">-----------------+-------------+</span></span><br><span class="line">| Variable_name   | Value       |</span><br><span class="line">+<span class="comment">-----------------+-------------+</span></span><br><span class="line">| Last_query_cost | 1104.399000 |</span><br><span class="line">+<span class="comment">-----------------+-------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>结果表示 MySQL 的优化器认为大概需要 1104 个数据页的随机查找才能完成上面的查询。这通过每个表或索引的页面个数、索引的基数、索引和数据行的长度、索引分布情况计算得出。</p>
<p>导致 MySQL 优化器选择错误执行计划的可能原因：</p>
<ul>
<li>统计信息不准确。InnoDB 因其 MVCC 架构不能维护一个数据表的准确行数统计信息。</li>
<li>执行计划中的成本不等于实际成本。收到页面读取方式（顺序/随机）、页面存储位置（内存/磁盘），是否缓存等影响。</li>
<li>成本模型无法真实反应执行速度</li>
<li>MySQL 没有考虑其它并发执行的查询的影响。</li>
<li>有时基于固定规则执行。如存在全文搜索 MATCH() 子句，则存在全文索引的时候就使用全文索引。</li>
<li>不考虑其他不受控制的操作的成本。如执行存储过程或用户自定义函数的成本。</li>
<li>无法估计可能的执行计划</li>
</ul>
<p>MySQL 能处理的优化类型：</p>
<ul>
<li>重新定义关联表的顺序</li>
<li>将外连接转化为内链接</li>
<li>使用等价变换规则。如将 <code>(a&lt;b AND b&lt;c) AND a=5</code> 改写为 <code>b&gt;5 AND b=c AND a=5</code></li>
<li>优化 COUNT(), MIN() 和 MAX()。有时，要找某一列的最小值需要查询 B 树索引的最左端（EXPLAIN 中看到 Select tables optimized away），类似的，最大值找索引的最后一个记录。MyISAM 维护了数据表行数的精确值，对于没有筛选条件的 COUNT(*) 查询可以直接使用。</li>
<li>预估并转化为常数表达式。检测到表达式可以转化为常数时，将其转化。对数学表达式，甚至一个查询（如带 MIN()，MAX()，主键或唯一键查找语句） 都能转化为常数。</li>
<li>覆盖索引扫描</li>
<li>子查询优化</li>
<li>提前终止查询。如 LIMIT 子句或条件不成立返回空结果。</li>
<li>等值传播。如果两个列的值通过等式关联，则把一个列的 WHERE 条件传递到另一个列上使得存储引擎可以更高效地过滤数据。</li>
<li>列表 IN() 的比较。MySQL 中 IN() 并非不等同于多个 OR 条件子句。MySQL 将 IN() 列表中的数据先进行排序，然后通过二分查找的方式确定列表中的值是否满足条件，IN() 列表中有大量取值时速度相较 OR 快很多。</li>
</ul>
<p><strong>嵌套循环关联</strong>：先在一个表中循环取出单条数据，然后再嵌套循环到下一个表中寻找匹配的行，依次下去，直到找到所有表中匹配的行为止。然后根据各个表匹配的行，返回需要的各个列。MySQL 会尝试在最有一个关联表中找到所有匹配的行，然后回溯到上一层关联表继续查找。<br />
本质上，MySQL 对多有类型的查询都以这样的方式运行。FROM 子句遇到子查询是，先执行子查询并将结果放在一个临时表中，然后将临时表当作普通表一样对待。<em>在 MySQL 中每一个查询，每一个片段（包括子查询，甚至单表 select）都可能是关联。</em></p>
<p><strong>执行计划</strong>：MySQL 生成查询的一颗指令树，然后通过存储引擎完成这颗指令树并返回结果。最终的执行计划包含了查询的所有信息。在对某个查询执行<code>EXPLAIN EXTENDED</code>后，再执行<code>SHOW WARNINGS</code>就可以看到重构的查询，其与原查询语义相同，但查询语句可能不同。</p>
<p>MySQL 的执行计划是一颗左侧深度优先的树。<br />
<img src="https://i.loli.net/2020/02/13/8xDFghPGLit1Wp9.png" alt="" /></p>
<p><strong>关联查询优化器</strong>通过评估多表关联时不同顺序的成本来选择代价最小的关联顺序。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 自动优化顺序</span></span><br><span class="line"><span class="keyword">SELECT</span> film.film_id, film.title, film.release_year, actor.actor_id, actor.last_name</span><br><span class="line"><span class="keyword">FROM</span> film</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> film_actor <span class="keyword">USING</span>(film_id)</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> actor <span class="keyword">USING</span>(actor_id)</span><br><span class="line"></span><br><span class="line">+<span class="comment">------+-------------+------------+--------+------------------------+---------------------+---------+---------------------------+------+-------------+</span></span><br><span class="line">| <span class="keyword">id</span>   | select_type | <span class="keyword">table</span>      | <span class="keyword">type</span>   | possible_keys          | <span class="keyword">key</span>                 | key_len | <span class="keyword">ref</span>                       | <span class="keyword">rows</span> | Extra       |</span><br><span class="line">+<span class="comment">------+-------------+------------+--------+------------------------+---------------------+---------+---------------------------+------+-------------+</span></span><br><span class="line">|    <span class="number">1</span> | SIMPLE      | actor      | <span class="keyword">index</span>  | PRIMARY                | idx_actor_last_name | <span class="number">137</span>     | <span class="literal">NULL</span>                      |  <span class="number">200</span> | <span class="keyword">Using</span> <span class="keyword">index</span> |</span><br><span class="line">|    <span class="number">1</span> | SIMPLE      | film_actor | <span class="keyword">ref</span>    | PRIMARY,idx_fk_film_id | PRIMARY             | <span class="number">2</span>       | sakila.actor.actor_id     |   <span class="number">13</span> | <span class="keyword">Using</span> <span class="keyword">index</span> |</span><br><span class="line">|    <span class="number">1</span> | SIMPLE      | film       | eq_ref | PRIMARY                | PRIMARY             | <span class="number">2</span>       | sakila.film_actor.film_id |    <span class="number">1</span> |             |</span><br><span class="line">+<span class="comment">------+-------------+------------+--------+------------------------+---------------------+---------+---------------------------+------+-------------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 固定顺序</span></span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> <span class="keyword">STRAIGHT_JOIN</span> film.film_id, film.title, film.release_year, actor.actor_id, actor.last_name</span><br><span class="line"><span class="keyword">FROM</span> film</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> film_actor <span class="keyword">USING</span>(film_id)</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> actor <span class="keyword">USING</span>(actor_id)</span><br><span class="line"></span><br><span class="line">+<span class="comment">------+-------------+------------+--------+------------------------+----------------+---------+----------------------------+------+-------------+</span></span><br><span class="line">| <span class="keyword">id</span>   | select_type | <span class="keyword">table</span>      | <span class="keyword">type</span>   | possible_keys          | <span class="keyword">key</span>            | key_len | <span class="keyword">ref</span>                        | <span class="keyword">rows</span> | Extra       |</span><br><span class="line">+<span class="comment">------+-------------+------------+--------+------------------------+----------------+---------+----------------------------+------+-------------+</span></span><br><span class="line">|    <span class="number">1</span> | SIMPLE      | film       | <span class="keyword">ALL</span>    | PRIMARY                | <span class="literal">NULL</span>           | <span class="literal">NULL</span>    | <span class="literal">NULL</span>                       | <span class="number">1000</span> |             |</span><br><span class="line">|    <span class="number">1</span> | SIMPLE      | film_actor | <span class="keyword">ref</span>    | PRIMARY,idx_fk_film_id | idx_fk_film_id | <span class="number">2</span>       | sakila.film.film_id        |    <span class="number">2</span> | <span class="keyword">Using</span> <span class="keyword">index</span> |</span><br><span class="line">|    <span class="number">1</span> | SIMPLE      | actor      | eq_ref | PRIMARY                | PRIMARY        | <span class="number">2</span>       | sakila.film_actor.actor_id |    <span class="number">1</span> |             |</span><br><span class="line">+<span class="comment">------+-------------+------------+--------+------------------------+----------------+---------+----------------------------+------+-------------+</span></span><br></pre></td></tr></table></figure>
<p>通过对比两种关联顺序，相比原顺序，优化后的顺序第一个关联表只需要扫描更少的行数，而第二和第三个关联表都是根据索引查询速度很快，因而优化后查询速度更快。通过 Last_query_cost 也可以看出来。</p>
<p>当表的数量过多，需要关联的表超过<code>optimizer_search_depth</code>时，使用 <a href="http://ourmysql.com/archives/1207" target="_blank" rel="noopener">贪婪模式</a> 进行搜索。</p>
<p><strong>排序优化</strong>。从性能角度考虑，应尽可能避免排序或者尽可能避免对大量数据及逆行排序。</p>
<p>当不能使用索引生成排序结果的时候，MySQL 将利用内存或磁盘进行排序（文件排序 filesort）。</p>
<p>内存足够时，MySQL 使用内存进行“快速排序”。内存不够时，将数据分块 ，对每个独立的块使用“快速排序”，结果保存在磁盘上，将排好的块进行合并，返回排序结果。</p>
<p>MySQL 的两种排序算法：</p>
<ul>
<li>两次传输排序：读取行指针和需要排序的行，完成排序后根据结果读取需要的数据行。第二次读取数据行会产生大量的随机 IO，成本高。</li>
<li>单次传输排序：读取查询所需的所有列，然后根据给定列进行排序，最后直接返回排序结果。此算法只需一次顺序 IO 读取所有数据。缺点是，如果需要返回的列非常多、非常大会占用大量的空间，造成浪费。单条排序记录很大所以可能有更多的排序块需要合并。</li>
</ul>
<p>进行文件排序时，占用的临时空间可能很大。MySQL 为每行排序数据分配一个足以容纳其最长字符串的定长空间。</p>
<p>在关联查询中如果需要排序，分两种情况处理。</p>
<ul>
<li>ORDER BY 子句中的所有列来自关联的第一个表。MySQL 在关联第一个变的时候就进行文件排序，Extra 字段为 <code>Using filesort</code>。</li>
<li>除此之外。MySQL 先进行所有关联再进行文件排序。Extra 字段为 <code>Using temporary; Using filesort</code>。</li>
</ul>
<p>LIMIT 子句在排序之后应用。MySQL 5.6 进行了改进，不再对所有结果进行排序，而是根据实际情况，选择抛弃不满足条件的结果，然后进行排序。</p>
<h3 id="查询执行引擎"><a class="markdownIt-Anchor" href="#查询执行引擎"></a> 查询执行引擎</h3>
<p>查询执行过程有大量操作需要通过调用存储引擎的接口（handler API）完成。查询中的每一个表由一个 handler 的实例表示。MySQL 在优化阶段就为每个表创建了一个 handler 实例。</p>
<p>并不是所有操作都由 handler 完成，如果是所有存储引擎共有的特性则由服务器层实现。</p>
<h3 id="返回结果给客户端"><a class="markdownIt-Anchor" href="#返回结果给客户端"></a> 返回结果给客户端</h3>
<p>MySQL 返回结果集是一个增量、逐步返回的过程。如在关联操作中，一旦服务器处理完最后一个关联表，开始生成第一条结果时，MySQL 就可以开始向客户端逐步返回结果集了。这样处理服务器无须存储太多结果，节省内存，另外也能让客户端第一时间获得结果。</p>
<p>结果集的每一行都会以一个满足 MySQL 通信协议的封包发送，再通过 TCP 协议传输，传输过程中可能对 MySQL 的封包进行缓存然后批量传输。</p>
<h2 id="mysql-查询优化器的局限性"><a class="markdownIt-Anchor" href="#mysql-查询优化器的局限性"></a> MySQL 查询优化器的局限性</h2>
<ul>
<li>关联子查询</li>
</ul>
<p>MySQL 的<code>IN(sub query)</code>语句效率不高，可改写为关联查询。<strong>MariaDB 进行了一定的优化，可以跟踪一下。</strong></p>
<p>使用子查询有时候也会比关联查询更加清晰、快速：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 关联查询，需要 DISTICT 剔除重复数据</span></span><br><span class="line"><span class="comment">-- 查询过程中会产生临时中间表，影响效率</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> film.film_id <span class="keyword">FROM</span> film </span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> film_actor <span class="keyword">USING</span>(film_id)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 子查询</span></span><br><span class="line"><span class="keyword">SELECT</span>  film.film_id <span class="keyword">FROM</span> film </span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span>(<span class="keyword">SELECT</span> * <span class="keyword">from</span> film_actor</span><br><span class="line"><span class="keyword">WHERE</span> film.film_id = film_actor.film_id)</span><br></pre></td></tr></table></figure>
<ul>
<li>UNION 的限制</li>
</ul>
<p>有时候 MySQL 无法将限制条件从外层“下推”到内层，使得原本能够限制部分返回结果的条件无法应用到每层查询的优化上。</p>
<p>如当使用 UNION 和 LIMIT 语句，将两个结果集合并后取部分结果集，MySQL 会将两个表的所有结果都存放到临时表中，可以在两个 UNION 子查询中都添加 LIMIT 进行优化。</p>
<ul>
<li>索引合并优化</li>
</ul>
<p>当 WHERE 子句中包含多个复杂条件的时候，MySQL 能够访问单个表的多个索引以合并和交叉过滤的方式定位需要查找的行。、</p>
<ul>
<li>等值传递</li>
</ul>
<p>当有一个很大了 IN() 列表时，等值传播的特性会带来很大开销。</p>
<ul>
<li>并行执行</li>
</ul>
<p>MySQL 无法并行执行查询</p>
<ul>
<li>哈希关联</li>
</ul>
<p>MariaDB 支持 hash join。<br />
MySQL 8.0.18 版本增加了对 hash join 的支持。</p>
<p>版本对照</p>
<table>
<thead>
<tr>
<th>MariaDB</th>
<th>MySQL</th>
</tr>
</thead>
<tbody>
<tr>
<td>10.0-1</td>
<td>5.6</td>
</tr>
<tr>
<td>10.1-3</td>
<td>5.7</td>
</tr>
<tr>
<td>10.3-4</td>
<td>8.0</td>
</tr>
</tbody>
</table>
<ul>
<li>松散索引扫描</li>
</ul>
<p>相当于 Oracle 中的跳跃索引扫描（skip index scan）</p>
<p>MySQL 只在某些特定场景下可以使用松散索引扫描，如在一个分组查询中找到最大（小）值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> actor_id, <span class="keyword">MAX</span>(film_id)</span><br><span class="line"><span class="keyword">FROM</span> film_actor</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> actor_id</span><br></pre></td></tr></table></figure>
<p>有索引 (actor_id, film_id)，可以跳跃式的扫描每个 actor_id 段的最后一个记录，就是相应的 <code>MAX(film_id)</code>。</p>
<ul>
<li>最大值和最小值优化</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MIN</span>(actor_id) <span class="keyword">FROM</span> actor <span class="keyword">WHERE</span> first_name = <span class="string">'PENELOPE'</span>;</span><br></pre></td></tr></table></figure>
<p>以上查询中，<code>first_name</code>字段没有索引，MySQL 会进行全表扫描。而事实上因为主键 actor_id 是升序排列的，因此在找到第一个满足<code>first_name = 'PENELOPE'</code>的记录时就可以结束查询。因此可以改写为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> actor_id <span class="keyword">FROM</span> actor <span class="keyword">USE</span> <span class="keyword">INDEX</span>(PRIMARY)</span><br><span class="line"><span class="keyword">WHERE</span> first_name = <span class="string">'PENELOPE'</span> <span class="keyword">LIMIT</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>在同一张表上查询和更新</li>
</ul>
<p>MySQL 不允许对同一张表同时进行查询和更新。但是可以通过使用生成表的形式绕过限制，关联时不是关联自身，而是关联临时表。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> tb <span class="keyword">as</span> outer_tb</span><br><span class="line">    <span class="keyword">set</span> cnt = (</span><br><span class="line">        <span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> tb <span class="keyword">AS</span> inner_tb</span><br><span class="line">        <span class="keyword">WHERE</span> inner_tb.type = outer_tb.type</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ERROR 1093 (HY000): Table 'outer_tb' is specified twice, both as a target for 'UPDATE' and as a separate source for data</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> tb</span><br><span class="line">    <span class="keyword">INNER</span> <span class="keyword">JOIN</span>(</span><br><span class="line">        <span class="keyword">SELECT</span> <span class="keyword">type</span>, <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> cnt</span><br><span class="line">        <span class="keyword">FROM</span> tb</span><br><span class="line">        <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">type</span></span><br><span class="line">    ) <span class="keyword">AS</span> der <span class="keyword">USING</span>(<span class="keyword">type</span>)</span><br><span class="line"><span class="keyword">SET</span> tb.cnt = der.cnt;</span><br></pre></td></tr></table></figure>
<ul>
<li>hint
<ul>
<li>HIGH_PRIORITY / LOW_PRIORITY</li>
<li>DELAYED</li>
<li>STRAIGHT_JOIN</li>
<li>SQL_SMALL_RESULT / SQL_BIG_RESULT：前者告诉优化器结果集会很小，可以将结果放在林村中的索引临时表，避免排序操作；后者说明结果集非常大，建议使用磁盘临时表进行排序操作。</li>
<li>SQL_BUFFER_RESULT</li>
<li>SQL_CACHE / SQL_NO_CACHE</li>
<li>SQL_CALC_FOUND_ROWS</li>
<li>FOR UPDATE / LOCK IN SHARE MODE</li>
<li>USE INDEX / IGNORE INDEX / FORCE INDEX</li>
</ul>
</li>
</ul>
<p>因版本而异，详见官方手册</p>
<h2 id="优化特定类型的查询"><a class="markdownIt-Anchor" href="#优化特定类型的查询"></a> 优化特定类型的查询</h2>
<h3 id="优化-count-查询"><a class="markdownIt-Anchor" href="#优化-count-查询"></a> 优化 COUNT() 查询</h3>
<p>在 COUNT() 的括号中指定了列或者列的表达式，则统计的就是这个表达式有值的结果数。</p>
<p>对于没有任何 WHERE 条件的 COUNT(*)，MyISAM 可以直接返回结果。</p>
<p>可以利用 MyISAM 此特性对特定语句进行优化</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 原查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> world.city <span class="keyword">where</span> <span class="keyword">ID</span> &gt; <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 优化 只需要扫描前 5 条就行</span></span><br><span class="line"><span class="keyword">SELECT</span> (<span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> world.city) - <span class="keyword">COUNT</span>(*) </span><br><span class="line"><span class="keyword">FROM</span> world.city <span class="keyword">where</span> <span class="keyword">ID</span> &lt;= <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p>一个查询中统计一个列不同值的数量</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(color = <span class="string">'blue'</span> <span class="keyword">OR</span> <span class="literal">NULL</span>) <span class="keyword">AS</span> blue, <span class="keyword">COUNT</span>(color = <span class="string">'red'</span> <span class="keyword">OR</span> <span class="literal">NULL</span>) <span class="keyword">AS</span> red <span class="keyword">FROM</span> items;</span><br></pre></td></tr></table></figure>
<p>在对精度要求不高的时候可以使用近似值代替</p>
<h3 id="优化关联查询"><a class="markdownIt-Anchor" href="#优化关联查询"></a> 优化关联查询</h3>
<ul>
<li>确保 ON 或者 USING 子句中的列上有索引。创建索引的时候要考虑关联的顺序，当表 A 和表 B 通过列 c 关联的时候，如果优化器的关联顺序是 B、A，则只需要在 A.c（内层）上创建索引。</li>
<li>确保 GROUP BY 和 ORDER BY 中的表达式只涉及一个表中的列，这样 MySQL 才能使用索引进行优化。</li>
<li>升级时注意，关联语法、运算符优先级等可能发生变化。</li>
</ul>
<h3 id="优化-group-by-和-distinct"><a class="markdownIt-Anchor" href="#优化-group-by-和-distinct"></a> 优化 GROUP BY 和 DISTINCT</h3>
<p>在 GROUP BY 子句中使用查找表的标识列分组的效率比其他列高。但当所需字段为非分组列时，部分服务器可能禁用这种写法（ORACLE 是不支持的），强行使用也可能带来问题。</p>
<p>如果没有 ORDER BY 子句显式地指定排序列，当使用 GROUP BY 子句时，结果集会自动按照分组的字段进行排列。如果不关心结果集的顺序，这种默认排序有导致了需要文件排序操作，则可以使用 ORDER BY NULL，让 MySQL 不进行文件排序。</p>
<p>可以直接在 GROUP BY 子句中使用 DESC 或 ASC 指定排序方向。</p>
<p>尽可能将 GROUP BY WITH ROLLUP 的 ROLLUP 部分放在应用程序中进行。</p>
<h3 id="优化-limit-分页"><a class="markdownIt-Anchor" href="#优化-limit-分页"></a> 优化 LIMIT 分页</h3>
<p>分页查询中，非常靠后的页偏移量很大，很多的记录被抛弃，代价很高。</p>
<p>优化此类分页查询的最简单办法就是尽可能地使用索引覆盖扫描，而不是所有的列，然后再进行一次关联操作返回需要的列。</p>
<p>对于部分情况（主键排序），可以记录上次查询中最后一条记录的 ID 作为下一次查询的条件，避免使用偏移量。如</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> rental</span><br><span class="line"><span class="keyword">WHERE</span> rental_id &lt; <span class="number">16030</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> rental_id <span class="keyword">DESC</span> <span class="keyword">LIMIT</span> <span class="number">20</span>。</span><br></pre></td></tr></table></figure>
<h3 id="优化-sql_calc_found_rows"><a class="markdownIt-Anchor" href="#优化-sql_calc_found_rows"></a> 优化 SQL_CALC_FOUND_ROWS</h3>
<p>分页时可以在 LIMIT 语句中加上 SQL_CALC_FOUND_ROWS hint，可以获得所有满足条件的行数以便计算页数，但事实上它就是通过扫描所有行实现的，因此改提示的代价很高。</p>
<p>实践中可以不显示页数，只显示下一页，假设每页显示 20 条，那么就一次查询 21 条，如果 21 条存在则激活“下一页”按钮。另一种做法是一次缓存较多的数据。</p>
<h3 id="优化-union-查询"><a class="markdownIt-Anchor" href="#优化-union-查询"></a> 优化 UNION 查询</h3>
<p>WHERE、LIMIT、ORDER BY 等子句需要手动“下推”</p>
<p>除非必须消除重复行，否则使用 UNION ALL 避免唯一性检查</p>
<h3 id="使用用户自定义变量"><a class="markdownIt-Anchor" href="#使用用户自定义变量"></a> 使用用户自定义变量</h3>
<p>用户自定义变量是一个用来存储内容的临时容器，在连接 MySQL 的整个过程中都存在。可以使用 SET 和 SELECT 语句来定义：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&gt; SET @one      := 1;</span><br><span class="line">&gt; SET @min_actor:= (SELECT MIN(actor_id) FROM actor);</span><br><span class="line">&gt; SET @last_week:= CURRENT_DATE - INTERVAL 1 WEEK;</span><br></pre></td></tr></table></figure>
<p>然后可以在任何使用表达式的地方使用这些自定义变量。</p>
<p>不能使用用户自定义变量的场景：</p>
<ul>
<li>使用自定义变量的查询无法使用查询缓存。</li>
<li>不能在使用常量或标识符的地方使用自定义变量，如表名、列名和 LIMIT 子句中。</li>
<li>用户自定义变量的生命周期为一个连接，不可以跨连接通信。</li>
<li>如果使用连接池或者持久化连接，自定义变量可能让看起来毫无关系的代码发生交互。</li>
<li>不能显式声明变量类型，其为动态类型。</li>
<li>优化器在某些场景可能会将这些变量优化掉，导致意想不到的错误。</li>
<li>赋值表达式需要使用括号，<code>:=</code>的优先级很低。</li>
<li>使用未定义变量不会报语法错误</li>
</ul>
<p>总之使用时要注意<strong>赋值的顺序和赋值的时间</strong></p>
<p>应用场景：</p>
<ul>
<li>优化排名语句</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> @curr_cnt := <span class="number">0</span> , @prev_cnt := <span class="number">0</span> , @<span class="keyword">rank</span> := <span class="number">0</span>;</span><br><span class="line"><span class="keyword">SELECT</span> actor_id, </span><br><span class="line">    @curr_cnt := cnt <span class="keyword">AS</span> cnt, </span><br><span class="line">    @<span class="keyword">rank</span>     := <span class="keyword">IF</span>(@prev_cnt &lt;&gt; @curr_cnt, @<span class="keyword">rank</span> + <span class="number">1</span>, @<span class="keyword">rank</span>) <span class="keyword">AS</span> <span class="keyword">rank</span>,</span><br><span class="line">    @prev_cnt := @curr_cnt <span class="keyword">AS</span> dummy</span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> actor_id, <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> cnt </span><br><span class="line">    <span class="keyword">FROM</span> sakila.film_actor </span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> actor_id</span><br><span class="line">    <span class="keyword">ORDER</span> <span class="keyword">BY</span> cnt <span class="keyword">DESC</span></span><br><span class="line">    <span class="keyword">LIMIT</span> <span class="number">10</span> </span><br><span class="line">)<span class="keyword">AS</span> der;</span><br></pre></td></tr></table></figure>
<ul>
<li>更新的同时获取数据</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> t1 <span class="keyword">SET</span> lastUpdated = <span class="keyword">NOW</span>() <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">AND</span> @<span class="keyword">now</span> = <span class="keyword">NOW</span>();</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="keyword">now</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>统计更新和插入的数量</li>
</ul>
<p>当使用了 <code>INSERT ON DUPLICATE KEY UPDATE</code>时想知道更新数可以使用</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1(c1, c2) <span class="keyword">VALUES</span>(<span class="number">4</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">1</span>), (<span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">DUPLICATE</span> <span class="keyword">KEY</span> <span class="keyword">UPDATE</span></span><br><span class="line">    c1 = <span class="keyword">VALUES</span>(c1) + (<span class="number">0</span> * (@x := @x + <span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<ul>
<li>确定取值的顺序</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> @<span class="keyword">rownum</span> := <span class="number">0</span>;</span><br><span class="line"><span class="comment">-- where 语句 在 select 之前执行</span></span><br><span class="line"><span class="keyword">SELECT</span> actor_id, @<span class="keyword">rownum</span> := @<span class="keyword">rownum</span> + <span class="number">1</span> <span class="keyword">AS</span> cnt</span><br><span class="line"><span class="keyword">FROM</span> sakila.actor</span><br><span class="line"><span class="keyword">WHERE</span> @<span class="keyword">rownum</span> &lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--  Using where; Using index </span></span><br><span class="line">+<span class="comment">----------+------+</span></span><br><span class="line">| actor_id | cnt  |</span><br><span class="line">+<span class="comment">----------+------+</span></span><br><span class="line">|       58 |    1 |</span><br><span class="line">|       92 |    2 |</span><br><span class="line">+<span class="comment">----------+------+</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> @<span class="keyword">rownum</span> := <span class="number">0</span>;</span><br><span class="line"><span class="comment">-- 让赋值和取值发生在查询的同一个阶段（子句）可结果以上问题</span></span><br><span class="line"><span class="keyword">SELECT</span> actor_id, @<span class="keyword">rownum</span> <span class="keyword">AS</span> cnt</span><br><span class="line"><span class="keyword">FROM</span> sakila.actor</span><br><span class="line"><span class="keyword">WHERE</span> (@<span class="keyword">rownum</span> := @<span class="keyword">rownum</span> + <span class="number">1</span>) &lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Using where; Using index</span></span><br><span class="line">+<span class="comment">----------+------+</span></span><br><span class="line">| actor_id | cnt  |</span><br><span class="line">+<span class="comment">----------+------+</span></span><br><span class="line">|       58 |    1 |</span><br><span class="line">+<span class="comment">----------+------+</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> @<span class="keyword">rownum</span>:=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">SELECT</span> actor_id,first_name, </span><br><span class="line">    @<span class="keyword">rownum</span> <span class="keyword">AS</span> cnt <span class="keyword">FROM</span> sakila.actor <span class="keyword">WHERE</span> (@<span class="keyword">rownum</span> := @<span class="keyword">rownum</span> + <span class="number">1</span>) &lt;= <span class="number">1</span> </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> first_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Using where; Using filesort</span></span><br><span class="line">+<span class="comment">----------+------------+------+</span></span><br><span class="line">| actor_id | first_name | cnt  |</span><br><span class="line">+<span class="comment">----------+------------+------+</span></span><br><span class="line">|        1 | PENELOPE   |  200 |</span><br><span class="line">+<span class="comment">----------+------------+------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 这个语句的执行顺序貌似是 where -&gt; order by -&gt;select</span></span><br><span class="line"><span class="comment">-- @rownum &lt;= 2 会返回三条</span></span><br><span class="line"><span class="comment">-- 子句中表达式的执行可能和子句的执行顺序不一致？</span></span><br><span class="line"><span class="keyword">SET</span> @<span class="keyword">rownum</span> := <span class="number">0</span>;</span><br><span class="line"><span class="keyword">SELECT</span> actor_id,first_name, </span><br><span class="line">    @<span class="keyword">rownum</span> <span class="keyword">AS</span> cnt <span class="keyword">FROM</span> sakila.actor <span class="keyword">WHERE</span> @<span class="keyword">rownum</span> &lt;= <span class="number">1</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> first_name, <span class="keyword">least</span>(<span class="number">0</span>, @<span class="keyword">rownum</span> := @<span class="keyword">rownum</span> +<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Using where; Using temporary; Using filesort</span></span><br><span class="line">+<span class="comment">----------+------------+------+</span></span><br><span class="line">| actor_id | first_name | cnt  |</span><br><span class="line">+<span class="comment">----------+------------+------+</span></span><br><span class="line">|        2 | NICK       |    2 |</span><br><span class="line">|        1 | PENELOPE   |    1 |</span><br><span class="line">+<span class="comment">----------+------------+------+</span></span><br></pre></td></tr></table></figure>
<h4 id="order-by-问题留待讨论"><a class="markdownIt-Anchor" href="#order-by-问题留待讨论"></a> order by 问题留待讨论</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 想法是，当没有 order by 子句时迭代式执行</span></span><br><span class="line"><span class="keyword">for</span> row in table&#123;</span><br><span class="line">    where()</span><br><span class="line">    select()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当有 order by 语句时</span></span><br><span class="line"><span class="keyword">for</span> row in table&#123;</span><br><span class="line">    where()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> row in filtered&#123;</span><br><span class="line">    select()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">order_by()</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/02/16/kAuNf25xScyZL9e.png" alt="MySQL - SQL 语句执行顺序" /></p>
<ul>
<li>lazy UNION</li>
</ul>
<p>当<code>user</code>表找不到数据时，才查询 <code>user_archived</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">GREATEST</span>(@<span class="keyword">found</span> := <span class="number">-1</span>, <span class="keyword">id</span>) <span class="keyword">AS</span> <span class="keyword">id</span>, <span class="string">'user'</span> <span class="keyword">AS</span> which_tbl</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">id</span>, <span class="string">'user_archived'</span></span><br><span class="line">    <span class="keyword">FROM</span> user_archived <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">AND</span> @<span class="keyword">found</span> <span class="keyword">IS</span> <span class="literal">NULL</span></span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="number">1</span>, <span class="string">'reset'</span> <span class="keyword">FROM</span> DUAL <span class="keyword">WHERE</span> (@<span class="keyword">found</span> := <span class="literal">NULL</span>) <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br></pre></td></tr></table></figure>
<h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3>
<p>优化需要三管齐下：不做、少做、快速地做。</p>
]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>创建高性能的索引</title>
    <url>/2020/02/high-perf-mysql05-md/</url>
    <content><![CDATA[<h2 id="索引基础"><a class="markdownIt-Anchor" href="#索引基础"></a> 索引基础</h2>
<p>索引可以包含一个或多个列的值，MySQL 只能高效地使用索引的最左前缀，如果索引包含多个列，那么列的顺序也十分重要。</p>
<p><strong>B 树索引</strong></p>
<p>B 树中所有的值按顺序存储，每个叶节点到根的距离相同。</p>
<p>索引对多个值进行排序的依据是<code>CREATE TABLE</code>语句中定义索引时列的顺序。</p>
<p>B 树适用于全键值、键值范围或键前缀查找：</p>
<ul>
<li>全值匹配：和索引中的所有列进行匹配</li>
<li>匹配最左前缀：只使用索引的第一列</li>
<li>匹配列前缀：只匹配某一列的开头部分</li>
<li>匹配范围值：匹配值处于某个区间</li>
<li>精确匹配某一列并范围匹配另一列</li>
<li>只访问索引的查询</li>
</ul>
<p>索引树中的节点是有序的，因此还可以用于查询中的<code>ORDER BY</code>操作。如果<code>ORDER BY</code>子句满足前面列出的集中查询类型，则索引也可以满足对应的排序需求。</p>
<p>B 树索引的限制：</p>
<ul>
<li>如果不是按照索引的最左列开始查找，则无法使用索引。如为<code>last_name, first_name, birthday</code>创建索引，索引无法用于查询名字为 Bill 的人，也无法用于查找某个特定的生日。类似的，无法查找姓氏以某个字结尾的人。</li>
<li>不能跳过索引中的列。前述的索引无法用于查找特定姓氏并且在某个特定生日的人，如果不指定 first_name，只能使用索引的第一列。</li>
<li>如果查询中有某个列的范围查询，则其右边所有的列无法使用索引优化查询。</li>
</ul>
<a id="more"></a>
<p><strong>哈希索引</strong></p>
<p>hash index 只有在精确匹配索引所有列的时候才有效。对于一行数据，存储引擎对所有<em>索引列</em>计算一个 hash code。</p>
<p>MySQL 中只有 Memory 引擎显式支持哈希索引。此外其还支持非唯一哈希索引，哈希值相同是，索引会以链表的形式存放多个记录指针到同一个哈希条目中。</p>
<p>哈希索引无法用于排序，不支持部分列匹配。</p>
<p>InnoDB 引擎支持“自适应哈希索引（adaptive hash index）”，当 InnoDB 注意到某些索引值被使用得相对平凡是，它会在 B 树索引之上再创建一个哈希索引。这是一个内部行为，用户无法控制或配置。</p>
<p>可以维护一个 hash 列，查询时手动指定使用 hash 函数，实现类似哈希索引的效果。</p>
<p><strong>空间数据索引（R-Tree）</strong></p>
<p>MyISAM 支持空间索引，可以用作地理数据存储，用所有维度来索引数据，必须使用 GIS 相关函数<code>MBRCONTAINS()</code>等来维护数据，但并不完善。PostgreSQL 中的 PostGIS 较好。</p>
<p><strong>全文索引</strong></p>
<p>详见第 7 章</p>
<h2 id="索引的优点"><a class="markdownIt-Anchor" href="#索引的优点"></a> 索引的优点</h2>
<p>三大优点：</p>
<ol>
<li>减少服务器需要扫描的数据量</li>
<li>帮助服务器避免排序和临时表</li>
<li>将随机 IO 变为顺序 IO</li>
</ol>
<h2 id="高性能的索引策略"><a class="markdownIt-Anchor" href="#高性能的索引策略"></a> 高性能的索引策略</h2>
<h3 id="独立的列"><a class="markdownIt-Anchor" href="#独立的列"></a> 独立的列</h3>
<p>独立的列是指索引列不能是表达式的一部分，也不能是函数的参数。我们应该养成简化 where 条件的习惯，时钟将索引列单独放在比较符号的一侧。</p>
<h3 id="前缀索引和索引选择性"><a class="markdownIt-Anchor" href="#前缀索引和索引选择性"></a> 前缀索引和索引选择性</h3>
<p>索引很长的字符列会让索引变得大且慢，一个策略是模拟 hash 索引。</p>
<p>此外还可以只索引开头的部分字符，节约索引空间，提升效率，但会降低索引的选择性。<strong>索引的选择性</strong>是指，不重复的索引值（基数，cardinality）和记录总数的比值。</p>
<p>为了确定前缀的合适长度，需要将常见值和常见的前缀进行比较。</p>
<p>方法一：定性比较</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> cnt, city <span class="keyword">FROM</span> city_demo <span class="keyword">GROUP</span> <span class="keyword">BY</span> city <span class="keyword">ORDER</span> <span class="keyword">BY</span> cnt <span class="keyword">DESC</span> <span class="keyword">LIMIT</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改前缀长度，寻找合适长度</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> cnt, <span class="keyword">LEFT</span>(city, <span class="number">3</span>) <span class="keyword">AS</span> pref <span class="keyword">FROM</span> city_demo <span class="keyword">GROUP</span> <span class="keyword">BY</span> city <span class="keyword">ORDER</span> <span class="keyword">BY</span> cnt <span class="keyword">DESC</span> <span class="keyword">LIMIT</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>方法二：计算选择度，定量比较</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> city)/<span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> city_demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> <span class="keyword">LEFT</span>(city, <span class="number">3</span>))/<span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> sel3,</span><br><span class="line"><span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> <span class="keyword">LEFT</span>(city, <span class="number">4</span>))/<span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> sel4,</span><br><span class="line"><span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> <span class="keyword">LEFT</span>(city, <span class="number">5</span>))/<span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> sel5,</span><br><span class="line"><span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> <span class="keyword">LEFT</span>(city, <span class="number">6</span>))/<span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> sel6</span><br><span class="line"><span class="keyword">FROM</span> city_demo;</span><br></pre></td></tr></table></figure>
<p>方法二中的数值反应平均选择性，还要通过观察调整避免极端案例（最常出现前缀）带来的影响。</p>
<p><strong>创建前缀索引</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> city_demo <span class="keyword">ADD</span> <span class="keyword">KEY</span> (city(<span class="number">7</span>));</span><br></pre></td></tr></table></figure>
<p>前缀索引是一种能够是索引更小更快的办法，但也有缺陷：无法使用前缀索引来做<code>ORDER BY</code>和<code>GROUP BY</code>，也无法使用前缀索引做覆盖扫描。</p>
<p>一个常见场景是针对很长的十六进制唯一 ID 使用前缀索引。</p>
<p>后缀索引（suffix index）也有用途，例如查找某个域名的邮箱地址。MySQL 原生并不支持，但可以把字符串反转后存储，创建前缀索引。通过触发器来维护。</p>
<h3 id="多列索引"><a class="markdownIt-Anchor" href="#多列索引"></a> 多列索引</h3>
<p>在多个列上分别创建单列索引大部分情况下不能提高查询性能。MySQL 5.x 引入了“索引合并（index merge）”的策略，一定程度上使用表上的多个单列索引来定位指定的行。算法包括：OR 条件的联合，AND 条件的相交，组合前两种情况的联合及相交。可以在<code>EXPLAIN</code>中的 <code>Extra</code>查看。</p>
<p>出现索引合并意味着索引建得比较糟糕：</p>
<ul>
<li>当出现多个索引相交（多个 AND），通常需要创建一个包含多个列的索引</li>
<li>当出现联合操作（多个 OR 条件），通常需要耗费大量 CPU 和内存用于缓存、排序和合并</li>
<li>更重要的是，优化器不会吧这些计算到查询成本中，优化器只关心随机页面读取。有时运行这样查询不如直接全表扫描。可通过<code>optimizer_switch</code>关闭索引合并，也可以使用<code>IGNORE INDEX</code>提示让优化器忽略有些索引。</li>
</ul>
<h3 id="选择合适的索引顺序"><a class="markdownIt-Anchor" href="#选择合适的索引顺序"></a> 选择合适的索引顺序</h3>
<p>场景不同，选择不同，需要根据运行频率最高的查询来调整索引列的顺序。</p>
<p>当不想需要考虑排序和分组时，将选择性最高的列放在前面通常是最好的。</p>
<h3 id="聚簇索引"><a class="markdownIt-Anchor" href="#聚簇索引"></a> 聚簇索引</h3>
<p>聚簇索引（Oracle 称为 索引组织表，index-organized table）并不是单独的数据类型而是一种数据存储方式，InnoDB 的聚簇索引在同一个结构中保存了 B-Tree 索引和数据行。当表有聚簇索引时，它的数据行存放在索引的叶子页（leaf page）。因为无法同时把数据放在不同的地方，因此一个表只能有一个聚簇索引。</p>
<p>InnoDB 默认通过主键聚集数据，没有主键会选择一个唯一的非空索引代替，如果没有这样 的索引，InnoDB 会隐式定义一个主键作为聚簇索引。</p>
<p>聚簇索引的优点：</p>
<ul>
<li>相关数据共同存储，减少随机 IO</li>
<li>数据访问更快</li>
<li>使用覆盖索引扫描的查询可以直接使用页节点中的主键值  ——<em>不太理解</em></li>
</ul>
<p>缺点：</p>
<ul>
<li>数据存放在内存中时没有优势</li>
<li>插入顺序，如果不是按照主键顺序插入数据，那么在数据插入完成后最好使用 OPTIMIZE TABLE 命令重新组织一下表</li>
<li>更新聚簇索引列的代价很高，因为会强制将每个被更新的行移动到新的位置</li>
<li>基于聚簇索引的表在插入行或更新主键时，可能面临“页分裂（page split）”问题。当行的主键值要求不许将这一行插入到某个已满的页中是，存储引擎会将该页分裂成两个页面来容纳该行（两个页可能隔得很远），页分裂会导致表占用更多磁盘空间</li>
<li>聚簇索引可能导致全表扫面变慢，尤其是行比较稀疏，或者因为页分裂导致数据存储不连续的时候</li>
<li><strong>二级索引访问需要两次索引查找</strong>：二级索引的叶节点不存储地址而是存储行的主键，通过二级索引查找行，需要先在二级索引的叶节点中找到对应的主键值，然后根据主键值在聚簇索引中找到对应的行。</li>
</ul>
<p><strong>InnoDB 和 MyISAM 的数据分布对比</strong></p>
<p><strong>MyISAM</strong>：按照数据插入的顺序存储在磁盘上。索引的叶节点存储数据的物理地址，主键索引和其他索引没有什么不同</p>
<p><strong>InnoDB</strong>：在 InnoDB 中聚簇索引就是表，不需要独立的行存储，聚簇索引的每个叶节点都包含了主键值、事务 ID、回滚指针以及剩余的列。如果使用主键的列前缀索引，InnoDB 也会包含完整的主键列。</p>
<p>二级索引中叶节点存储的不是“行指针”，而是主键值，这样的策略减少了行移动或数据页分裂时二级索引的维护工作，但当主键值较长时会让二级索引占用更多的空间。</p>
<p><strong>在 InnoDB 表中按主键顺序插入行</strong></p>
<p>如果表中没有什么数据需要聚集，可以定义一个代理键（surrogate key）作为主键，最简单的就是自增列，可以保证数据行顺序写入。</p>
<p>最好避免随机的（不连续且范围很大）聚簇索引，特别是对于 IO 密集型的应用。从这个角度，使用 UUID 作为聚簇索引很糟糕，插入的花费时间更长，索引占用的空间更大。</p>
<p>顺序主键什么时候会造成坏的结果？<br />
对于高并发工作符合，按主键顺序插入可能会造成明显的争用</p>
<h3 id="覆盖索引"><a class="markdownIt-Anchor" href="#覆盖索引"></a> 覆盖索引</h3>
<p>如果一个索引包含（或者说覆盖）所有需要查询的字段的值，就称之为“覆盖索引”。使用覆盖索引可以直接获得列的数据，不需要再去读取数据行。</p>
<ul>
<li>索引条目通常远小于数据行大小，只读取索引会极大减小数据访问量。</li>
<li>索引按照列值顺序存储，范围查询有优势</li>
<li>一些存储引擎如 MyISAM 在内存中只缓存索引，数据则依赖于操作系统缓存，只扫描索引减少系统调用。</li>
<li>对于聚簇索引，如果二级索引能够实现覆盖查询，可以避免对主键索引的二级查询。</li>
</ul>
<p>MySQL 只能使用 B 树索引做覆盖索引（其他索引类型不存储索引列的值）。</p>
<p>如果索引覆盖了 WHERE 条件的字段，但不是整个查询涉及的字段，MySQL 5.5 及更早版本会回表获取数据行。可以通过延迟关联（deferred join）进行优化，对能覆盖索引的字段进行子查询，得到主键后在外层查询获取所有列值。</p>
<h3 id="使用索引扫描来做排序"><a class="markdownIt-Anchor" href="#使用索引扫描来做排序"></a> 使用索引扫描来做排序</h3>
<p>扫描索引本身很快，但如果索引不能覆盖查询所需的列，那就不得不回表查询数据行，因此按索引读取数据的速度通常比顺序全表扫描要慢。</p>
<p>只有当索引的列顺序和 ORDER BY 子句的顺序完全一致，并且各列的排序方向都一样时，MySQL 才能使用索引的结果做排序。需要关联多张表时，只有 ORDER BY 子句的字段全部属于第一张表时才能使用索引做排序。通常 ORDER BY 子句要满足最左前缀要求，除非前导列限定为常数。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> RENTAL_ID, STAFF_ID <span class="keyword">FROM</span> RENTAL </span><br><span class="line"><span class="keyword">WHERE</span> RENTAL_DATA = <span class="string">'2005-05-25'</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> INVENTORY_ID, CUSTIMER_ID</span><br></pre></td></tr></table></figure>
<p>如上查询中能够利用建立在<code>（RENTAL_DATA，INVENTORY_ID，CUSTIMER_ID）</code>上的索引。</p>
<h3 id="压缩索引"><a class="markdownIt-Anchor" href="#压缩索引"></a> 压缩索引</h3>
<p>MyISAM 使用前缀压缩减少索引的大小，让更多的索引放到内存中，提高性能。但是对于部分操作可能更慢。因为每个值的前缀压缩以来于前面的值，因此只在正序扫面的时候有利，二分查找和倒序扫面都不行。</p>
<h3 id="冗余和重复索引"><a class="markdownIt-Anchor" href="#冗余和重复索引"></a> 冗余和重复索引</h3>
<p>重复索引是指在相同的列上按照找相同的顺序创建的相同类型的索引。重复索引影响性能，应该移除。</p>
<p>唯一限制和主键限制都是通过索引实现的，三个都创建相当于在主键列上创建了三个相同的索引。</p>
<p>如果创建了索引（A，B），再创建索引（A）就是冗余索引，因为这只是前一个索引的前缀索引。索引（A，B）可以当作索引（A）使用（对于 B 树）。还有一个情况是将一个索引扩展为（A，ID），因为主键列 ID 已经包含在二级索引中了，因此这种扩展也是冗余的。</p>
<h3 id="索引和锁"><a class="markdownIt-Anchor" href="#索引和锁"></a> 索引和锁</h3>
<h2 id="索引案例学习"><a class="markdownIt-Anchor" href="#索引案例学习"></a> 索引案例学习</h2>
<h3 id="多种条件过滤"><a class="markdownIt-Anchor" href="#多种条件过滤"></a> 多种条件过滤</h3>
<p>常用的列放在前面，如果不限制该列可以用 in() 指定所有值</p>
<p>尽可能将需要做范围查询的列放在索引的后面，以便使用尽可能多的索引列。</p>
<h3 id="避免多个范围条件"><a class="markdownIt-Anchor" href="#避免多个范围条件"></a> 避免多个范围条件</h3>
<p>当有 A&gt;N and B&gt;m 两个范围条件时可以维护一个冗余列记录 A&gt;n 的真假（如果 N 不会变动）</p>
<h3 id="优化排序"><a class="markdownIt-Anchor" href="#优化排序"></a> 优化排序</h3>
<p>对于分页查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">profiles</span> <span class="keyword">where</span> sex=<span class="string">'M'</span> <span class="keyword">order</span> <span class="keyword">by</span> rating <span class="keyword">limit</span> <span class="number">10000</span>,<span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>即使有索引（sex, rating) 依然很慢。可以通过延迟关闭，通过覆盖索引查询到需要的主键再去获取需要的行，减少 MySQL 扫描多余的行。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">profiles</span> <span class="keyword">inner</span> <span class="keyword">join</span>(</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> <span class="keyword">profiles</span></span><br><span class="line">        <span class="keyword">where</span> sex=<span class="string">'M'</span> <span class="keyword">order</span> <span class="keyword">by</span> rating <span class="keyword">limit</span> <span class="number">10000</span>, <span class="number">10</span></span><br><span class="line">) <span class="keyword">as</span> x <span class="keyword">using</span>(<span class="keyword">id</span>);</span><br></pre></td></tr></table></figure>
<h2 id="维护索引和表"><a class="markdownIt-Anchor" href="#维护索引和表"></a> 维护索引和表</h2>
<p>维护表的三个目的：</p>
<ul>
<li>找到并修复损坏的表</li>
<li>维护准确的索引统计信息</li>
<li>减少碎片</li>
</ul>
<h3 id="找到并修复损坏的表"><a class="markdownIt-Anchor" href="#找到并修复损坏的表"></a> 找到并修复损坏的表</h3>
<p>损坏的索引会导致查询返回错误的结果或莫须有的主键冲突等问题，严重时甚至还会导致数据库的崩溃。</p>
<p>可以通过运行<code>CHECK TABLE</code>来检查是否发生了表损坏（因不同存储引擎而异）。</p>
<p>可使用<code>REPAIR TABLE</code>来修复损坏的表，对于不支持的存储引擎，可使用空的<code>ALTER</code>操作来重建表：<code>ALTER TABLE innodb_tbl ENGINE=INNODB</code>。如果损坏的是系统区域或者数据，只能从备份恢复。</p>
<p>MyISAM 的表损坏（corruption）通常是系统崩溃导致的。InnoDB 一般不会出现损坏，如果发生损坏，可能是</p>
<ul>
<li>硬件问题，如内存或磁盘故障（有可能）</li>
<li>数据库管理员的错误操作，如在 MySQL 外部直接操作数据文件（有可能）</li>
<li>InnoDB 本身缺陷（不太可能）</li>
</ul>
<p>如果遇到数据损坏，不能只是简单修复，更重要的是找到损坏原因，避免在此发生。</p>
<h3 id="更新索引统计信息"><a class="markdownIt-Anchor" href="#更新索引统计信息"></a> 更新索引统计信息</h3>
<p>MySQL 的查询优化器通过两个 API 来icol_per_row存储引擎的索引值分布情况</p>
<ul>
<li><code>records_in_range()</code>：传入两个边界值，查询范围内有多少记录，MyISAM 返回精确值，InnoDB 返回估算值。</li>
<li><code>info()</code>：返回各种类型的数据，包括索引的基数（每个键值有多少条记录）</li>
</ul>
<p>可以通过<code>ANALYZE TABLE</code>来生成统计信息。如果存储引擎提供的扫描行数是不准确的，或者执行计划本身太复杂无法准确获取各个阶段的行数，优化器会使用索引统计信息来估算扫描行数。</p>
<p>每种存储引擎实现索引统计信息的方式不同：</p>
<ul>
<li>Mymory 引擎不存储索引统计信息</li>
<li>MyISAM 将索引统计信息存储在磁盘中，ANALYZE TABLE 需要全索引扫描计算索引基数，此过程中需要锁表</li>
<li>InnoDB 不再磁盘中存储索引统计信息，通过随机的索引访问进行评估将其存储在内存中。</li>
</ul>
<p><code>SHOW INDEX FROM TABLE</code>可查看索引的基数（Cardinality），也可以通过<code>information_schema.statistics 表</code>获取。</p>
<p>InnoDB 会在表首次打开，或执行<code>ANALYZE TABLE</code>，或表的大小发生很大变化（大小变化超过 1/16 或插入 20 亿行）时计算索引的统计信息：随机读取少量索引页面，以此为样本计算。可通过参数设置样本页数量。</p>
<p>InnoDB 打开某些<code>information_schema</code>表，使用 SHOW TABLE STATUS 或 SHOW INDEX，或 MySQL 客户端开启自动补全的时候会触发索引统计信息的更新，可能影响性能。可以关闭<code>innodb_stats_on_metadata</code>参数避免此问题。</p>
<h3 id="减少索引和数据碎片"><a class="markdownIt-Anchor" href="#减少索引和数据碎片"></a> 减少索引和数据碎片</h3>
<p>B 树索引会碎片化，造成查询效率降低。</p>
<p>表的数据存储碎片化有三种类型：</p>
<ul>
<li>行碎片（Row fragmentation）：数据行被存储在多个片段中，对单行的访问性能下降</li>
<li>行间碎片（Intra-row fragmentation）：逻辑上顺序的页，在磁盘上不是顺序存储的。对全表扫描和聚簇索引扫描之类的操作影响很大</li>
<li>剩余空间碎片（Free space fragmentation）：数据页中有大量空余空间，读取数据时读取大量不需要的数据，造成浪费</li>
</ul>
<p>MyISAM 中三种都可能发生，InnoDB 中不会出现行碎片。</p>
<p>解决方式</p>
<ol>
<li>OPTIMIZE TABLE 或 导入再导出</li>
<li>MyISAM 可通过排序算法重建索引</li>
<li>InnoDB 可先删除索引再重新创建</li>
<li>空的<code>ALTER</code>操作来重建表：<code>ALTER TABLE innodb_tbl ENGINE=INNODB</code>（消除表的碎片）</li>
</ol>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>三个原则：</p>
<ol>
<li>单行访问成本很高。如果读取一个块只为了获取一行数据，很浪费，最好使一次块读取能获取尽可能多的行</li>
<li>顺序访问数据很快：顺序 IO 不需要磁盘寻道，对于排序的查询也更快</li>
<li>索引覆盖查询很快：如果一个所以覆盖了查询所需的所有列，那存储引擎就不用回表查询</li>
</ol>
]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Schema 与数据类型优化</title>
    <url>/2020/02/high-perf-mysql04-md/</url>
    <content><![CDATA[<h2 id="选择优化的数据类型"><a class="markdownIt-Anchor" href="#选择优化的数据类型"></a> 选择优化的数据类型</h2>
<p>选择数据类型的原则</p>
<ul>
<li>更小的通常更好。应该尽量使用可以正确存储数据的最小数据类型，更小的数据类型占用更少的磁盘、内存和 CPU 缓存，处理时需要的 CPU 周期也更少。<strong>但也要确保没有低估需要存储的值的范围</strong>。<em>(个人觉得字符串的长度限制有时候真的很难把握)</em></li>
<li>简单就好。简单数据类型的操作通常需要更少的 CPU 周期，整型的代价比字符串低，内建时间类型比字符串低，用整型存储 IP 比字符串低。</li>
<li>尽量避免使用<code>NULL</code>。查询可为 NULL 的列对于 MySQL 来说更难优化，这些列使得索引、索引统计和值比较都更复杂。</li>
</ul>
<a id="more"></a>
<h3 id="整数类型"><a class="markdownIt-Anchor" href="#整数类型"></a> 整数类型</h3>
<p>整数计算一般使用 64 位的<strong>BIGINT</strong>类型。</p>
<p>MySQL 可以为整数类型制定宽度，例如<code>INT(11)</code>，但对于大多数应用没有意义，不会限制值的合法范围，只是规定了交互工具用来显示字符的个数。</p>
<h3 id="实数类型"><a class="markdownIt-Anchor" href="#实数类型"></a> 实数类型</h3>
<p>FLOAT 和 DOUBLE 类型支持标准的浮点运算进行近似计算。</p>
<p>DECIMAL 类型用于存储精确的小数。在<code>MySQL 5.0</code>以上，MySQL 服务器自身实现了 DECIMAL 的高精度计算，相较原生浮点计算明显更慢。</p>
<p>DECIMAL 类型可以指定小数点前后的最大位数，如<code>DECIMAL(18,9)</code>小数点两边各存储 9 个数字，以二进制字符串的形式存储，每 4 个字节存储 9 个数字，小数点本身占一个字节，共计 9 个字节。</p>
<p>需要精确计算时，也可以考虑使用 BIGINT 代替 DECIMAL，根据需要的精度乘以响应的倍数即可。如存储财务数据要求精确到万分之一分，则可以把所以金额乘以一百万，以整形存储。</p>
<h3 id="字符串类型"><a class="markdownIt-Anchor" href="#字符串类型"></a> 字符串类型</h3>
<p>从 4.1 开始每个字符串列可以定义自己的字符集和排序规则。</p>
<p>VARCHAR 需要使用 1 或 2 个额外字节记录字符串的长度：如果列长度小于等于 255 用 1 个，否则用 2 个。VARCHAR 节省空间但是在更新时需要许多额外工作。适合使用的情况：最大长度比平均长度大很多；列很少更新；使用 UTF-8 这种每个字符字节数不同的字符集。</p>
<p>**5.0 以上版本 VARCHAR 保留末尾空格，CHAR 会删除所有空格。**字符串长度定义不是字节数，是字符数。</p>
<p>BINARY 和 VARBIANRY 存储二进制字符串，比较时更快。</p>
<blockquote>
<p>使用<code>VARCHAR(5)</code>和<code>VARCHAR(200)</code>存储 ‘hello’ 的空间开销是一样的，但 MySQL 会分配固定大小的内存块来保存内部值，尤其是使用内存临时表进行排序等操作。所以最好的策略是分配真正需要的空间。</p>
</blockquote>
<p>BLOB 和 TEXT 分别使用二进制和字符串方式存储大数据。BLOB 没有排序规则和字符集，而 TEXT 类型有。</p>
<p>对于 BLOB 和 TEXT，MySQL 只对每列的前<code>max_sort_length</code>字节而不是整个串进行排序。来着两种类型不能对全部长度进行索引也不能使用索引消除排序。</p>
<blockquote>
<p>Memory 引擎不支持 BLOB 和 TEXT，如果查询中使用这两种类型的列并且需要使用隐式临时表，将使用 MyISAM 磁盘临时表，开销很大。应尽量避免使用这两种类型，实在无法避免可以在用到该字段时使用<code>SUBSTRING(column, length)</code>将列值转换为字符串。</p>
</blockquote>
<p>ENUM（枚举）类型有利有弊不太常用。</p>
<h3 id="日期和时间"><a class="markdownIt-Anchor" href="#日期和时间"></a> 日期和时间</h3>
<p>MySQL 中时间格式精度为秒（MariaDB 支持微秒级别的时间类型）。</p>
<ul>
<li>DATETIME 使用 8 字节存储，存储范围大（1001~9999），与时区无关</li>
<li>TIMESTAMP 使用 4 字节存储，存储范围小（1970~2038），与时区相关</li>
</ul>
<p>通常使用 TIMESTAMP 类型，效率更高。</p>
<h3 id="位数据类型"><a class="markdownIt-Anchor" href="#位数据类型"></a> 位数据类型</h3>
<p>不太常用</p>
<h3 id="选择标识符"><a class="markdownIt-Anchor" href="#选择标识符"></a> 选择标识符</h3>
<p>选择标识列（identifier column）类型时，不仅要考虑存储类型还要考虑如何进行计算和比较，一旦选定了一种类型，还要确保所有关联表中使用同样的类型，类型之间需要精确匹配（包括 UNSIGNED 这样的属性）</p>
<p>整数通常是 ID 列最好的选择。</p>
<p>使用 MD5(),SHA1(),UUID() 产生的字符串的值会随机分布在很大的空间中，导致 INSERT 和一些 SELECT 语句变得很慢：</p>
<ul>
<li>插入值随机写到索引的不同位置，导致页分裂，磁盘随机访问等，详见第五章</li>
<li>逻辑上相邻的行会分布在磁盘和内存的不同地方</li>
<li>随机值使得缓存赖以工作的<code>访问局部性原理</code>失效。</li>
</ul>
<p>存储 UUID 值应该异出“-”符号；最好使用 UNHEX() 函数将 UUID 值转换为 16 字节的数字，存储在 BINARY(16) 列中。检索时可以通过 HEX() 函数格式化成十六进制格式。</p>
<h3 id="特殊类型数据"><a class="markdownIt-Anchor" href="#特殊类型数据"></a> 特殊类型数据</h3>
<p>IP 的本质是 32 位无符号整数，分成四段只是为了方便人进行阅读。MySQL 使用 INET_ATON() 和 INET_NTOA() 函数在两种表示方法之间转换。</p>
<h2 id="mysql-schema-设计中的陷阱"><a class="markdownIt-Anchor" href="#mysql-schema-设计中的陷阱"></a> MySQL schema 设计中的陷阱</h2>
<ul>
<li>太多的列<br />
MySQL 的存储引擎 API 需要在服务器曾和存储引擎层之间通过行缓冲格式拷贝数据，然后在服务器层将换缓冲内容解码成各个列。从行缓冲将编码过的列转换成行数据结构的操作代价很高。转换的代价依赖于列的数量。</li>
<li>太多的关联<br />
如果希望查询执行得快速且并发行好，单个查询最好在 12 个表以内做关联</li>
<li>防止过度使用枚举</li>
</ul>
<h2 id="范式和反范式"><a class="markdownIt-Anchor" href="#范式和反范式"></a> 范式和反范式</h2>
<h3 id="范式的优点和缺点"><a class="markdownIt-Anchor" href="#范式的优点和缺点"></a> 范式的优点和缺点</h3>
<ul>
<li>范式化的更新操作通常更快，只需修改更少的数据</li>
<li>范式化的表通常更小，可以更好地放在内存中，执行操作更快</li>
<li>减少 DISTINCT 或者 GROUP BY 语句的使用</li>
</ul>
<p>范式化设计的缺点是需要更多关联操作。范式化可能将列存放在不同的表中，而这些列如果在一个表中可以属于同一个索引。</p>
<h3 id="反范式的有点和缺点"><a class="markdownIt-Anchor" href="#反范式的有点和缺点"></a> 反范式的有点和缺点</h3>
<p>反范式可以避免关联，当数据比内存大是比关联要快得多，因为这样避免了随机 IO。</p>
<p>假设想要查询付费用户最近的 10 条信息，涉及<code>user_name, account_type, message_text, message_published_time</code>等字段。使用范式化设计，字段存放在两个表格中，使用 user_id 进行关联。使用反范式化组织数据，并增加一个索引（account_type, published），就可以不通过关联进行高效查询。</p>
<h3 id="混用范式化和反范式化"><a class="markdownIt-Anchor" href="#混用范式化和反范式化"></a> 混用范式化和反范式化</h3>
<p>现实中往往混合使用，平衡时间和空间开销</p>
<h2 id="缓存表和汇总表"><a class="markdownIt-Anchor" href="#缓存表和汇总表"></a> 缓存表和汇总表</h2>
<p>有时提升性能的最好方法是在同一张表中保存衍生的冗余数据，又是也需要创建一张独立的汇总表或缓存表。</p>
<p>汇总表：如统计过去 24 小时发送的消息数，可以创建<code>msg_per_hr</code>来存储每个小时的发帖数，从中查出完成的 23 小时的发帖数，在从原始表中查出头尾不完整的数量，相加得到。<br />
事事计算统计值是很昂贵的操作，要么扫描表中的大部分数据，要么查询语句只能在某些特定的索引上生效，而这类特定索引一般会对 UPDATE 操作造成影响。</p>
<p>缓存表：有时可能需要很多不同的索引组合来加速各种类型的查询。这些矛盾的需求可以通过创建一张包含部分列的缓存表解决。对缓存表使用不同的存储引擎可获得更高的效率，如主表使用 InnoDB，用 MyISAM 作为缓存表的引擎得到更小的索引占用空间，并且可以全文搜索。Elastic Search 等也可以看成是缓存表。</p>
<h3 id="物化视图"><a class="markdownIt-Anchor" href="#物化视图"></a> 物化视图</h3>
<p>物化视图实际上是预先计算并存储在硬盘上的表，可以通过各种策略进行刷新和更新。MySQL 并不原声支持物化视图，使用 Flexviews 可以自己实现。</p>
<h3 id="计数器表"><a class="markdownIt-Anchor" href="#计数器表"></a> 计数器表</h3>
<p>假设需要记录网站的点击次数，可使用 1 行记录，每次点击对改行进行更新，但写锁使得更新操作只能顺序执行。要获取更高的并发更新性能，可以将计数器保存在多行中，每次随机选择一行进行更新。</p>
<p><code>ON DUPLICATE KEY UPDATE</code>可在主键已经存在时进行更新。</p>
<h2 id="加快-alter-table-操作的速度"><a class="markdownIt-Anchor" href="#加快-alter-table-操作的速度"></a> 加快 ALTER TABLE 操作的速度</h2>
<p>ALTER TABLE 是一个很费事的操作，对于常见的场景能使用的技巧：一种是离线修改后进行主库的切换；另一种是，创建新表，拷贝数据后修改表名。</p>
<p>对于一些特殊的场景，可以只通过修改表的元数据加快操作。</p>
<h3 id="只修改-frm-文件"><a class="markdownIt-Anchor" href="#只修改-frm-文件"></a> 只修改 .frm 文件</h3>
<p>不需要重建表的操作：</p>
<ul>
<li>移除一个列的 AUTO_INCREMENT</li>
<li>增加、移除或修改 ENUM 和 SET 常量</li>
</ul>
<p>操作过程：</p>
<ol>
<li>创建一张有相同结构的表，并进行所需要的操作</li>
<li>执行 <code>FLUSH TABLES WITH READ LOCK</code>，关闭所有正在使用的表</li>
<li>交换<code>.frm 文件</code></li>
<li>执行<code>UNLOCK TABLES</code>释放锁</li>
</ol>
<h3 id="快速创建-myisam-索引"><a class="markdownIt-Anchor" href="#快速创建-myisam-索引"></a> 快速创建 MyISAM 索引</h3>
<p>MyISAM 中的<code>唯一索引</code>无法通过禁用索引、载入数据、重启索引的方式导入大量数据，也可以通过直接修改元文件的方式操作</p>
]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 架构和历史</title>
    <url>/2020/02/high-perf-mysql01-md/</url>
    <content><![CDATA[<h2 id="逻辑架构"><a class="markdownIt-Anchor" href="#逻辑架构"></a> 逻辑架构</h2>
<p>三层架构：</p>
<ul>
<li>连接与线程处理</li>
</ul>
<p>每个连接拥有一个线程，线程的创建和销毁消耗资源，可以通过维护线程池的方式，提高性能。<br />
注意区分<code>线程池</code>和<code>连接池</code>，连接池一般在客户端设置，而线程池是在 DB 服务器上配置。连接池可以减少连接的创建和释放，提高请求的平均响应时间，控制一个应用的 DB 连接数，但无法控制整个应用集群的连接数规模。<code>线程池</code>和<code>连接池</code>需要结合使用。</p>
<ul>
<li>MySQL 服务层：SQL 解析、分析、优化、缓存</li>
</ul>
<p>MySQL 的优化器不关心使用的是什么存储引擎，但存储引擎对于优化查询有影响。优化器会请求存储引擎提供容量或某个具体操作的开销信息，以及表数据的统计信息。<br />
Oracle 中有库基于规则优化 (RBO) 和基于代价优化 (CBO) 两种方式，但<code>oracle 10g</code>之后已经弃用 RBO。相比 MySQL 的优化器，Oracle 的优化更加丰富和完善，可以对照着学习。</p>
<ul>
<li>存储引擎</li>
</ul>
<a id="more"></a>
<h2 id="并发控制"><a class="markdownIt-Anchor" href="#并发控制"></a> 并发控制</h2>
<p>两种类型的锁：</p>
<ul>
<li>共享锁（shared lock）/ 读锁（read lock）</li>
<li>排他锁（exclusive lock）/ 写锁（write lock）</li>
</ul>
<p>粒度</p>
<ul>
<li>
<p>表锁<br />
存储引擎可以管理自己的锁，MySQL 本身还是会使用各种表锁来实现不同的目的。如，服务器会对<code>ALTER TABLE</code>之类的语句使用<em>表锁</em>，而忽略存储引擎的锁机制。</p>
</li>
<li>
<p>行级锁<br />
行级锁只在存储引擎层实现（如 InnoDB 和 XtraDB），服务器层面没有实现。</p>
</li>
</ul>
<h2 id="事务"><a class="markdownIt-Anchor" href="#事务"></a> 事务</h2>
<p><strong>ACID</strong></p>
<ul>
<li>原子性（atomicity）</li>
<li>一致性（consistency）</li>
<li>隔离性（isolation）</li>
<li>持久性（durability）</li>
</ul>
<p>支持事务必然会来带开销，对于一些不需要事务的查询类应用就可以选择飞事务型的存储引擎，获取更高的性能。通过<code>LOCK TABLES</code>语句同样可以为应用提供一定的保护。</p>
<p><strong>四种隔离级别</strong></p>
<ul>
<li>READ UNCIMMITTED（未提交读）：造成 dirty read，实际很少使用</li>
<li>READ COMMITTED（提交读）：不可重复读 nonrepeatable read</li>
<li>REPEATABLE READ：依然会有幻读（Phantom Read） 的问题，进一步通过多版本并发控制（Multi version Concurrency Control，MVCC）解决。是 MySQL 的默认隔离级别。</li>
<li>SERIALIZABLE：在读取的每一行上都加上锁，可能导致大量的超时和锁争用，实际很少使用。</li>
</ul>
<p><strong>事务日志</strong><br />
使用事务日志，修改数据表式可以先在内存中修改，并把操作行为记录到硬盘上的事务日志，事务日志采用追加方式，写日志操作相对写数据要快。事务日志持久化后，内存中被修改的数据可以在后台慢慢刷回到硬盘。（预写式日志 Write-Adead Logging）</p>
<p><strong>MySQL 中的事务</strong></p>
<ul>
<li>默认自动提交，可通过<code>SET AUTOCOMMIT = 0</code>禁用</li>
<li>在同一个事务中使用多种存储引擎是不可靠的</li>
<li>除了自动加的隐式锁，还可以使用特定语句进行显式锁定,如下语句（ORACLE 里也有）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT ... FOR UPDATE</span><br></pre></td></tr></table></figure>
<h2 id="多版本并发控制"><a class="markdownIt-Anchor" href="#多版本并发控制"></a> 多版本并发控制</h2>
<p>MVCC 没有统一的实现标准，有多种实现机制。MVCC 可以看成是行级锁的一个变种，但它在很多情况下避免了加锁操作，开销更低。读操作非阻塞，写操作锁定必要的行。</p>
<p>典型的有<code>乐观锁</code>和<code>悲观锁</code></p>
<p>InnoDB 的 MVCC 通过两个隐藏的列实现：行创建时间、行过期时间。存储的不是时间值而是系统版本号（system version number）。详见相关章节。</p>
<h2 id="存储引擎"><a class="markdownIt-Anchor" href="#存储引擎"></a> 存储引擎</h2>
<p>MySQL 最初基于<code>ISAM</code>构建，后来被<code>MyISAM</code>取代，如今默认的存储引擎为<code>InnoDB</code>。</p>
<p>不同的存储引擎各有特点，需要结合实际业务选择使用。多数情况下，使用 InnoDB 综合表现最好。</p>
<p><strong>应用场景</strong></p>
<ul>
<li>日志型应用：使用 MyISAM 或 Archive，开销低，插入速度快。要做分析可以主从备份，读写分离</li>
</ul>
<p><strong>切换表的引擎</strong></p>
<ul>
<li>ALTER TABLE：执行时间长</li>
<li>导入导出：mysqldump 导出后修改建表语句导入</li>
<li>创建与复制：创建新表，复制数据，数据量特别大可以分批处理</li>
</ul>
]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Fluent Python 笔记</title>
    <url>/2020/02/fluent-python/</url>
    <content><![CDATA[<h2 id="术语解释"><a class="markdownIt-Anchor" href="#术语解释"></a> 术语解释</h2>
<p>doctest: 一种单元测试工具</p>
<p>genxp: generator expression</p>
<p>listcomp: list comprehension</p>
<a id="more"></a>
<h2 id="data-structures"><a class="markdownIt-Anchor" href="#data-structures"></a> Data Structures</h2>
<h3 id="tuples-are-not-just-immutable-lists"><a class="markdownIt-Anchor" href="#tuples-are-not-just-immutable-lists"></a> Tuples Are Not Just Immutable Lists</h3>
<h4 id="using-to-excess-items"><a class="markdownIt-Anchor" href="#using-to-excess-items"></a> Using * to excess items</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a,b,*rest = range(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rest</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a,b,*rest = range(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, rest</span><br><span class="line">(<span class="number">0</span>,<span class="number">1</span>,[])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, *body, c, d = range(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, body, c, d</span><br><span class="line">(<span class="number">0</span>, [<span class="number">1</span>, <span class="number">2</span>], <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<h4 id="multidimensional-slicing-and-ellipsis"><a class="markdownIt-Anchor" href="#multidimensional-slicing-and-ellipsis"></a> Multidimensional Slicing and Ellipsis</h4>
<p>Numpy uses <code>...</code>(not <code>…</code>) as a shortcut when sliceing arrays of many dimensions; for example, if x is a four-dimensional array, <code>x[i, ...]</code> is a shortcut for <code>x[i, :, :, :]</code>.</p>
<hr />
<h3 id="using-and-with-sequences"><a class="markdownIt-Anchor" href="#using-and-with-sequences"></a> Using + and * with sequences</h3>
<p>Both + and * always create a new object, and never change their operands.</p>
<h4 id="building-lists-of-lists"><a class="markdownIt-Anchor" href="#building-lists-of-lists"></a> Building Lists of Lists</h4>
<p>The best way od doing so is with a listcomp.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>board = [[<span class="string">'_'</span>] * <span class="number">3</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>board</span><br><span class="line">[[<span class="string">'_'</span>, <span class="string">'_'</span>, <span class="string">'_'</span>], [<span class="string">'_'</span>, <span class="string">'_'</span>, <span class="string">'_'</span>], [<span class="string">'_'</span>, <span class="string">'_'</span>, <span class="string">'_'</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>board[<span class="number">1</span>][<span class="number">2</span>] = <span class="string">'X'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>board</span><br><span class="line">[[<span class="string">'_'</span>, <span class="string">'_'</span>, <span class="string">'_'</span>], [<span class="string">'_'</span>, <span class="string">'_'</span>, <span class="string">'X'</span>], [<span class="string">'_'</span>, <span class="string">'_'</span>, <span class="string">'_'</span>]]</span><br></pre></td></tr></table></figure>
<p>A tempting but wrong shortcut is doing it like the following example.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>false_board = [[<span class="string">'_'</span>] * <span class="number">3</span>] * <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>false_board</span><br><span class="line">[[<span class="string">'_'</span>, <span class="string">'_'</span>, <span class="string">'_'</span>], [<span class="string">'_'</span>, <span class="string">'_'</span>, <span class="string">'_'</span>], [<span class="string">'_'</span>, <span class="string">'_'</span>, <span class="string">'_'</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>false_board[<span class="number">1</span>][<span class="number">2</span>] = <span class="string">'X'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>false_board</span><br><span class="line">[[<span class="string">'_'</span>, <span class="string">'_'</span>, <span class="string">'X'</span>], [<span class="string">'_'</span>, <span class="string">'_'</span>, <span class="string">'X'</span>], [<span class="string">'_'</span>, <span class="string">'_'</span>, <span class="string">'X'</span>]]</span><br></pre></td></tr></table></figure>
<h3 id="augmented-assignment-with-sequences"><a class="markdownIt-Anchor" href="#augmented-assignment-with-sequences"></a> Augmented Assignment with Sequences</h3>
<p>The specical method that makes <code>+=</code> work is <code>__iadd__</code>(for “in-place addition”). However, is <code>__iadd__</code> is not implemented(immutable sequences), Python falls back to call <code>__add__</code>.</p>
<p>Repeated concatenation of immutable sequences is ineffcient.</p>
<h4 id="a-assignment-puzzler"><a class="markdownIt-Anchor" href="#a-assignment-puzzler"></a> A += Assignment Puzzler</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = (<span class="number">1</span>,<span class="number">2</span>,[<span class="number">30</span>,<span class="number">40</span>])</span><br><span class="line">t[<span class="number">2</span>] += [<span class="number">50</span>,<span class="number">60</span>]</span><br></pre></td></tr></table></figure>
<p>The result is</p>
<ul>
<li>t becomes (1,2,[30,40,50,60])</li>
<li>TypeError is raised with the message ‘tuple’ object does not support item assignment</li>
</ul>
<p>There are three steps when <code>s[a] += b</code> is running:</p>
<ol>
<li>Put the value of s[a] on TOS(Top Of Stack)</li>
<li>Perform TOS <code>+= b</code>. This succeeds if TOS is refers to a mutable object.</li>
<li>Assign s[a] = TOS. This fails if s is immutable.</li>
</ol>
<h3 id="listsort-and-the-sorted-built-in-function"><a class="markdownIt-Anchor" href="#listsort-and-the-sorted-built-in-function"></a> list.sort and the sorted Built-In Function</h3>
<p>The <code>list.sort</code> method sorts a list in place–that is, without making a copy. It retuens None to remind us that it changes the target object, and does not create a new list.</p>
<p>In contrast, the built-in function <code>sorted</code> create a new list and retuen it. In fact is accepts any iterable objects, including immutable sequences and generators.</p>
<h3 id="managing-ordered-sequences-with-bisect"><a class="markdownIt-Anchor" href="#managing-ordered-sequences-with-bisect"></a> Managing Ordered Sequences with bisect</h3>
<p>An interesting application of bisect is to perform table lookups by numeric values–for example, to convert scores to letter grades.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">grade</span><span class="params">(score, breakpoints=[<span class="number">60</span>, <span class="number">70</span>, <span class="number">80</span>, <span class="number">90</span>], grades=<span class="string">'FDCBA'</span>)</span>:</span></span><br><span class="line"><span class="meta">... </span>    i = bisect.bisect(breakpoints,score)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> grades[i]</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[grade(score) <span class="keyword">for</span> score <span class="keyword">in</span> [<span class="number">33</span>, <span class="number">99</span>, <span class="number">77</span>, <span class="number">70</span>, <span class="number">89</span>, <span class="number">90</span>, <span class="number">100</span>]]</span><br><span class="line">[<span class="string">'F'</span>, <span class="string">'A'</span>, <span class="string">'C'</span>, <span class="string">'C'</span>, <span class="string">'B'</span>, <span class="string">'A'</span>, <span class="string">'A'</span>]</span><br></pre></td></tr></table></figure>
<h3 id="when-a-list-is-not-the-answer"><a class="markdownIt-Anchor" href="#when-a-list-is-not-the-answer"></a> When a List Is Not the Answer</h3>
<h4 id="array"><a class="markdownIt-Anchor" href="#array"></a> Array</h4>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> array <span class="keyword">import</span> array</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> random <span class="keyword">import</span> random</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>floats = array(<span class="string">'d'</span>,(random() <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>**<span class="number">7</span>)))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>floats[<span class="number">-1</span>]</span><br><span class="line"><span class="number">0.652373109695629</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fp = open(<span class="string">'num.bin'</span>, <span class="string">'wb'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>floats.tofile(fp)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fp.close()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>floats2 = array(<span class="string">'d'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fp = open(<span class="string">'num.bin'</span>, <span class="string">'rb'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>floats2.fromfile(fp, <span class="number">10</span>**<span class="number">7</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fp.close()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>floats2[<span class="number">-1</span>]</span><br><span class="line"><span class="number">0.652373109695629</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>floats2 == floats</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>Using <code>array.fromfile</code> is nearly 60 times faster than reading the numbers from a text file. Saving with <code>array.tofile</code> ia about 7 times faster than writing one float per line in a text file.</p>
<h4 id="memory-views"><a class="markdownIt-Anchor" href="#memory-views"></a> Memory Views</h4>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>nums = array.array(<span class="string">'h'</span>, list(range(<span class="number">-2</span>,<span class="number">3</span>)))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>memv = memoryview(nums)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(memv)</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>memv[<span class="number">0</span>]</span><br><span class="line"><span class="number">-2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>memv_oct = memv.cast(<span class="string">'B'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>memv_oct.tolist()</span><br><span class="line">[<span class="number">254</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>memv_oct[<span class="number">5</span>] = <span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>nums</span><br><span class="line">array(<span class="string">'h'</span>, [<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">1024</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br></pre></td></tr></table></figure>
<p>非常底层的内操作，一般来说只有在有高性能需求的时候才会用到吧。</p>
<h4 id="deques-and-other-queues"><a class="markdownIt-Anchor" href="#deques-and-other-queues"></a> Deques and Other Queues</h4>
<p>The <code>.append</code> and <code>.pop</code> methods make a list as a stack or a queue (if you use <code>.pop(0)</code>), you get LIFO behavior. But inserting and removing form the left of a list(the 0-index end) is costly because the entire list must be shifted.</p>
<p>The class <code>collections.deque</code> is a <strong>thread-safe double-end</strong> queue designed for fast inserting and removing from both ends.And a queue can be bounded, when it is full, it discards items from the opposite end when you append new one.</p>
<p>Note:<br />
Removing items from the middle of a deque is not fast.<br />
THe <code>append</code> and <code>popleft</code> operations are atomic, so deque is safe to use as a LIFO queue in multithreaded aoolications wihtout th need for <em>lock</em>.</p>
<h2 id="dictionaries-and-sets"><a class="markdownIt-Anchor" href="#dictionaries-and-sets"></a> Dictionaries and Sets</h2>
<h3 id="generic-mapping-types"><a class="markdownIt-Anchor" href="#generic-mapping-types"></a> Generic Mapping Types</h3>
<h4 id="what-is-hashabe"><a class="markdownIt-Anchor" href="#what-is-hashabe"></a> What Is Hashabe?</h4>
<p>A object is hashable if it has a hash value which never change guring its lifetime (it needs a <code>__hash__()</code> method). and can be compared to other objects (it needs an <code>__eq__()</code> method). Hashable objects which compare equal must have the same hash value.</p>
<p>The atomic immutable types(str, bytes, numeric types) are all hashable. A <code>frozen Set</code> si aways hashable, because its elements must be hashable by definition. A <code>tuple</code> is hashable <em>only if</em> all its items are hashable.</p>
<h4 id="various-means-of-building-a-dict"><a class="markdownIt-Anchor" href="#various-means-of-building-a-dict"></a> Various means of building a dict</h4>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = dict(one=<span class="number">1</span>, two=<span class="number">2</span>, three=<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = &#123;<span class="string">'one'</span>: <span class="number">1</span>, <span class="string">'two'</span>: <span class="number">2</span>, <span class="string">'three'</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = dict(zip([<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>],[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = dict([(<span class="string">'two'</span>, <span class="number">2</span>),(<span class="string">'one'</span>, <span class="number">1</span>), (<span class="string">'three'</span>, <span class="number">3</span>)])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e = dict(&#123;<span class="string">'three'</span>: <span class="number">3</span>, <span class="string">'one'</span>: <span class="number">1</span>, <span class="string">'two'</span>: <span class="number">2</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a == b == c == d == e</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h3 id="overview-of-common-mapping-methods"><a class="markdownIt-Anchor" href="#overview-of-common-mapping-methods"></a> Overview of Common Mapping Methods</h3>
<h4 id="defaultdict"><a class="markdownIt-Anchor" href="#defaultdict"></a> defaultdict</h4>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>counts = dict()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>counts</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>counts[<span class="string">'puppy'</span>] += <span class="number">1</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">KeyError: <span class="string">'puppy'</span></span><br></pre></td></tr></table></figure>
<p>第一次对单词进行统计时，会抛出 KeyError，为此可以通过加判断解决：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">strings = (<span class="string">'puppy'</span>, <span class="string">'kitten'</span>, <span class="string">'puppy'</span>, <span class="string">'puppy'</span>,</span><br><span class="line">           <span class="string">'weasel'</span>, <span class="string">'puppy'</span>, <span class="string">'kitten'</span>, <span class="string">'puppy'</span>)</span><br><span class="line">counts = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> kw <span class="keyword">in</span> strings:</span><br><span class="line">    <span class="keyword">if</span> kw <span class="keyword">not</span> <span class="keyword">in</span> counts:</span><br><span class="line">        counts[kw] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        counts[kw] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># counts:</span></span><br><span class="line"><span class="comment"># &#123;'puppy': 5, 'weasel': 1, 'kitten': 2&#125;</span></span><br></pre></td></tr></table></figure>
<p>也可以通过<code>dict.setdefault()</code>方法来设置默认值：<br />
<code>setdefault(kw, 0)</code>中如果 kw 存在则返回键 kw 所对应的值，若不存在则返回 0</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">strings = (<span class="string">'puppy'</span>, <span class="string">'kitten'</span>, <span class="string">'puppy'</span>, <span class="string">'puppy'</span>,</span><br><span class="line">           <span class="string">'weasel'</span>, <span class="string">'puppy'</span>, <span class="string">'kitten'</span>, <span class="string">'puppy'</span>)</span><br><span class="line">counts = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> kw <span class="keyword">in</span> strings:</span><br><span class="line">    counts[kw] = counts.setdefault(kw, <span class="number">0</span>) + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>当然更简洁的的方式是通过使用 defaultdict 解决：<br />
<code>defaultdict()</code>接受一个<code>default_factory()</code>将其返回值作为默认值</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line">strings = (<span class="string">'puppy'</span>, <span class="string">'kitten'</span>, <span class="string">'puppy'</span>, <span class="string">'puppy'</span>,</span><br><span class="line">           <span class="string">'weasel'</span>, <span class="string">'puppy'</span>, <span class="string">'kitten'</span>, <span class="string">'puppy'</span>)</span><br><span class="line">counts = defaultdict(<span class="keyword">lambda</span>: <span class="number">0</span>)  <span class="comment"># 使用 lambda 来定义简单的函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> strings:</span><br><span class="line">    counts[s] += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>The <code>default_factory</code> of a <code>defaultdict</code> is only invoked to provide default values for <code>__getitem</code> calls, and not for the other methods. For example:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd = collections.defaultdict() </span><br><span class="line"><span class="comment">#if no default_factory is provided, the usual KeyError is raised for missing keys</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd[<span class="string">'key'</span>]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">KeyError: <span class="string">'key'</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd</span><br><span class="line">defaultdict(<span class="literal">None</span>, &#123;&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd = collections.defaultdict(list)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd[<span class="string">'key'</span>]</span><br><span class="line">[]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd.get(<span class="string">'kk'</span>)    <span class="comment"># dd.get() still return None</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd.get(<span class="string">'key'</span>)</span><br><span class="line">[]</span><br></pre></td></tr></table></figure>
<h3 id="mapping-with-flexible-key-lookup"><a class="markdownIt-Anchor" href="#mapping-with-flexible-key-lookup"></a> Mapping with Flexible Key Lookup</h3>
<p>对于<code>dic = {'2': 'two', '4': 'four'}</code> 同时支持数字和字符串<code>2, '2'</code>索引</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrKeyDict</span><span class="params">(dict)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__missing__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(key, str):</span><br><span class="line">            <span class="keyword">raise</span> KeyError(key)</span><br><span class="line">        <span class="keyword">return</span> self[str(key)]</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key, default=None)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> self[key]</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">        <span class="comment"># If a KeyError was raised, __missing__ already failed, so we return default</span></span><br><span class="line">            <span class="keyword">return</span> default  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__contains__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> key <span class="keyword">in</span> self.keys() <span class="keyword">or</span> str(key) <span class="keyword">in</span> self.keys()</span><br><span class="line"></span><br><span class="line">d = StrKeyDict(&#123;<span class="string">'2'</span>: <span class="string">'two'</span>, <span class="string">'4'</span>: <span class="string">'four'</span>&#125;)</span><br><span class="line">print(d)</span><br><span class="line">print(d[<span class="number">2</span>],d[<span class="string">'4'</span>])</span><br><span class="line">print(<span class="number">2</span> <span class="keyword">in</span> d)</span><br></pre></td></tr></table></figure>
<p>Why is the test <code>isinstance(key, str)</code> necessary:<br />
没有这个判断的话，会进入 <em>不存在-&gt;转换为字符串-&gt;查找-&gt;不存在</em> 的死循环</p>
<p>Why not check for the key in the usual Pythonic way – key in my_dict:<br />
It will call <code>__contains__</code> recursively</p>
<p>在 python3 中<code>dict.keys()</code>返回一个类似与<code>set</code>的<code>view</code>, 而 check <code>k in my_set</code>是很高效的，而 python2 中其返回 list, 因此效率不高。</p>
<h3 id="immutable-mapping"><a class="markdownIt-Anchor" href="#immutable-mapping"></a> Immutable Mapping</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> types <span class="keyword">import</span> MappingProxyType</span><br><span class="line">dic = &#123;<span class="number">1</span>: <span class="string">'A'</span>&#125;</span><br><span class="line">d_proxy = MappingProxyType(dic)</span><br></pre></td></tr></table></figure>
<p>创建一个只读的代理字典，遂原始对象同步更新，但不可更改</p>
<h3 id="set-theory"><a class="markdownIt-Anchor" href="#set-theory"></a> Set Theory</h3>
<p>frozenset: the immutable sibling of <code>set</code></p>
<p>Set elements must be hashable. The set type is not hashable, but frozenset is, so you can have frozenset elements inside a set.</p>
<p>Count occurrences of needles in a haystack:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">found = len(set(needle) &amp; set(haystack))</span><br><span class="line"></span><br><span class="line">found = len(set(needle).intersection(haystack))</span><br></pre></td></tr></table></figure>
<p>In Python3, the standard string representation of sets always uses the {…} notation, except for the empty set which uses set().</p>
<p>Calling the constructor is slower because, to evaluate it, Python has to look up the set name to fetch the constructor, then build a list, and ginally pass it to the constructor.</p>
<p>中缀操作符要求两边都是 set, 函数只要 iterable 就行。</p>
<h3 id="dict-and-set-under-the-hood"><a class="markdownIt-Anchor" href="#dict-and-set-under-the-hood"></a> dict and set Under the Hood</h3>
<p>Key ordering depends on insertion order.</p>
<p><code>dict([(key1,value1), (key2, value2)])</code> == <code>dict([(key2, value2),(key1,value1)])</code>, but their key ordering may not be the same if the hashes of key1 and key2 collide.</p>
<h4 id="adding-items-to-a-dict-may-change-the-oder-of-existing-keys"><a class="markdownIt-Anchor" href="#adding-items-to-a-dict-may-change-the-oder-of-existing-keys"></a> Adding items to a dict may change the oder of existing keys</h4>
<p>When you add a new item to a dict, the Python interpreter may decide that the hash table of that dict needs to grow. This entails building a new, bigger hash table, and adding all current items to the new one. During this process, new (but different) hash collisions may happen, with the result that the kays are likely to ordered differently. And you <strong>can’t predict</strong> when it will happen.</p>
<p>This is why modifying the contents of a dict while iterating through it is a bad idea. If you need to scan and add ites to a dict, do in two steps:</p>
<ol>
<li>read the dict from start to end and collect the needed additions in a second dict</li>
<li>updata the first one with it.</li>
</ol>
<p>In Python3, the <code>.keys(), .items(), .values()</code>return <code>views</code>, which behave like set and are dynamic: they do not replicate the contents of dict, and they immediately reflect any changes to the dict.</p>
<h2 id="text-versus-bytes"><a class="markdownIt-Anchor" href="#text-versus-bytes"></a> Text versus Bytes</h2>
<h3 id="character-issues"><a class="markdownIt-Anchor" href="#character-issues"></a> Character Issues</h3>
<p>The Unicode standard explicitly seperates the identity of characters from specific byte representation:</p>
<ul>
<li>The identity of charater – its <em>code points</em> – is a number from 0 to 1114111 (U+10FFFF), shown in Unicode standard as 4 to 6 hexadecimal digits with a “U+” prefix.</li>
<li>The actual vytes that represent a character depends on the <em>encoding</em> in use. An encoding is an algorithm that converts code point to byte sequences and vice versa. The code point for A (U+0041) is encoded as the single byte \x41 in the UTF-8 encoding, or as the bytes \x41\x00 in UTF-16LE encoding. As another example, the Euro sign (U+20AC) becomes three bytes in UTF-8 (\xe2\x82\xac) but in UTF-16LE it is encoded as two bytes: \xac\x20.</li>
</ul>
<h3 id="byte-essentials"><a class="markdownIt-Anchor" href="#byte-essentials"></a> Byte Essentials</h3>
<p>There are two basic built-in types for binary sequences: the immutable <code>bytes</code> type introduced in Python3 and the mutable <code>bytearray</code> added in Python2.6.</p>
<p>Each item in bytes is an int. A slice of a binary sequence always produces a binary sequence, even slices of 1 length 1.</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>cafe = bytes(<span class="string">'café'</span>, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cafe</span><br><span class="line"><span class="string">b'caf\xc3\xa9'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(cafe[<span class="number">0</span>])</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">int</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">type</span><span class="params">(cafe[:<span class="number">1</span>])</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">bytes</span>'&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line">&gt;&gt;&gt; cafe_arr  =bytearray(cafe)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cafe_arr</span><br><span class="line">bytearray(<span class="string">b'caf\xc3\xa9'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cafe_arr[<span class="number">-1</span>:]</span><br><span class="line">bytearray(<span class="string">b'\xa9'</span>)</span><br></pre></td></tr></table></figure>
<p>The only sequence type where <code>s[0] == s[:1]</code> is <code>str</code> type.</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>cafe_str = cafe.decode(<span class="string">'utf-8'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cafe_str[<span class="number">0</span>] == cafe_str[:<span class="number">1</span>]</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>Three differents displays are used, depending on each byte value:</p>
<ul>
<li>For bytes in printable ASCII, the ASCII character itself is used</li>
<li>For bytes corresponding to tab, newline, carriage return and <code>\</code>, the escape sequences <code>\t, \n, \r and \\</code> are used.</li>
<li>For other byte value, a hexadecimal escape sequnece is used.</li>
</ul>
<p>Both <code>bytes and bytearray</code> support every <code>str</code> method except those that do formatting and a few others that depend on Unicode data, including <code>casefold, isdecimal, isidentifier, isnumeric, isprintable, and encode</code>.</p>
<p>Binary sequences have a method that <code>str</code> doesn’t have – <code>fromhex</code>:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bytes.fromhex(<span class="string">'31 4B CE A9'</span>)</span><br><span class="line"><span class="string">b'1K\xce\xa9'</span></span><br></pre></td></tr></table></figure>
<h4 id="structs-and-memory-views"><a class="markdownIt-Anchor" href="#structs-and-memory-views"></a> Structs and Memory Views</h4>
<p>// 内存操作相关，没怎么用到，碰到了再补上。</p>
<h3 id="understanding-encodedecode-problems"><a class="markdownIt-Anchor" href="#understanding-encodedecode-problems"></a> Understanding Encode/Decode Problems</h3>
<h4 id="coping-with-unicodeerror"><a class="markdownIt-Anchor" href="#coping-with-unicodeerror"></a> coping with UnicodeError</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; str &#x3D; &#39;café&#39;</span><br><span class="line">&gt;&gt;&gt; str.encode(&#39;utf-8&#39;)</span><br><span class="line">b&#39;caf\xc3\xa9&#39;</span><br><span class="line">&gt;&gt;&gt; str.encode(&#39;gb2312&#39;)</span><br><span class="line">b&#39;caf\xa8\xa6&#39;</span><br><span class="line">&gt;&gt;&gt; str.encode(&#39;ascii&#39;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">UnicodeEncodeError: &#39;ascii&#39; codec can&#39;t encode character &#39;\xe9&#39; in position 3: ordinal not in range(128)</span><br><span class="line">&gt;&gt;&gt; str.encode(&#39;ascii&#39;, errors&#x3D;&#39;ignore&#39;)</span><br><span class="line">b&#39;caf&#39;</span><br><span class="line">&gt;&gt;&gt; str.encode(&#39;ascii&#39;, errors&#x3D;&#39;replace&#39;)</span><br><span class="line">b&#39;caf?&#39;</span><br><span class="line">&gt;&gt;&gt; str.encode(&#39;ascii&#39;, errors&#x3D;&#39;xmlcharrefreplace&#39;)</span><br><span class="line">b&#39;caf&amp;#233;&#39;</span><br></pre></td></tr></table></figure>
<h3 id="handling-text-files"><a class="markdownIt-Anchor" href="#handling-text-files"></a> Handling Text Files</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; open(&#39;cafe.txt&#39;, &#39;w&#39;, encoding&#x3D;&#39;utf-8&#39;).write(&#39;café&#39;)</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; open(&#39;cafe.txt&#39;).read()</span><br><span class="line">&#39;caf 茅&#39;</span><br><span class="line">&gt;&gt;&gt; open(&#39;cafe.txt&#39;, &#39;w&#39;, encoding&#x3D;&#39;utf-8&#39;).write(&#39;中国&#39;)</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; open(&#39;cafe.txt&#39;).read()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">UnicodeDecodeError: &#39;gbk&#39; codec can&#39;t decode byte 0xad in position 2: illegal multibyte sequence</span><br></pre></td></tr></table></figure>
<h3 id="normalizing-unicode-for-saner-comparisons"><a class="markdownIt-Anchor" href="#normalizing-unicode-for-saner-comparisons"></a> Normalizing Unicode for Saner Comparisons</h3>
<p>Unicode 中有一些附加字符 (combining character), 附加在前一个字符上，但在 print 的时候显示成一个字符，如：<br />
<code>'cafe\u0301'</code>  与 <code>'café'</code> 应该输出一样的结果，这成为规范等价 (canonical equivalent).</p>
<p>在 Python 中，二者并不等价，需要 <code>from unicodedata import normalize</code> 对字符进行转换。<br />
// TODO 了解一下，用到再查好了</p>
<h2 id="first-class-functions"><a class="markdownIt-Anchor" href="#first-class-functions"></a> First-Class Functions</h2>
<p>“first-class object” as a program entity that can be:</p>
<ul>
<li>Created at runtime</li>
<li>Assigned to a variable or element in a data structure</li>
<li>Passed as an argument to a function</li>
<li>Returned as the result of a functio</li>
</ul>
<p>A function that takes a function as argument or returns a function as the result is a higher-order function, like <code>map</code> and <code>sort</code>.</p>
<h3 id="the-seven-flavors-of-callable-objects"><a class="markdownIt-Anchor" href="#the-seven-flavors-of-callable-objects"></a> The Seven Flavors of Callable Objects</h3>
<p>The Python Data Model documentation lists seven callable types:</p>
<ul>
<li>
<p>User-defined functions<br />
Created with def statements or lambda expressions.</p>
</li>
<li>
<p>Built-in functions<br />
A function implemented in C (for CPython), like len or time.strftime.</p>
</li>
<li>
<p>Built-in methods<br />
Methods implemented in C, like dict.get.</p>
</li>
<li>
<p>Methods<br />
Functions defined in the body of a class.</p>
</li>
<li>
<p>Classes<br />
When invoked, a class runs its <code>__new__</code> method to create an instance, then <code>__init__</code> to initialize it, and finally the instance is returned to the caller. Because there is no new operator in Python, calling a class is like calling a function. (Usually calling a class creates an instance of the same class, but other behaviors are possible by overriding <code>__new__</code>. We’ll see an example of this in “Flexible Object Creation with <code>__new__</code>” on page 592.)</p>
</li>
<li>
<p>Class instances<br />
If a class defines a <code>__call__</code> method, then its instances may be invoked as functions. See “User-Defined Callable Types” on page 145.</p>
</li>
<li>
<p>Generator functions<br />
Functions or methods that use the yield keyword. When called, generator functions return a generator object.</p>
</li>
</ul>
<p>Generator functions are unlike other callables in many respects. Chapter 14 is devoted to them. They can also be used as coroutines, which are covered in Chapter 16.</p>
<p>Not only are Python functions real objects, but arbitrary Python objects may also be made to behave like functions. Implementing a <code>__call__</code> instance method is all it takes.</p>
<h3 id="retrieving-information-about-parameters"><a class="markdownIt-Anchor" href="#retrieving-information-about-parameters"></a> Retrieving Information About Parameters</h3>
<p>// TODO</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>常见机器学习算法的优缺点</title>
    <url>/2019/12/ML_algorithm/</url>
    <content><![CDATA[<p>想要寻找一个合适的算法不容易，实际应用中，我们一般采用启发式实验。</p>
<p>没有免费的午餐定理 (NFL)：核心在于，假设了所有问题出现的机会相同，或所有问题同等重要。当需求是解决一切问题时，“哪个算法更好”就毫无意义。HG2G 中“深思”面对“宇宙、生命以及一切的中继答案是什么？”这样一个问题，用最复杂的算法算出一个 42 和随便说一个 42 是一样的。</p>
<h2 id="偏差与方差"><a class="markdownIt-Anchor" href="#偏差与方差"></a> 偏差与方差</h2>
<ul>
<li>偏差：描述的是估计值的期望 E 与真实值 Y 之间的差距。偏差越大，越偏离真实数据。</li>
<li>方差：描述的是预测值的离散程度，方差越大，数据分布约分散。</li>
<li>模型的真实误差可以看成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mi>i</mi><mi>a</mi><msup><mi>s</mi><mn>2</mn></msup><mo>+</mo><mi>v</mi><mi>a</mi><mi>r</mi><mo>+</mo><msup><mi>σ</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">bias^2 + var + \sigma^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>σ</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\sigma^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> 是噪音</li>
</ul>
<p>偏差与方差窘境：</p>
<ul>
<li>学得不好，偏差大</li>
<li>学得好，敏感性高，方差大。</li>
</ul>
<a id="more"></a>
<p>通常情况下</p>
<ul>
<li>小训练集，高偏差/低方差的分类器（例如，朴素贝叶斯 NB）要比低偏差/高方差大分类的优势大（例如，KNN），因为后者会发生过拟合（overfitting）。</li>
<li>随着训练集增长，此时低偏差/高方差的分类器在训练集上性能变好，偏差降低，就会渐渐的表现其优势（因为它们有较低的渐近误差），而高偏差分类器的偏差难以下降。</li>
</ul>
<p>特征选择：最小冗余/最大相关（<em>Minimum Redundancy Maximum Relevance</em>， mRMR）</p>
<h2 id="常见算法的优缺点"><a class="markdownIt-Anchor" href="#常见算法的优缺点"></a> 常见算法的优缺点</h2>
<h3 id="朴素贝叶斯-naive-bayes-classifier"><a class="markdownIt-Anchor" href="#朴素贝叶斯-naive-bayes-classifier"></a> 朴素贝叶斯 Naive Bayes classifier</h3>
<p>朴素贝叶斯假设数据之间是无关的，严重简化了模型。对于这样一个简单没顶，大部分时候表现出高偏差，低方差。</p>
<p>属于生成式模型，收敛速度快于判别式模型</p>
<p>优点：</p>
<ul>
<li>有坚实的数学理论基础，易解释，分类效率稳定，计算速度快</li>
<li>小规模数据表现好，能处理多分类任务，适合增量式训练</li>
<li>对缺失数据不敏感，常用于文本分类</li>
</ul>
<p>缺点：</p>
<ul>
<li>需要计算先验概率</li>
<li>使用了“属性条件独立性假设”，当属性之间有关联时效果较差</li>
<li>对输入数据的表达形式敏感</li>
</ul>
<p>应用领域：</p>
<ul>
<li>欺诈检测</li>
<li>文本分类</li>
<li>人脸识别</li>
</ul>
<h3 id="逻辑回归-logistic-regression"><a class="markdownIt-Anchor" href="#逻辑回归-logistic-regression"></a> 逻辑回归 Logistic Regression</h3>
<p>属于判别式模型，常和很多模型正则化方法（L0<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>，L1，L2）。能使用在线梯度下降法更新模型。</p>
<p>优点：</p>
<ul>
<li>实现简单，计算量小</li>
<li>有概率解释</li>
<li>能通过 L2 正则化解决多重共线性问题</li>
</ul>
<p>缺点：</p>
<ul>
<li>特征空间很大时，性能不好</li>
<li>容易欠拟合，一般准确性不高</li>
<li>不能很好地处理大量分类特征</li>
<li>只能处理线性二分类问题（多分类使用 softmax）</li>
</ul>
<p>应用领域：</p>
<ul>
<li>适用于根据概率排名的应用，如搜索排名</li>
</ul>
<h3 id="线性回归"><a class="markdownIt-Anchor" href="#线性回归"></a> 线性回归</h3>
<p>Normal Equation 优化结果：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>ω</mi><mo>^</mo></mover><mo>=</mo><mo stretchy="false">(</mo><msup><mi>X</mi><mi>T</mi></msup><mi>X</mi><msup><mo stretchy="false">)</mo><mrow><mo>−</mo><mn>1</mn></mrow></msup><msup><mi>X</mi><mi>T</mi></msup><mi>y</mi></mrow><annotation encoding="application/x-tex">\hat{\omega} = (X^TX)^{-1}X^Ty
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;">^</span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1413309999999999em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span></span></p>
<p>局部加权线性回归（LWLR）优化结果：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable rowspacing="0.24999999999999992em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mover accent="true"><mi>ω</mi><mo>^</mo></mover><mo>=</mo><mo stretchy="false">(</mo><msup><mi>X</mi><mi>T</mi></msup><mi>W</mi><mi>X</mi><msup><mo stretchy="false">)</mo><mrow><mo>−</mo><mn>1</mn></mrow></msup><msup><mi>X</mi><mi>T</mi></msup><mi>W</mi><mi>y</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><msub><mi>w</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><mi>e</mi><mi>x</mi><mi>p</mi><mrow><mo fence="true">(</mo><mfrac><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><msub><mi>x</mi><mi>j</mi></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><mrow><mn>2</mn><msup><mi>k</mi><mn>2</mn></msup></mrow></mfrac><mo fence="true">)</mo></mrow></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{gathered}
\hat{\omega} = (X^T W X)^{-1} X^T W y  \\

w_{ij} = exp\left(\frac{(x_i - x_j)^2}{2k^2}\right)
\end{gathered}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.2924690000000005em;vertical-align:-1.8962345000000003em;"></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.3962345000000003em;"><span style="top:-4.9960115em;"><span class="pstrut" style="height:3.4911079999999997em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;">^</span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-2.8449034999999996em;"><span class="pstrut" style="height:3.4911079999999997em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.4911079999999999em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.8962345000000003em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>LWLR 是非参数模型，每次进行回归计算都需要遍历训练样本。</p>
<p>优点：实现简单，计算简单</p>
<p>缺点：不能拟合非线性关系</p>
<h3 id="knn"><a class="markdownIt-Anchor" href="#knn"></a> KNN</h3>
<p>关键在于 K 值的选择，K 值较大能够减少噪声的影响，但会使类别之间的界限变模糊。噪声和非相关性特征向量的存在会使 K 近邻算法的准确性减小。数据密度很大时，KNN 的泛化错误率不会超过贝叶斯最优分类器错误率的两倍。</p>
<p>优点：</p>
<ul>
<li>思路简单，可分类，可回归</li>
<li>可用于非线性分类</li>
<li>对数据没有假设，对离群点不敏感</li>
<li>惰性学习，新增数据无需重新训练</li>
</ul>
<p>缺点：</p>
<ul>
<li>样本不平衡时效果差，bias 大</li>
<li>需要大量内存</li>
<li>预测时需要全局计算，计算量大</li>
</ul>
<p>应用领域：</p>
<ul>
<li>文本分类</li>
<li>模式识别</li>
<li>多分类</li>
</ul>
<h3 id="决策树"><a class="markdownIt-Anchor" href="#决策树"></a> 决策树</h3>
<p>优点：</p>
<ul>
<li>易于解释，可以可视化，容易提取规则</li>
<li>可以同时处理连续变量和分类变量</li>
<li>对属性缺失不敏感</li>
</ul>
<p>缺点：</p>
<ul>
<li>
<p>容易过拟合（通过随机森林减轻）</p>
</li>
<li>
<p><mark>容易忽略数据集中属性的相互关联</mark></p>
</li>
<li>
<p>样本不平衡的情况下，进行属性划分时，不同的判定准则有不同的属性选择倾向；</p>
<ul>
<li>信息增益准则对可取数目较多的属性有所偏好（典型代表 ID3 算法）</li>
<li>增益率准则（CART）则对可取数目较少的属性有所偏好，CART 进行属性划分时候不再简单地直接利用增益率进行划分，而是采用一种启发式规则</li>
<li>只要是使用了信息增益，都有这个缺点，如 RF</li>
</ul>
</li>
</ul>
<p>应用领域：</p>
<ul>
<li>决策类</li>
</ul>
<h3 id="svm"><a class="markdownIt-Anchor" href="#svm"></a> SVM</h3>
<p>优点：</p>
<ul>
<li>可以解决高维问题，即特征空间很大的问题</li>
<li>小样本下也有不错的表现</li>
<li>能处理非线性特征的相互作用（利用核函数）</li>
<li>无局部最小值问题（相对于神经网络）</li>
<li>不依赖所有数据</li>
<li>泛化能力强</li>
</ul>
<p>缺点：</p>
<ul>
<li>当观测样本很多，效率不高</li>
<li>对非线性问题没有通用解决方案，很难找到一个合适的核函数</li>
<li>对核函数的高维映射解释力不强，尤其是高斯核</li>
<li>对缺失数据敏感</li>
</ul>
<p>核函数的选择：libsvm 中自带了四种核函数：线性核、多项式核、RBF 以及 sigmoid 核</p>
<ul>
<li>如果样本数量小于特征数，那么就没必要选择非线性核，简单的使用线性核就可以了；</li>
<li>如果样本数量大于特征数目，这时可以使用非线性核，将样本映射到更高维度，一般可以得到更好的结果；</li>
<li>如果样本数目和特征数目相等，该情况可以使用非线性核，原理和第二种一样</li>
</ul>
<p>应用：</p>
<ul>
<li>文本分类</li>
<li>图像分类</li>
</ul>
<h3 id="人工神经网络"><a class="markdownIt-Anchor" href="#人工神经网络"></a> 人工神经网络</h3>
<p>优点：</p>
<ul>
<li>分类的准确度高；</li>
<li>并行分布处理能力强，分布存储及学习能力强，</li>
<li>对噪声神经有较强的鲁棒性和容错能力；</li>
<li>具备联想记忆的功能，能充分逼近复杂的非线性关系</li>
</ul>
<p>缺点：</p>
<ul>
<li>神经网络需要大量的参数，如网络拓扑结构、权值和阈值的初始值；</li>
<li>黑盒过程，不能观察之间的学习过程，输出结果难以解释，会影响到结果的可信度和可接受程度；</li>
<li>学习时间过长，有可能陷入局部极小值，甚至可能达不到学习的目的。</li>
</ul>
<h3 id="k-means-聚类"><a class="markdownIt-Anchor" href="#k-means-聚类"></a> K-Means 聚类</h3>
<p>优点</p>
<ul>
<li>算法简单，容易实现 ，算法速度很快；</li>
<li>对处理大数据集，该算法是相对可伸缩的和高效率的，因为它的复杂度大约是 O(nkt)，其中 n 是所有对象的数目，k 是簇的数目，t 是迭代的次数。通常 <code>k &lt;&lt; n</code>，这个算法<strong>通常局部收敛</strong>。</li>
<li>算法尝试找出使平方误差函数值最小的 k 个划分。当簇是密集的、球状或团状的，且簇与簇之间区别明显时，聚类效果较好。</li>
</ul>
<p>缺点</p>
<ul>
<li>对数据类型要求较高，适合数值型数据；</li>
<li>可能收敛到局部最小值，在大规模数据上收敛较慢</li>
<li>分组的数目 k 是一个输入参数，不合适的 k 可能返回较差的结果。</li>
<li>对初始的簇心值敏感</li>
<li>不适合于发现非凸面形状的簇，或者大小差别很大的簇</li>
<li>对于”噪声”和孤立点数据敏感</li>
</ul>
<h3 id="em-最大期望算法"><a class="markdownIt-Anchor" href="#em-最大期望算法"></a> EM 最大期望算法</h3>
<p>EM 算法是基于模型的聚类方法，是在概率模型中寻找参数最大似然估计的算法，其中概率模型依赖于无法观测的隐藏变量。E 步估计隐含变量，M 步估计其他参数，交替将极值推向最大。</p>
<ul>
<li>
<p>EM 算法比 K-means 算法计算复杂，收敛也较慢，不适于大规模数据集和高维数据，</p>
</li>
<li>
<p>比 K-means 算法计算结果稳定、准确。</p>
</li>
</ul>
<p>应用：</p>
<ul>
<li>机器学习和计算机视觉的数据集聚（Data Clustering）</li>
</ul>
<h3 id="adaboost"><a class="markdownIt-Anchor" href="#adaboost"></a> AdaBoost</h3>
<p>一种经典的 boosting 算法，每个模型都是基于上一次模型的错误率来建立的，增加错误分类样本的权重，而对正确分类的样本减少关注度，逐次迭代之后，可以得到一个相对较好的模型。</p>
<p>优点：</p>
<ul>
<li>精度高</li>
<li>可以使用各种方法构建子分类器，Adaboost 提供的是框架</li>
<li>当使用简单分类器时，计算结果可以理解</li>
<li>不需要特征筛选，不易 overfitting</li>
<li>相对于 bagging 算法和 RF，AdaBoost 充分考虑了每个分类器的权重</li>
</ul>
<p>缺点：</p>
<ul>
<li>对 outlier 敏感，对样本平衡性敏感</li>
<li>迭代次数不易确定</li>
</ul>
<p><mark>Adaboost, GBDT 及 XGBoost 比较</mark></p>
<h3 id="关联规则算法"><a class="markdownIt-Anchor" href="#关联规则算法"></a> 关联规则算法</h3>
<p>Apriori 算法是一种挖掘关联规则的算法，用于挖掘其内含的、未知的却又实际存在的数据关系。</p>
<p>常用的频繁项集的评估标准有支持度，置信度和提升度三个。</p>
<p>支持度就是几个关联的数据在数据集中出现的次数占总数据集的比重。或者说几个数据关联出现的概率。如果我们有两个想分析关联性的数据 X 和 Y，则对应的支持度为：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>u</mi><mi>p</mi><mi>p</mi><mi>o</mi><mi>r</mi><mi>t</mi><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>P</mi><mo stretchy="false">(</mo><mi>X</mi><mi>Y</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>b</mi><mi>e</mi><mi>r</mi><mo stretchy="false">(</mo><mi>X</mi><mi>Y</mi><mo stretchy="false">)</mo></mrow><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mo stretchy="false">(</mo><mi>A</mi><mi>l</mi><mi>l</mi><mi>S</mi><mi>a</mi><mi>m</mi><mi>p</mi><mi>l</mi><mi>e</mi><mi>s</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">Support(X,Y)=P(XY)=\frac{number(XY)}{num(AllSamples)}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">u</span><span class="mord mathdefault">p</span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">b</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>置信度体现了一个数据出现后，另一个数据出现的概率，或者说数据的条件概率。如果我们有两个想分析关联性的数据 X 和 Y，X 对 Y 的置信度为</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mi>o</mi><mi>n</mi><mi>f</mi><mi>i</mi><mi>d</mi><mi>e</mi><mi>n</mi><mi>c</mi><mi>e</mi><mo stretchy="false">(</mo><mi>X</mi><mo>⇐</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>P</mi><mo stretchy="false">(</mo><mi>X</mi><mi mathvariant="normal">∣</mi><mi>Y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>P</mi><mo stretchy="false">(</mo><mi>X</mi><mi>Y</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>P</mi><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Confidence(X \Leftarrow Y)=P(X|Y)=P(XY)/P(Y)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">c</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇐</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span></span></span></span></span></p>
<p>提升度表示含有 Y 的条件下，同时含有 X 的概率，与 X 总体发生的概率之比，即：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>i</mi><mi>f</mi><mi>t</mi><mo stretchy="false">(</mo><mi>X</mi><mo>⇐</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>P</mi><mo stretchy="false">(</mo><mi>X</mi><mi mathvariant="normal">∣</mi><mi>Y</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>P</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo><mi>C</mi><mi>o</mi><mi>n</mi><mi>f</mi><mi>i</mi><mi>d</mi><mi>e</mi><mi>n</mi><mi>c</mi><mi>e</mi><mo stretchy="false">(</mo><mi>X</mi><mo>⇐</mo><mi>Y</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>P</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Lift(X \Leftarrow Y) = P(X|Y)/P(X) = Confidence(X \Leftarrow Y)/P(X)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇐</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">c</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇐</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span></span></p>
<p>提升度体先了 X 和 Y 之间的关联关系，提升度大于 1 则<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mo>⇐</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \Leftarrow Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇐</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span>是有效的强关联规则， 提升度小于等于 1 则<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mo>⇐</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \Leftarrow Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇐</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span>是无效的强关联规则 。一个特殊的情况，如果 X 和 Y 独立，则有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>i</mi><mi>f</mi><mi>t</mi><mo stretchy="false">(</mo><mi>X</mi><mo>⇐</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">Lift(X⇐Y)=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇐</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，因为此时<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>X</mi><mi mathvariant="normal">∣</mi><mi>Y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>P</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(X|Y)=P(X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span></p>
<p><a href="https://bainingchao.github.io/2018/09/27/%E4%B8%80%E6%AD%A5%E6%AD%A5%E6%95%99%E4%BD%A0%E8%BD%BB%E6%9D%BE%E5%AD%A6%E5%85%B3%E8%81%94%E8%A7%84%E5%88%99Apriori%E7%AE%97%E6%B3%95/" target="_blank" rel="noopener">learn more</a></p>
<h2 id="算法选择参考"><a class="markdownIt-Anchor" href="#算法选择参考"></a> 算法选择参考</h2>
<p>一个简单的算法选择技巧：</p>
<ol>
<li>x 先逻辑回归，如果它的效果不怎么样，那么可以将它的结果作为基准来参考，在基础上与其他算法进行比较；</li>
<li>然后试试决策树（随机森林）看看是否可以大幅度提升你的模型性能。即便最后你并没有把它当做为最终模型，你也可以使用随机森林来移除噪声变量，做特征选择；</li>
<li>如果特征的数量和观测样本特别多，那么当资源和时间充足时（这个前提很重要），使用 SVM 不失为一种选择。</li>
</ol>
<p>通常情况下：GBDT &gt;= SVM &gt;= RF &gt;= Adaboost &gt;= Other</p>
<p>算法固然重要，<strong>但好的数据却要优于好的算法</strong>，设计优良特征是大有裨益的。假如你有一个超大数据集，那么无论你使用哪种算法可能对分类性能都没太大影响（此时就可以根据速度和易用性来进行抉择）。</p>
<hr class="footnotes-sep" />
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>L0 正则化的值是模型参数中非零参数的个数 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>AI</category>
      </categories>
  </entry>
  <entry>
    <title>《经济学原理：微观经济学分册》 读书笔记</title>
    <url>/2019/11/Principles-of-Economics-Micro/</url>
    <content><![CDATA[<h2 id="一-经济学十大原理"><a class="markdownIt-Anchor" href="#一-经济学十大原理"></a> 一、经济学十大原理</h2>
<h3 id="个人决策"><a class="markdownIt-Anchor" href="#个人决策"></a> 个人决策</h3>
<ul>
<li>人们面临权衡取舍</li>
<li>某种东西的成本是为了得到它所放弃的东西</li>
<li>理性人考虑边际量</li>
<li>人们会对激励做出反应</li>
</ul>
<h3 id="人们如何交易"><a class="markdownIt-Anchor" href="#人们如何交易"></a> 人们如何交易</h3>
<ul>
<li>贸易可以使得每个人的状况变得更好</li>
<li>市场通常是组织经济活动的一种好方法</li>
<li>政府有时候可以改善市场结果</li>
</ul>
<h3 id="整体经济如何运行"><a class="markdownIt-Anchor" href="#整体经济如何运行"></a> 整体经济如何运行</h3>
<ul>
<li>一国的生活水平取决于它生产物品与劳务的能力</li>
<li>当政府发行了过多货币时，物价上升</li>
<li>社会面临通货膨胀和失业之间的短期权衡</li>
</ul>
<a id="more"></a>
<h2 id="二-像经济学家一样思考"><a class="markdownIt-Anchor" href="#二-像经济学家一样思考"></a> 二、像经济学家一样思考</h2>
<h3 id="微观经济学-vs-宏观经济学"><a class="markdownIt-Anchor" href="#微观经济学-vs-宏观经济学"></a> 微观经济学 VS 宏观经济学</h3>
<ul>
<li>微观经济学研究家庭和企业如何作出决策，以及他们在某个人市场上的相互交易。</li>
<li>宏观经济学研究整体经济现象。</li>
</ul>
<h3 id="实证分析与规范分析"><a class="markdownIt-Anchor" href="#实证分析与规范分析"></a> 实证分析与规范分析</h3>
<blockquote>
<p>A：最低工资法引起了失业。<br />
B：政府应该提高最低工资。</p>
</blockquote>
<p>A 的表述是实证的（empirical），描述性的，作出了关于世界是什么样的表述。B 的表述是规范的（normative），命令性的，作出关于世界应该是什么的表述。</p>
<p>实证表述和规范表述之间的主要差别是我们如何判断他们的正确性。我们可以通过验证数据（事实）确定或否定实证描述。与之相比，评价规范描述涉及到价值观和事实。</p>
<p>当经济学家作出规范表述时，他们已经从科学家变成了决策者。</p>
<h3 id="经济学家意见分歧"><a class="markdownIt-Anchor" href="#经济学家意见分歧"></a> 经济学家意见分歧</h3>
<p>经济学家提出看来相互矛盾的建议，基本原因有：</p>
<ul>
<li>经济学家可能对世界如何运行的不同实证理论的正确性看法不同。</li>
<li>经济学家可能有不同的价值观，因此对政策应该时间的目标有不同的规范观点。</li>
<li>不懂装懂的人的建议混淆了经济学家的共识。</li>
</ul>
<h2 id="三-相互依赖性与贸易的好处"><a class="markdownIt-Anchor" href="#三-相互依赖性与贸易的好处"></a> 三、相互依赖性与贸易的好处</h2>
<p>尽管一个人可能在两种物品的生产上都拥有绝对优势，但不可能在两种物品的生产上都拥有比较优势。（一种物品的机会成本是另一种物品的倒数）</p>
<p>专业化和贸易的好处不是基于<strong>绝对优势</strong>，而是基于<strong>比较优势</strong>。当每个人专门生产自己有比较优势的物品的时候，经济的生产总量就增加了。</p>
<p>对从贸易中获益的双方而言，<strong>贸易的价格</strong>在两种机会成本之间。</p>
<h2 id="四-供给与需求"><a class="markdownIt-Anchor" href="#四-供给与需求"></a> 四、供给与需求</h2>
<p>如果你想知道，任何一个事件或者政策将如何影响经济，你就应该先考虑它将如何影响供给和需求。</p>
<h3 id="市场与竞争"><a class="markdownIt-Anchor" href="#市场与竞争"></a> 市场与竞争</h3>
<p><strong>竞争市场</strong>：有许多买家与卖家，以至于每个人对市场的影响微乎其微</p>
<h2 id="弹性及其应用"><a class="markdownIt-Anchor" href="#弹性及其应用"></a> 弹性及其应用</h2>
<h4 id="决定因素"><a class="markdownIt-Anchor" href="#决定因素"></a> 决定因素</h4>
<ul>
<li>相近替代品的可获得性</li>
<li>必需品与奢侈品</li>
<li>市场的定义：范围小的市场弹性大于范围大的市场，如“香草冰淇淋”的弹性大于“食物”</li>
<li>时间框架：物品的需求往往在长期内更富有弹性</li>
</ul>
<h3 id="需求弹性"><a class="markdownIt-Anchor" href="#需求弹性"></a> 需求弹性</h3>
<blockquote>
<p>需求价格弹性 = 需求量变动的百分比 / 价格变动的百分比</p>
</blockquote>
<p>为使得从上升和减小两个方向计算结果一致，计算百分比时可以除以变化前后量的中位数</p>
<blockquote>
<p>需求收入弹性 = 需求量变动的百分比 / 收入变动的百分比</p>
</blockquote>
<h3 id="供给弹性"><a class="markdownIt-Anchor" href="#供给弹性"></a> 供给弹性</h3>
<blockquote>
<p>供给价格弹性 = 供给量变动的百分比 / 价格变动的百分比</p>
</blockquote>
<p>总收益增加还是减少取决于需求弹性</p>
<p>分析农业技术或农业政策的影响时要记住，对农民有利的不一定对整个社会也有利。</p>
<pre class="mermaid">graph LR
技术提升 --> 供给增加
供给增加 --> 价格降低
价格降低-- 需求弹性小 --> 农民总收益降低</pre>
<h2 id="供给需求与价格政策"><a class="markdownIt-Anchor" href="#供给需求与价格政策"></a> 供给/需求与价格政策</h2>
<h3 id="税收"><a class="markdownIt-Anchor" href="#税收"></a> 税收</h3>
<p>税收负担由交易双方分担；</p>
<p>税收负担更多地落在缺乏弹性的市场一方身上</p>
<h2 id="消费者-生产者和市场效率"><a class="markdownIt-Anchor" href="#消费者-生产者和市场效率"></a> 消费者、生产者和市场效率</h2>
<h3 id="消费者剩余"><a class="markdownIt-Anchor" href="#消费者剩余"></a> 消费者剩余</h3>
<p>买家愿意为一种物品支付的量减去实际支付的量，衡量了一个买家从一件物品中得到的自己感觉到的利益</p>
<p>需求曲线以下和价格以上的面积衡量一个市场上的消费者剩余</p>
<h3 id="生产者剩余"><a class="markdownIt-Anchor" href="#生产者剩余"></a> 生产者剩余</h3>
<p>卖家出售一种物品得到的量减去其生产成本</p>
<p>价格以下和供给曲线以上的面积衡量一个市场上的生产者剩余</p>
<h3 id="市场效率"><a class="markdownIt-Anchor" href="#市场效率"></a> 市场效率</h3>
<p>市场的总剩余是用买家支付意愿衡量的买家对物品的总评价减去卖家提供这些物品的总成本</p>
<p>总剩余=消费者剩余+生产者剩余——供给曲线和需求曲线到均衡数量之间的面积</p>
<h2 id="税收的代价"><a class="markdownIt-Anchor" href="#税收的代价"></a> 税收的代价</h2>
<p>税收引起无谓损失：税收引起的总剩余减少。<br />
买者和卖着由于税收受到的损失大于政府收入的增加。<br />
税收使得部分贸易无法发生。</p>
<h3 id="无谓损失的决定因素"><a class="markdownIt-Anchor" href="#无谓损失的决定因素"></a> 无谓损失的决定因素</h3>
<p>供给和需求弹性越大，税收的无谓损失越大。</p>
<h3 id="土地税"><a class="markdownIt-Anchor" href="#土地税"></a> 土地税</h3>
<p>土地的供给弹性为 0, 因此可以认为土地税没有改变市场配置，几乎没有无谓损失，政府的税收收入等于地主的损失。<br />
理论上正确，但仅对于未经过任何改良的处女地适用。经过改良的土地供给弹性大于零，地主对税收的反应是把更少的资源由于改良他们的土地。</p>
<h3 id="无谓损失和税收收入随税收变动"><a class="markdownIt-Anchor" href="#无谓损失和税收收入随税收变动"></a> 无谓损失和税收收入随税收变动</h3>
<p>税收无谓损失的增加要快于税收规模</p>
<p>随着税收规模提高，税收收入先增加，随着税收规模进一步扩大，市场收缩严重，以至于税收收入开始减小。</p>
<h2 id="国际贸易"><a class="markdownIt-Anchor" href="#国际贸易"></a> 国际贸易</h2>
<p>在小型经济假设下</p>
<h3 id="出口国的得失"><a class="markdownIt-Anchor" href="#出口国的得失"></a> 出口国的得失</h3>
<p>贸易迫使国内价格上升到世界价格，国内生产者受益，但消费者不得不以更高的价格购买。但总的剩余量增加，表明贸易提高了整个国家的经济福利。</p>
<h3 id="进口国得失"><a class="markdownIt-Anchor" href="#进口国得失"></a> 进口国得失</h3>
<p>对于物品的进口国，国内该物品消费者状况变好，而国内生产者的状况变差。<br />
赢家收益大于输家损失，一国的福利还是增加了。<br />
国际贸易开放是一种扩大经济蛋糕大小的政策，但也许会使一些经济参与者得到的蛋糕小了。</p>
<h3 id="关税的影响"><a class="markdownIt-Anchor" href="#关税的影响"></a> 关税的影响</h3>
<p>关税：对进口物品征收的税</p>
<p>关税使得国内生产者和消费者的收益和损失减少，政府获得税收收入，但相比关税前还是无可避免产生了无谓损失。</p>
<h3 id="进口限额的影响"><a class="markdownIt-Anchor" href="#进口限额的影响"></a> 进口限额的影响</h3>
<p>产生的影响相似，不同在于关税增加了政府的收入，进口限额增加了国内许可证持有者的收入</p>
<p>实际上用进口限额限制贸易的国家很少通过出卖进口许可证来达成。</p>
<h2 id="竞争市场"><a class="markdownIt-Anchor" href="#竞争市场"></a> 竞争市场</h2>
<p>企业在竞争市场中长期获利为 0, 但此处是经济利润为零，会计利润是正数。<br />
长期供应曲线向右上方倾斜</p>
<ol>
<li>用于生产的总资源是有限的</li>
<li>不同企业的成本不同</li>
</ol>
<ul>
<li>竞争企业是价格接受者，所以它的收益与产量成正比。物品的价格等于企业平均收益和边际收益。</li>
<li>为了利润最大化，企业选择使编辑收益等于边际成本的产量。由于竞争企业的边际收益等于市场价格，所以企业选择使价格等于边际成本的产量。因此企业的边际成本曲线是他的供给曲线。</li>
<li>在短期中，当企业不能收回其固定成本时，如果物品价格等于平均可变成本，企业将选择停止营业。在长期中，如果价格小于平均成本，当企业不能收回其固定收益和可变成本时，企业将选择退出。</li>
<li>在有自由进出的市场上，长期中利润为零。在长期均衡中，所有企业在有效规模时生产，价格等于最低平均总成本，而且企业数量的调整满足在这种价格时的需求量。</li>
<li>需求变动在不同时间范围之内有不同的影响。在短期中，需求增加引起价格上升，并使利润增加，而需求减少降低了价格，并引起亏损。但是如果企业可以自由进入和退出市场，那么在长期中企业数量调整使市场回到零利润均衡。</li>
</ul>
<h2 id="垄断"><a class="markdownIt-Anchor" href="#垄断"></a> 垄断</h2>
<p>竞争企业是价格接受者，而垄断企业是价格制定者。<br />
垄断引起的无谓损失类似税收，实际上我们可以把垄断着看成私人收税者。<br />
垄断产生的三个原因：</p>
<ul>
<li>一个企业拥有关键资源</li>
<li>政府给一个企业排他性地生产一种物品的权力</li>
<li>一个企业可以比许多企业以更少的成本供给整个市场</li>
</ul>
<p>政府对垄断的四种处理方式：</p>
<ul>
<li>用反托拉斯法使行业更具有竞争性</li>
<li>管制垄断者收取的价格</li>
<li>公有化</li>
<li>不作为</li>
</ul>
<p>价格歧视：</p>
<ul>
<li>完全价格歧视下，垄断产生的无谓损失完全消失，剩余都作为生产者的利润</li>
<li>价格歧视不完全时，与单一垄断价格相比，会增加或减少福利。</li>
</ul>
<h2 id="寡头"><a class="markdownIt-Anchor" href="#寡头"></a> 寡头</h2>
<p>寡头通过形成一个卡特尔并像垄断者一样行事来使自己的总利润最大化。但寡头如果独立地做出生产决策，结果是产量大于垄断的结果，价格低于垄断的结果。在寡头市场上企业的数量越多，产量和价格越接近竞争下存在的水平。</p>
<p>囚徒困境表明，利己使人即使在合作符合他们共同利益时也无法维持合作。囚徒困境的逻辑使用与很多情况，包括军备竞赛、做广告、共有资源问题和寡头。</p>
<p>决策者用反托拉斯来防止寡头从事减少竞争的行为。这些法律的适用性是有争议的，因为一些看来可以减少竞争的行为，实际上可能有合理的经营目的。</p>
<h2 id="垄断竞争"><a class="markdownIt-Anchor" href="#垄断竞争"></a> 垄断竞争</h2>
<p>垄断竞争市场有三个特点：许多企业、有差别的产品和自由进入。</p>
<p>垄断竞争市场的情况在相关的两个方面不同于完全竞争市场。</p>
<ol>
<li>每个企业都有过剩的生产力。即，它在平均总成本曲线向右下方倾斜的部分运行。</li>
<li>每个企业收取高于边际成本的价格。</li>
</ol>
<p>垄断竞争没有完全竞争所有特意的特点。存在由高于边际成本的价格加成引起的类似垄断的无谓损失。此外企业的数量可能过多或过少。实际上，决策者纠正这些无效率的能力是有限的。</p>
<p>垄断竞争中固有的产品差别引起使用广告和品牌。广告与品牌的批评者认为，企业这些方法利用了消费者的无理性，并减少了竞争。支持者认为，企业用这些方法向消费者提供信息，并使价格和质良的竞争更为激烈。</p>
<h2 id="生产要素市场"><a class="markdownIt-Anchor" href="#生产要素市场"></a> 生产要素市场</h2>
<p>生产要素的需求是派生需求，也就是说，企业的生产要素需求是它向另一个市场供给物品的决策派生出来的。对程序员的需求由软件派生。</p>
<h3 id="劳动"><a class="markdownIt-Anchor" href="#劳动"></a> 劳动</h3>
<p>对于一个竞争性的、利润最大化的企业，边际产量值曲线也是劳动需求曲线。</p>
<h3 id="土地和资本"><a class="markdownIt-Anchor" href="#土地和资本"></a> 土地和资本</h3>
<p>土地或资本的购买价格和租赁价格由略有不同的经济力量决定。</p>
<p>对劳动市场提出的要素需求里路可以用于土地和资本的租赁价格。</p>
<p>一块土地或资本的均衡购买价格取决于边际产量的现值和预期未来会有的边际产量值。</p>
<p>改变任何一种生产要素的供给事件会改变所有要素的收入。</p>
<p>新古典理论中，每种生产要素所得到的报酬量取决于那种要素的供给与需求。需求又决定了某种要素的边际生产率。在均衡时，每种生产要素赚到了它对生产于劳务的边际贡献的价值。</p>
<h2 id="收入与歧视"><a class="markdownIt-Anchor" href="#收入与歧视"></a> 收入与歧视</h2>
<h3 id="补偿性工资差别"><a class="markdownIt-Anchor" href="#补偿性工资差别"></a> 补偿性工资差别</h3>
<p>补偿性工资差别用来指不同工作的非货币特性引起的工资差别。</p>
<h3 id="人力资本"><a class="markdownIt-Anchor" href="#人力资本"></a> 人力资本</h3>
<p>人力资本是对人的投资的积累，最重要的人力资本类型是教育。</p>
<h3 id="能力-努力和机遇"><a class="markdownIt-Anchor" href="#能力-努力和机遇"></a> 能力、努力和机遇</h3>
<h3 id="教育的另一种观点信号"><a class="markdownIt-Anchor" href="#教育的另一种观点信号"></a> 教育的另一种观点：信号</h3>
<p>当人们得到大学学位时，他们并没有变得生产率更高，但是他们向有希望的雇主发送了他们高能力的信息——高能力的人比低能力的人更容易拿到大学学位。</p>
<p>信号理论和人力资本理论的不同之处在于：根据人力资本观点，提高所有工人的教育水平会提高所有工人的生产率，从而提高所有人的工资；根据信号理论，教育并没有提高生产率，提高所有工人的教育水平不影响工资。</p>
<h3 id="超级明星"><a class="markdownIt-Anchor" href="#超级明星"></a> 超级明星</h3>
<p>超级明星产生在有两个特点的市场上：</p>
<ul>
<li>市场上每位顾客都想享受最优生产者提供的物品；</li>
<li>使最优生产者以低成本向每位顾客提供物品成为可能的是生产这种物品所用的技术。</li>
</ul>
]]></content>
      <categories>
        <category>通识</category>
      </categories>
      <tags>
        <tag>经济学</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 操作备忘</title>
    <url>/2019/10/git_cheat_sheet/</url>
    <content><![CDATA[<h2 id="控制"><a class="markdownIt-Anchor" href="#控制"></a> 控制</h2>
<ul>
<li>git init G</li>
<li>git add/rm</li>
<li>git commit -m “informatiom”</li>
</ul>
<h3 id="查看修改"><a class="markdownIt-Anchor" href="#查看修改"></a> 查看修改</h3>
<ul>
<li>git status</li>
<li>git diff # failure after use git add</li>
<li>git log [–pretty=oneline//不输出作者时间等信息 ]
<ul>
<li>git log --graph --pretty=oneline --abbrev-commit</li>
</ul>
</li>
</ul>
<a id="more"></a>
<p>diff</p>
<ul>
<li>git diff      # 输出工作区和暂存区的 different</li>
<li>git diff --cached # 输出暂存区和本地最近的版本 (commit) 的 different</li>
<li>git diff HEAD     # 输出工作区、暂存区 和本地最近的版本 (commit)</li>
<li>git whatchanged --since=‘2 weeks ago’ # 查看两个星期内的修改</li>
</ul>
<h3 id="版本回退"><a class="markdownIt-Anchor" href="#版本回退"></a> 版本回退</h3>
<ul>
<li>git reset
<ul>
<li>git reset --hard HEAD^ # ^ 表示前一个版本，^^ 为两个，以此类推</li>
<li>git reset --hard HEAD~100 # 表示前 100 个版本</li>
<li>git reset --hard commit_id</li>
</ul>
</li>
<li>git revert HEAD # 撤销当前提交，不需要^</li>
<li>git reflog</li>
</ul>
<p>reset 直接忽略已经提交的 commit, 常用于本地；<br />
revert 保留原有的 commit, 创建一个新的节点使其与上一个节点内容相同，多用于已经 push 到远程的提交</p>
<h3 id="撤销修改"><a class="markdownIt-Anchor" href="#撤销修改"></a> 撤销修改</h3>
<p>工作区</p>
<ul>
<li>git checkout – file<br />
让这个文件回到最近一次 git commit 或 git add 时的状态</li>
</ul>
<p>缓存区</p>
<ul>
<li>git reset HEAD file<br />
若已经使用 git add 则先清缓存区，再清工作区</li>
</ul>
<h3 id="删除文件"><a class="markdownIt-Anchor" href="#删除文件"></a> 删除文件</h3>
<ul>
<li>git rm</li>
<li>git checkout – file<br />
用版本库里的版本替换工作区的版本</li>
</ul>
<h3 id="远程"><a class="markdownIt-Anchor" href="#远程"></a> 远程</h3>
<p>push</p>
<ul>
<li>git remote add origin <a href="mailto:git@github.com">git@github.com</a>:ViggoC/Test.git</li>
<li>git push -u origin master</li>
</ul>
<p>clone</p>
<ul>
<li>git clone <a href="mailto:git@github.com">git@github.com</a>:Viggo/Test.git</li>
</ul>
<p>fetch</p>
<ul>
<li>git fetch --all &amp;&amp; git reset --hard origin/master # 抛弃本地所有的修改，回到远程仓库的状态。</li>
</ul>
<p><code>git fetch</code> 将远程主机的最新内容拉到本地，用户在检查了以后决定是否合并到工作本机分支中。而<code>git pull</code> 则将远程主机的最新内容拉下来后直接合并，即：git pull = git fetch + git merge，这样可能会产生冲突，需要手动解决。</p>
<p>rebase</p>
<ul>
<li>git rebase # 把本地未 push 的分叉提交历史整理成直线，未 push 的修改都在最新远程状态之后</li>
</ul>
<h2 id="分支"><a class="markdownIt-Anchor" href="#分支"></a> 分支</h2>
<h3 id="合并"><a class="markdownIt-Anchor" href="#合并"></a> 合并</h3>
<ul>
<li>git checkout -b dev
<ul>
<li>git branch dev</li>
<li>git checkout dev</li>
</ul>
</li>
<li>git merge</li>
<li>git branch -d dev # 删除分支
<ul>
<li>git branch -D <name> # force delete</li>
</ul>
</li>
<li>git merge --no-ff -m “merge with no-ff” dev<br />
普通合并而非 fast forward，先创建一个新的 commit 后合并</li>
<li>git branch -vv    # 展示本地分支关联远程仓库的情况</li>
</ul>
<h3 id="bug-分支"><a class="markdownIt-Anchor" href="#bug-分支"></a> Bug 分支</h3>
<p>在 dev 中工作到一半，需要修改 bug101</p>
<ul>
<li>git stash</li>
<li>git check master</li>
<li>git check -b issue-101</li>
<li>debug 后提交</li>
<li>git checkout master</li>
<li>git merge --no-ff “merge bug fix 101” issue-101</li>
<li>git branch -d issue-101</li>
<li>git checkout dev</li>
<li>git stash pop
<ul>
<li>git stash list</li>
<li>git stash apply stash@{}</li>
</ul>
</li>
</ul>
<h3 id="多人协作"><a class="markdownIt-Anchor" href="#多人协作"></a> 多人协作</h3>
<ul>
<li>查看远程库信息，使用 git remote -v；</li>
<li>本地新建的分支如果不推送到远程，对其他人就是不可见的；</li>
<li>从本地推送分支，使用 git push origin branch-name，如果推送失败，先用 git pull 抓取远程的新提交；</li>
<li>在本地创建和远程分支对应的分支，使用 git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致；</li>
<li>建立本地分支和远程分支的关联，使用 git branch --set-upstream branch-name origin/branch-name；</li>
<li>从远程抓取分支，使用 git pull，如果有冲突，要先处理冲突。</li>
</ul>
<h2 id="标签"><a class="markdownIt-Anchor" href="#标签"></a> 标签</h2>
<ul>
<li>git tag [tag-name] [-m “message”] [commit-id]</li>
<li>git show <tag-name></li>
<li>git push origin <tagname>     # 可以推送一个本地标签；</li>
<li>git push origin --tags        # 可以推送全部未推送过的本地标签；</li>
<li>git tag -d <tagname>          # 可以删除一个本地标签；</li>
<li>git push origin :refs/tags/<tagname>  # 可以删除一个远程标签，推送“空”到远程</li>
</ul>
<h2 id="学习资源"><a class="markdownIt-Anchor" href="#学习资源"></a> 学习资源</h2>
<p><a href="http://rogerdudler.github.io/git-guide/index.zh.html" target="_blank" rel="noopener">git-简明指南</a></p>
<p><a href="https://learngitbranching.js.org/" target="_blank" rel="noopener">在线学习网站</a>：可实操的教程，通过动画展示版本关系</p>
<p><a href="https://github.com/521xueweihan/git-tips/blob/master/assets/git.png?raw=true" target="_blank" rel="noopener">git tips 思维导图</a></p>
<p><img src="https://i.loli.net/2020/03/15/DxK5mRwtjZO3nPH.png" alt="cheat sheet" /></p>
]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle 笔记汇总</title>
    <url>/2019/09/Oracle-note-summary/</url>
    <content><![CDATA[<h1 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h1>
<h2 id="oracle-in-docker"><a class="markdownIt-Anchor" href="#oracle-in-docker"></a> Oracle in Docker</h2>
<p><code>docke search oracle</code>，选择相应的 <a href="https://hub.docker.com/r/absolutapps/oracle-12c-ee" target="_blank" rel="noopener">image</a> 拉取</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker run -d --name oracle \</span><br><span class="line">  --privileged -v $(pwd)&#x2F;oradata:&#x2F;u01&#x2F;app&#x2F;oracle \</span><br><span class="line">  -p 8080:8080 -p 1521:1521 absolutapps&#x2F;oracle-12c-ee</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/padlik/oracle-12c" target="_blank" rel="noopener">镜像说明文档</a> 中 Additional options 的意思是自己基于它的基础包重修 build 的时候可以修改的参数。</p>
<p>PS：在给自用 Ubuntu 安装时非常顺利，在给测试平台的<code>Centos7</code>安装时诡异地出现了<code>docker-entrypoint.sh</code>中一条<code>chown</code>语句卡出运行不了，修改文件中相应的语句后成功安装。</p>
<a id="more"></a>
<h2 id="oracle-in-centos"><a class="markdownIt-Anchor" href="#oracle-in-centos"></a> Oracle in Centos</h2>
<p><a href="https://blog.csdn.net/zwl18210851801/article/details/80774980" target="_blank" rel="noopener">静默安装教程</a></p>
<p><a href="https://wiki.centos.org/zh/HowTos/Oracle12onCentos7" target="_blank" rel="noopener">图形化安装教程</a></p>
<h3 id="vi-etcsysctlconf"><a class="markdownIt-Anchor" href="#vi-etcsysctlconf"></a> vi /etc/sysctl.conf</h3>
<p>这里面有很多参数可以优化</p>
<p><strong>内核的 shmall 和 shmmax 参数</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHMMAX&#x3D; 配置了最大的内存 segment 的大小 ------&gt;这个设置的比 SGA_MAX_SIZE 大比较好。</span><br><span class="line"></span><br><span class="line">SHMMIN&#x3D; 最小的内存 segment 的大小 </span><br><span class="line"></span><br><span class="line">SHMMNI&#x3D; 整个系统的内存 segment 的总个数</span><br></pre></td></tr></table></figure>
<p>使配置生效<br />
<code>/sbin/sysctl -p</code></p>
<h3 id="swap-不存在"><a class="markdownIt-Anchor" href="#swap-不存在"></a> swap 不存在</h3>
<p>报错，提示swap空间不足</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Checking swap space: 0 MB available, 150 MB required. Failed &lt;&lt;&lt;&lt;</span><br></pre></td></tr></table></figure>
<p>创建 swap 文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dd <span class="keyword">if</span>=/dev/zero of=/swapfile bs=1024 count=512k</span><br><span class="line">mkswap /swapfile</span><br><span class="line">swapon /swapfile</span><br></pre></td></tr></table></figure>
<p><a href="https://www.cnblogs.com/a9999/p/6957280.html" target="_blank" rel="noopener">参考</a></p>
<h3 id="配置监听"><a class="markdownIt-Anchor" href="#配置监听"></a> 配置监听</h3>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">netca /silent /responsefile /home/database/response/netca.rsp <span class="comment"># 这句话一定要写绝对路径</span></span><br></pre></td></tr></table></figure>
<p>listener.ora 范例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># listener.ora Network Configuration File:&#x2F;u01&#x2F;app&#x2F;oracle&#x2F;product&#x2F;12&#x2F;db_1&#x2F;network&#x2F;admin&#x2F;listener.ora</span><br><span class="line"># Generated by Oracle configuration tools.</span><br><span class="line">SID_LIST_LISTENER &#x3D;</span><br><span class="line">  (SID_LIST &#x3D;</span><br><span class="line">    (SID_DESC &#x3D;</span><br><span class="line">      (SID_NAME &#x3D; orcl)</span><br><span class="line">      (ORACLE_HOME &#x3D; &#x2F;u01&#x2F;app&#x2F;oracle&#x2F;product&#x2F;12&#x2F;db_1)</span><br><span class="line">#      (PROGRAM &#x3D; extproc)</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">LISTENER &#x3D;</span><br><span class="line">  (DESCRIPTION_LIST &#x3D;</span><br><span class="line">    (DESCRIPTION &#x3D;</span><br><span class="line">      (ADDRESS &#x3D; (PROTOCOL &#x3D; TCP)(HOST &#x3D; 10.5.16.198)(PORT &#x3D; 1521))</span><br><span class="line">#      (ADDRESS &#x3D; (PROTOCOL &#x3D; IPC)(KEY &#x3D; EXTPROC1521))</span><br><span class="line">    )</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<p>参考：</p>
<p><a href="http://blog.51cto.com/xjsunjie/1614115" target="_blank" rel="noopener">listener/tnsname</a><br />
<a href="https://docs.oracle.com/cd/B28359_01/network.111/b28317/listener.htm#NETRF008" target="_blank" rel="noopener">listener parameter</a></p>
<p><strong>host 填 localhost 可能出现其他机子连不到的情况</strong></p>
<p>使用 <a href="http://blog.itpub.net/12679300/viewspace-1969620/" target="_blank" rel="noopener">静态监听</a> 方式时，<code>lsnrctl status</code>会看到实例的状态为<code>unknown</code>为正常现象。</p>
<ul>
<li>动态监听：oracle 服务器默认会去绑定<code>1521</code>端口。</li>
<li>静态监听：在监听器中指定数据库信息（路径），由监听器去搜索服务。</li>
</ul>
<h3 id="sqlplus-无法使用-backspace-和-history"><a class="markdownIt-Anchor" href="#sqlplus-无法使用-backspace-和-history"></a> sqlplus 无法使用 backspace 和 history</h3>
<p>Cenots 中使用 sqlplus 无法使用删除和方向键，安装 <a href="https://oracle-base.com/articles/linux/rlwrap" target="_blank" rel="noopener">rlwrap</a> 解决。</p>
<h3 id="系统防火墙配置"><a class="markdownIt-Anchor" href="#系统防火墙配置"></a> 系统防火墙配置</h3>
<p>登录 root 检查防火墙状态</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@centos7 ~]<span class="comment"># firewall-cmd --get-active-zones</span></span><br><span class="line">public</span><br><span class="line">  interfaces: eth0</span><br></pre></td></tr></table></figure>
<p>打开相关的端口</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@centos7 ~]<span class="comment"># firewall-cmd --zone=public --add-port=1521/tcp --add-port=5500/tcp --add-port=5520/tcp --add-port=3938/tcp --permanent</span></span><br><span class="line">success</span><br></pre></td></tr></table></figure>
<p>重新加载生效</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@centos7 ~]<span class="comment"># firewall-cmd --reload</span></span><br><span class="line">success</span><br></pre></td></tr></table></figure>
<p>查看端口规则</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@centos7 ~]<span class="comment"># firewall-cmd --list-ports</span></span><br><span class="line">1521/tcp 3938/tcp 5500/tcp 5520/tcp</span><br></pre></td></tr></table></figure>
<h3 id="开机自启动配置"><a class="markdownIt-Anchor" href="#开机自启动配置"></a> 开机自启动配置</h3>
<p><a href="https://www.cnblogs.com/meiling12/p/8443823.html" target="_blank" rel="noopener">https://www.cnblogs.com/meiling12/p/8443823.html</a></p>
<ol>
<li>查看ORACLE_HOME是否设置</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ echo $ORACLE_HOME</span><br><span class="line">&#x2F;u01&#x2F;app&#x2F;oracle&#x2F;product&#x2F;11.2.0&#x2F;dbhome_1</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>执行dbstart 数据库自带启动脚本</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[oracle@<span class="built_in">local</span> ~]$ <span class="built_in">cd</span> <span class="variable">$ORACLE_HOME</span></span><br><span class="line">[oracle@<span class="built_in">local</span> dbhome_1]$ <span class="built_in">cd</span> bin/</span><br><span class="line">[oracle@<span class="built_in">local</span> bin]$ dbstart</span><br><span class="line">ORACLE_HOME_LISTNER is not SET, unable to auto-start Oracle Net Listener Usage: /u01/app/oracle/product/11.2.0/db_1/bin/dbstart ORACLE_HOME</span><br><span class="line">错误提示：ORACLE_HOME_LISTNER 没有设置</span><br><span class="line"></span><br><span class="line">[oracle@<span class="built_in">local</span> bin]$ ll | grep dbs</span><br><span class="line">-rwxr-x---. 1 oracle oinstall 6088 1月 1 2000 dbshut</span><br><span class="line">-rwxr-x---. 1 oracle oinstall 13892 12月 11 16:01 dbstart</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑 dbstart，将ORACLE_HOME_LISTNER=$1修改成 ORACLE_HOME_LISTNER=$ORACLE_HOME 前提是$ORACLE_HOME环境设置正确</span></span><br><span class="line"></span><br><span class="line">[oracle@<span class="built_in">local</span> bin]$ vi dbstart </span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加</span></span><br><span class="line">ORACLE_HOME_LISTNER=/u01/app/oracle/product/11.2.0/dbhome_1</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>编辑 <code>/etc/oratab</code> 文件</li>
</ol>
<p>dbca建库时都会自动创建<code>/etc/oratab</code>文件</p>
<p>将 <code>orcl:/u01/app/oracle/product/11.2.0/dbhome_1:N</code><br />
修改成<code>orcl:/u01/app/oracle/product/11.2.0/dbhome_1:Y</code></p>
<ol start="4">
<li>编辑 <code>/etc/rc.d/rc.local</code> 启动文件，添加数据库启动脚本 dbstart</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@<span class="built_in">local</span> ~]<span class="comment"># vi /etc/rc.d/rc.local</span></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># THIS FILE IS ADDED FOR COMPATIBILITY PURPOSES</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># It is highly advisable to create own systemd services or udev rules</span></span><br><span class="line"><span class="comment"># to run scripts during boot instead of using this file.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># In contrast to previous versions due to parallel execution during boot</span></span><br><span class="line"><span class="comment"># this script will NOT be run after all other services.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Please note that you must run 'chmod +x /etc/rc.d/rc.local' to ensure</span></span><br><span class="line"><span class="comment"># that this script will be executed during boot.</span></span><br><span class="line"></span><br><span class="line">su oracle -lc <span class="string">"/u01/app/oracle/product/11.2.0/dbhome_1/bin/lsnrctl start"</span></span><br><span class="line">su oracle -lc /u01/app/oracle/product/11.2.0/dbhome_1/bin/dbstart</span><br></pre></td></tr></table></figure>
<h1 id="管理"><a class="markdownIt-Anchor" href="#管理"></a> 管理</h1>
<h2 id="用户管理"><a class="markdownIt-Anchor" href="#用户管理"></a> 用户管理</h2>
<p>创建的新用户是没有任何权限的，甚至连登陆的数据库的权限都没有，需要为其指定相应的权限。给一个用户赋权限使用命令<code>grant</code>，回收权限使用命令<code>revoke</code>。</p>
<p>权限分为系统权限和对象权限。</p>
<h3 id="系统权限"><a class="markdownIt-Anchor" href="#系统权限"></a> 系统权限</h3>
<p>用户对数据库的相关权限，connect、resource、dba 等系统权限，如建库、建表、建索引、建存储过程、登陆数据库、修改密码等。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">SQL&gt; conn xiaoming/oracle</span><br><span class="line">ERROR:</span><br><span class="line">ORA-01045: user XIAOMING lacks <span class="keyword">CREATE</span> <span class="keyword">SESSION</span> privilege; logon denied</span><br><span class="line">警告：您不再连接到 ORACLE。</span><br><span class="line">SQL&gt; show user</span><br><span class="line">USER 为 ""</span><br><span class="line">SQL&gt; conn system/oracle</span><br><span class="line">已连接。</span><br><span class="line">SQL&gt; grant connect to xiaoming;</span><br><span class="line">授权成功。</span><br><span class="line">SQL&gt; conn xiaoming/oracle</span><br><span class="line">已连接。</span><br></pre></td></tr></table></figure>
<p>注意：准确地说<code>grant connect to xiaoming;</code>中，connect 不是权限，而是角色</p>
<h3 id="对象权限"><a class="markdownIt-Anchor" href="#对象权限"></a> 对象权限</h3>
<p>用户对其他用户的数据对象操作的权限，insert、delete、update、select、all 等对象权限，数据对象有很多，比如表，索引，视图，触发器、存储过程、包等。</p>
<p>执行<code>SELECT * FROM Dba_Object_Size;</code>语句可得到 oracle 数据库对象。</p>
<p>希望 xiaoming 用户可以去查询 scott 的 emp 表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span> <span class="keyword">on</span> scott.emp <span class="keyword">to</span> xiaoming</span><br></pre></td></tr></table></figure>
<p>希望 xiaoming 用户可以去修改 scott 的 emp 表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">update</span> <span class="keyword">on</span> scott.emp <span class="keyword">to</span> xiaoming</span><br></pre></td></tr></table></figure>
<p>希望 xiaoming 用户可以去修改/删除，查询，添加 scott 的 emp 表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> <span class="keyword">on</span> scott.emp <span class="keyword">to</span> xiaoming</span><br></pre></td></tr></table></figure>
<p>scott 希望收回 xiaoming 对 emp 表的查询权限</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">revoke</span> <span class="keyword">select</span> <span class="keyword">on</span> scott.emp <span class="keyword">from</span> xiaoming</span><br></pre></td></tr></table></figure>
<h3 id="权限的传递"><a class="markdownIt-Anchor" href="#权限的传递"></a> 权限的传递</h3>
<p>希望 xiaoming 用户可以去查询 scott 的 emp 表，还希望 xiaoming 可以把这个权限传递给别人。</p>
<p>如果是对象权限，就加入 with grant option</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span> <span class="keyword">on</span> emp <span class="keyword">to</span> xiaoming <span class="keyword">with</span> <span class="keyword">grant</span> <span class="keyword">option</span></span><br></pre></td></tr></table></figure>
<p>如果 scott 把 xiaoming 对 emp 表的查询权限回收，那么 xiaohong 的权限被回收。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">SQL&gt; conn scott/oracle;</span><br><span class="line">已连接。</span><br><span class="line">SQL&gt; revoke select on emp from xiaoming;</span><br><span class="line">撤销成功。</span><br><span class="line">SQL&gt; conn xiaohong/oracle;</span><br><span class="line">已连接。</span><br><span class="line">SQL&gt; select * from scott.emp;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> scott.emp</span><br><span class="line">*</span><br><span class="line">第 <span class="number">1</span> 行出现错误：</span><br><span class="line">ORA<span class="number">-00942</span>: 表或视图不存在</span><br></pre></td></tr></table></figure>
<p>结果显示：小红受到诛连了。</p>
<ul>
<li>如果是系统权限，就加入 with admin option</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">connect</span> <span class="keyword">to</span> xiaoming <span class="keyword">with</span> <span class="keyword">admin</span> <span class="keyword">option</span></span><br></pre></td></tr></table></figure>
<p>收回这个用户的系统权限时，这个用户已经授予其他用户或角色的此系统权限不会因传播无效</p>
<h3 id="代理用户"><a class="markdownIt-Anchor" href="#代理用户"></a> 代理用户</h3>
<p>proxy users, allowing you to access a schema via a different username/password combination.</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">CONN / AS SYSDBA</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> test_user <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> test_user;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> scott <span class="keyword">GRANT</span> <span class="keyword">CONNECT</span> <span class="keyword">THROUGH</span> test_user;</span><br><span class="line"></span><br><span class="line">SQL&gt; CONN test_user[scott]/test_user</span><br><span class="line">SQL&gt; SHOW USER</span><br><span class="line">USER is "SCOTT"</span><br><span class="line">SQL&gt;</span><br></pre></td></tr></table></figure>
<h3 id="特定-schema-的权限"><a class="markdownIt-Anchor" href="#特定-schema-的权限"></a> 特定 schema 的权限</h3>
<p>想要将<code>user1</code>下所有表的查询权限付给<code>user2</code>用户，ORACLE 没有提供这个层级的语句。</p>
<p>方法 1：在 <code>all_tables</code> 中查出所有表后，拷贝输出结果执行</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="string">'Grant all on '</span>||table_name||<span class="string">'to user2 ;'</span> <span class="keyword">from</span> all_tables </span><br><span class="line"><span class="keyword">where</span> owner = <span class="keyword">upper</span>(user1);</span><br></pre></td></tr></table></figure>
<p>方法 2：存储过程</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">procedure</span> grant_selectAll_sql(v_from <span class="keyword">in</span> <span class="built_in">varchar2</span>, v_to <span class="keyword">in</span> <span class="built_in">varchar2</span>) <span class="keyword">is</span></span><br><span class="line">  v_sql <span class="built_in">varchar2</span>(<span class="number">1000</span>);</span><br><span class="line">  cursor v_cur is</span><br><span class="line">    <span class="keyword">select</span> t.* <span class="keyword">from</span> dba_tables t <span class="keyword">where</span> t.OWNER = v_from;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">for</span> v_row <span class="keyword">in</span> v_cur <span class="keyword">loop</span></span><br><span class="line">    v_sql := <span class="string">'grant select on '</span> || v_from || <span class="string">'.'</span> || v_row.table_name || <span class="string">' to '</span> || v_to;</span><br><span class="line">    <span class="keyword">execute</span> <span class="keyword">immediate</span> v_sql;</span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">loop</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">test</span>;</span><br></pre></td></tr></table></figure>
<h2 id="表空间管理"><a class="markdownIt-Anchor" href="#表空间管理"></a> 表空间管理</h2>
<h3 id="创建表空间"><a class="markdownIt-Anchor" href="#创建表空间"></a> 创建表空间</h3>
<p>oracle 默认最大数据文件为 32G, 想要创建超过这个大小可以使用。一个 表空间不能混用 <code>datafile</code>和 <code>bigfile</code>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">bigfile</span> <span class="keyword">tablespace</span> ...</span><br></pre></td></tr></table></figure>
<p>为用户赋予权限，否则会报 <code>ORA-01950</code>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> userName <span class="keyword">quota</span> [<span class="keyword">unlimited</span>/<span class="number">100</span>M] <span class="keyword">on</span> tablespaceName;</span><br></pre></td></tr></table></figure>
<h3 id="nas-数据存储"><a class="markdownIt-Anchor" href="#nas-数据存储"></a> NAS 数据存储</h3>
<p>oracle 对 NAS 的挂载方式有要求，<a href="http://biancheng.dnbcw.net/oracle/247147.html" target="_blank" rel="noopener">ORACLE 不支持 cifs</a></p>
<p>NFS 挂载命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mount -o rw,<span class="built_in">bg</span>,hard,nointr,rsize=32768,wsize=32768,vers=3,tcp,actimeo=0,timeo=600 192.168.1.2:/ETL /mnt/data</span><br></pre></td></tr></table></figure>
<h2 id="字符集"><a class="markdownIt-Anchor" href="#字符集"></a> 字符集</h2>
<h3 id="server-字符集"><a class="markdownIt-Anchor" href="#server-字符集"></a> server 字符集</h3>
<p>查询 server 字符集</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> V$NLS_PARAMETERS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> userenv(<span class="string">'language'</span>) <span class="keyword">FROm</span> dual;</span><br></pre></td></tr></table></figure>
<h3 id="client-端字符集"><a class="markdownIt-Anchor" href="#client-端字符集"></a> client 端字符集</h3>
<p>在 windows 平台下，就是注册表里面相应 OracleHome 的 NLS_LANG。还可以在 dos 窗口里面自己设置，这样就只影响这个窗口里面的环境变量，比如：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> nls_lang=AMERICAN_AMERICA.ZHS16GBK</span><br></pre></td></tr></table></figure>
<p>在 unix 平台下，就是环境变量 NLS_LANG。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$NLS_LANG</span></span><br><span class="line">AMERICAN_AMERICA.ZHS16GBK</span><br></pre></td></tr></table></figure>
<p>如果检查的结果发现 server 端与 client 端字符集不一致，请统一修改为同 server 端相同的字符集</p>
<h3 id="dump-文件字符集"><a class="markdownIt-Anchor" href="#dump-文件字符集"></a> dump 文件字符集</h3>
<p>用 oracle 的 exp 工具导出的 dmp 文件也包含了字符集信息，dmp 文件的第 2 和第 3 个字节记录了 dmp 文件的字符集。</p>
<p>如果 dmp 文件不大，比如只有几 M 或几十 M，可以用 UltraEdit 打开 (16 进制方式），看第 2 第 3 个字节的内容，如 0354，然后用以下 SQL 查出它对应的字符集：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">SQL&gt; select nls_charset_name(to_number(<span class="string">'0354'</span>,<span class="string">'xxxx'</span>)) from dual;</span><br><span class="line">ZHS16GBK</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/dbanote/article/details/9158367" target="_blank" rel="noopener">参考</a></p>
<h2 id="日期"><a class="markdownIt-Anchor" href="#日期"></a> 日期</h2>
<h3 id="oracle-的日期格式"><a class="markdownIt-Anchor" href="#oracle-的日期格式"></a> Oracle 的日期格式</h3>
<p>Oracle 数据缺省的时间格式数据的显示形式，与所使用的字符集有关。一般显示年月日，而不显示时分秒。</p>
<p>例如：</p>
<ul>
<li>
<p>使用 us7ascii 字符集（或者是其他的英语字符集）时，缺省的时间格式显示为：28-Jan-2003，</p>
</li>
<li>
<p>使用 zhs16gbk 字符集（或其他中文字符集）时时间格式缺省显示为：2003-1 月-28。</p>
</li>
</ul>
<p>向表中插入数据时，如果不使用转换函数，则时间字段的格式必须遵从会话环境的时间格式，否则不能插入。</p>
<p>查看当前会话的时间格式，可以使用以下的 SQL 语句：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">SQL&gt; select sysdate from dual;</span><br></pre></td></tr></table></figure>
<h3 id="修改日期格式的方法"><a class="markdownIt-Anchor" href="#修改日期格式的方法"></a> 修改日期格式的方法</h3>
<ol>
<li>在 sql*plus 中修改当前会话的日期格式</li>
</ol>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">SQL&gt; alter session set nls_date_format = 'yyyy-mm-dd hh24:mi:ss';</span><br></pre></td></tr></table></figure>
<p>将当前会话的时间格式修改为这种格式： 2003-01-28 15:23:38，这种修改方法，只对当前会话有效。</p>
<p>注意，是对<strong>当前会话</strong>，而不是当前的 sql*plus 窗口。即如果你这样修改之后，又使用 connect 命令以其他用户连接到数据库或者是连接到其他的数据库，则这个日期格式就失效了，又恢复到缺省的日期格式。</p>
<ol start="2">
<li>修改注册表（只对 windows 系统）</li>
</ol>
<p>在注册表<code>/hkey_local_machine/software/oracle/home0</code> 主键中增加一个字串 (8i 版本），字串名为 nls_date_format，字串的值为你希望定义的时间格式，如： yyyy-mm-dd hh24:mi:ss ，然后重新启动 sql*plus。</p>
<p>这种修改方法，对 sql*plus 窗口有效，即不论你打开多少个 sql*plus 窗口，缺省的都是这种时间格式。修改服务器端的注册表无效，只有修改客户端的注册表才有效。</p>
<ol start="3">
<li>修改环境变量（Linux）</li>
</ol>
<p>oracle 用户编辑 <code>.bash_profile</code> 下 加入以下内容，重新登录即可生效</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> NLS_DATE_FORMAT=<span class="string">'YYYY-MM-DD HH24:MI:SS'</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>用 sysdba 登录：然后更新 props$这个表里的字段即可</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update props$ set value &#x3D; &#39;YYYY-MM-DD HH24:MI:SS&#39; where parameter &#x3D; &#39;NLS_DATE_FORMAT&#39;;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>sql developer 修改</li>
</ol>
<p>工具-&gt;首选项-&gt;数据库-&gt;NLS-&gt;日期格式：DD-MON-RR 修改为：<code>YYYY-MM-DD HH24:MI:SS</code></p>
<h2 id="统计信息"><a class="markdownIt-Anchor" href="#统计信息"></a> 统计信息</h2>
<p>sql developer 中看到的统计信息并不是实时的，只有使用<code>analysis</code>命令之后才会更新，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ANALYZE TABLE tablename COMPUTE STATISTICS</span><br></pre></td></tr></table></figure>
<h2 id="数据库恢复与迁移"><a class="markdownIt-Anchor" href="#数据库恢复与迁移"></a> 数据库恢复与迁移</h2>
<p>X医院使用的数据库为 <code>10.2.0.5 in winsows</code>，想要在Centos下恢复。</p>
<h3 id="恢复步骤"><a class="markdownIt-Anchor" href="#恢复步骤"></a> 恢复步骤</h3>
<ol>
<li>
<p>安装数据库</p>
</li>
<li>
<p>修改环境变量 <code>ORACLE_SID</code></p>
</li>
<li>
<p>nomout 启动，恢复 pfile 文件，并修改 pfile 文件中的路径为本地路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rman target &#x2F;</span><br><span class="line"></span><br><span class="line">rman&gt;startup nomount</span><br><span class="line"></span><br><span class="line">rman&gt;restore spfile to pfile &#39;$ORACLE_HOME&#x2F;dbs&#x2F;init_$ORACLE_SID.ora&#39; from&#39;&#x2F;backup&#x2F;rman&#x2F;full_09l9esg4_1_1&#39;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>sql使用 pfile 重启数据库至 nomount 状态，恢复 controlfile，启动到 mount 状态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RMAN&gt; restore controlfile from &#39;...&#39;</span><br><span class="line">RMAN&gt; alter database mount;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>检查备份，设置 datafi 路径，restore datebase</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RMAN&gt; catalog start with &#39;&#x2F;home&#x2F;oracle&#x2F;rmanbackup&#39;;</span><br><span class="line"></span><br><span class="line">RMAN&gt; run&#123;</span><br><span class="line">2&gt; allocate channel c1 type disk;</span><br><span class="line">3&gt; set newname for datafile 1 to &#39;&#x2F;u01&#x2F;app&#x2F;oracle&#x2F;oradata&#x2F;csdb&#x2F;system01.dbf&#39;;</span><br><span class="line">4&gt; set newname for datafile 2 to &#39;&#x2F;u01&#x2F;app&#x2F;oracle&#x2F;oradata&#x2F;csdb&#x2F;sysaux01.dbf&#39;;</span><br><span class="line">5&gt; set newname for datafile 3 to &#39;&#x2F;u01&#x2F;app&#x2F;oracle&#x2F;oradata&#x2F;csdb&#x2F;undotbs1.dbf&#39;;</span><br><span class="line">6&gt; set newname for datafile 4 to &#39;&#x2F;u01&#x2F;app&#x2F;oracle&#x2F;oradata&#x2F;csdb&#x2F;users01.dbf&#39;;</span><br><span class="line">7&gt; set newname for datafile 5 to &#39;&#x2F;u01&#x2F;app&#x2F;oracle&#x2F;oradata&#x2F;csdb&#x2F;example01.dbf&#39;;</span><br><span class="line">8&gt; set newname for datafile 6 to &#39;&#x2F;u01&#x2F;app&#x2F;oracle&#x2F;oradata&#x2F;csdb&#x2F;undotbs2.dbf&#39;;</span><br><span class="line">9&gt; set newname for datafile 7 to &#39;&#x2F;u01&#x2F;app&#x2F;oracle&#x2F;oradata&#x2F;csdb&#x2F;testtbs01.dbf&#39;;</span><br><span class="line">10&gt; restore database;</span><br><span class="line">11&gt; switch datafile all;</span><br><span class="line">12&gt; release channel c1;</span><br><span class="line">13&gt; &#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>recover datafilebase</p>
</li>
</ol>
<h3 id="尝试历程"><a class="markdownIt-Anchor" href="#尝试历程"></a> 尝试历程</h3>
<p>备份恢复的时候尽量选择相同的数据库版本，即使相同大版本不同小版本（补丁）也有可能出现各种奇怪的错误无法恢复数据。</p>
<ul>
<li>12c 失败</li>
<li>10.2.0.1 catalog start with 失败</li>
<li>10.2.0.3 restore database 失败</li>
<li>10.2.0.5 restore database 成功，recover database 失败</li>
</ul>
<h3 id="跨平台问题"><a class="markdownIt-Anchor" href="#跨平台问题"></a> 跨平台问题</h3>
<blockquote>
<p>The Cross-platform redo application is only supported for physical standby but not for general media recovery which is involved while duplicating database using RMAN.</p>
</blockquote>
<p>Windows 与 Linux 平台的 Oracle 日志系统不同，无法平台进行恢复，因此想要跨平台恢复存在如下方式：</p>
<ol>
<li>
<p>冷备份：即停机备份</p>
</li>
<li>
<p>热备份时备份 <code>standby controlfile</code> <a href="https://oraclefreak.wordpress.com/rman-backuprestore-from-windows-to-linux/" target="_blank" rel="noopener">（参考）</a></p>
<p>Let’s modify the RMAN script in windows to backup standby controlfile instead of a normal controlfile.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">run</span><br><span class="line">&#123;</span><br><span class="line">allocate channel c1 device type disk;</span><br><span class="line">allocate channel c2 device type disk;</span><br><span class="line">backup as compressed backupset database filesperset 1 format &#39;c:\backup\datafile_%U&#39;;</span><br><span class="line">sql &quot;alter database create standby controlfile as &#39;&#39;c:\backup\control_stby.bak&#39;&#39;&quot;;</span><br><span class="line">release channel c1;</span><br><span class="line">release channel c2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Make a few switch log in windows.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SQL&gt; alter system switch logfile;</span><br><span class="line"></span><br><span class="line">System altered.</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>修改配置跳过一致性检查（本次恢复最终使用此方法）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter system set “_allow_resetlogs_corruption”&#x3D;true scope&#x3D;spfile;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>BBED 可以直接修改文件头，骗过一致性检查 <a href="https://dba.stackexchange.com/questions/163074/duplicate-oracle-database-from-windows-to-linux" target="_blank" rel="noopener">（参考）</a></p>
</li>
</ol>
<h1 id="sql"><a class="markdownIt-Anchor" href="#sql"></a> SQL</h1>
<h2 id="in-vs-exists"><a class="markdownIt-Anchor" href="#in-vs-exists"></a> in vs exists</h2>
<p>in 和 exists 主要是造成了驱动顺序的改变（这是性能变化的关键），如果是 exists，那么以外层表为驱动表，先被访问，如果是 IN，那么先执行子查询，所以我们会以驱动表的快速返回为目标。因此 in 适用于内表小，exists 适用于外表小。</p>
<h2 id="not-in-vs-not-exists"><a class="markdownIt-Anchor" href="#not-in-vs-not-exists"></a> not in vs not exists</h2>
<p>对于 <code>not in</code>如果子查询中返回的任意一条记录含有空值，则查询将不返回任何记录。</p>
<p><a href="https://blog.csdn.net/baidu_37107022/article/details/77278381" target="_blank" rel="noopener">性能对比</a></p>
<h2 id="联表更新"><a class="markdownIt-Anchor" href="#联表更新"></a> 联表更新</h2>
<p>写法 1</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> test1 t1</span><br><span class="line">    <span class="keyword">set</span> t1.object_name = (<span class="keyword">select</span> t2.object_name</span><br><span class="line">        <span class="keyword">from</span> test2 t2</span><br><span class="line">    <span class="keyword">where</span> t1.object_id = t2.object_id)</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">exists</span> (<span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> test2 t3 </span><br><span class="line">    <span class="keyword">where</span> t3.object_id = t1.object_id);</span><br></pre></td></tr></table></figure>
<p>写法 2 (inline view 更新法）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> (<span class="keyword">select</span> t1.object_name, t2.object_name new_object_name</span><br><span class="line">    <span class="keyword">from</span> test1 t1, test2 t2</span><br><span class="line">    <span class="keyword">where</span> t1.object_id = t2.object_id)</span><br><span class="line"><span class="keyword">set</span> object_name = new_object_name;</span><br></pre></td></tr></table></figure>
<p>写法 3 (merge 法）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">merge</span> <span class="keyword">into</span> test1 t1</span><br><span class="line"><span class="keyword">using</span> test2 t2</span><br><span class="line"><span class="keyword">on</span> (t1.object_id = t2.object_id)</span><br><span class="line"><span class="keyword">when</span> <span class="keyword">matched</span> <span class="keyword">then</span></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">set</span> t1.object_name = t2.object_name;</span><br></pre></td></tr></table></figure>
<p><strong>这种写法不能对<code>on</code>条件中用到的字段进行更新</strong>。</p>
<p>写法 2-3 更优，方法 1 会进行两次子查询</p>
<p>写法 4 （快速游标法）: 没用过</p>
<table>
<thead>
<tr>
<th>方案</th>
<th>建议</th>
</tr>
</thead>
<tbody>
<tr>
<td>标准 update 语法</td>
<td>单表更新或较简单的语句采用使用此方案更优。</td>
</tr>
<tr>
<td>inline view 更新法</td>
<td>两表关联且被更新表通过关联表主键关联的，采用此方案更优。</td>
</tr>
<tr>
<td>merge 更新法</td>
<td>两表关联且被更新表不是通过关联表主键关联的，采用此方案更优。</td>
</tr>
<tr>
<td>快速游标更新法</td>
<td>多表关联且逻辑复杂的，采用此方案更优。</td>
</tr>
</tbody>
</table>
<h2 id="联表删除"><a class="markdownIt-Anchor" href="#联表删除"></a> 联表删除</h2>
<p>创建表 A</p>
<table>
<thead>
<tr>
<th>key</th>
<th>value</th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td>1</td>
</tr>
<tr>
<td>b</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>创建表 B</p>
<table>
<thead>
<tr>
<th>key</th>
<th>value</th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td>1</td>
</tr>
<tr>
<td>c</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>从表 A 中删除，与 B 中 key，value 都相等的数据。</p>
<p>方法 1: 无条件</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> A</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">exists</span>(</span><br><span class="line">    <span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> B <span class="keyword">where</span> A.key = B.key </span><br><span class="line">        <span class="keyword">and</span> A.value = B.value</span><br><span class="line">)</span><br><span class="line"><span class="comment">-- 或</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> A</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">rowid</span> <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">select</span> a.rowid <span class="keyword">from</span> B <span class="keyword">where</span> A.key = B.key </span><br><span class="line">        <span class="keyword">and</span> A.value = B.value);</span><br></pre></td></tr></table></figure>
<p>方法 2：要求其中一个表要有主键</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> </span><br><span class="line">(<span class="keyword">select</span> * <span class="keyword">from</span> B,A </span><br><span class="line"><span class="keyword">where</span> A.key = B.key</span><br><span class="line">    <span class="keyword">and</span> A.value = B.value);</span><br></pre></td></tr></table></figure>
<p>经测试，删除结果为：当两个表都有主键时删除位置靠前的表的数据，当其中一个表没有主键时删除没有主键的表的数据。</p>
<h1 id="优化"><a class="markdownIt-Anchor" href="#优化"></a> 优化</h1>
<h2 id="oracle-数据库性能优化与运维最佳实践"><a class="markdownIt-Anchor" href="#oracle-数据库性能优化与运维最佳实践"></a> Oracle 数据库性能优化与运维最佳实践</h2>
<h3 id="指导思想"><a class="markdownIt-Anchor" href="#指导思想"></a> 指导思想</h3>
<p>自上而下优化以下内容：</p>
<ol>
<li>优化应用程序代码之前先优化设计</li>
<li>优化实例之前先优化代码<br />
对可以带来最大潜在好处的方面进行优化并确定：</li>
<li>最长的等待</li>
<li>最慢的 SQL<br />
达到目标时停止优化</li>
</ol>
<h3 id="优化过程"><a class="markdownIt-Anchor" href="#优化过程"></a> 优化过程</h3>
<ol>
<li>定义问题并陈述目标</li>
<li>收集当前性能统计信息</li>
<li>考虑一些常见的性能错误</li>
<li>制定适用解决方案</li>
<li>事实并度量更改</li>
<li>是否达到目标？完成：转到步骤 3</li>
</ol>
<h3 id="实践方法"><a class="markdownIt-Anchor" href="#实践方法"></a> 实践方法</h3>
<ul>
<li>监视和诊断——<a href="https://sq.163yun.com/blog/article/177908307918032896" target="_blank" rel="noopener">使用 AWR 报告分析 Oracle 数据库性能</a></li>
<li>SQL 优化</li>
<li>实例优化</li>
</ul>
<h2 id="select-tuning"><a class="markdownIt-Anchor" href="#select-tuning"></a> Select Tuning</h2>
<p><em>事实上简单查询时 CBO (Cost-Based Optimization) 已经能够完成优化工作，但在写复杂的嵌套查询是仍需要注意。</em></p>
<h3 id="from-查询顺序-小表在后"><a class="markdownIt-Anchor" href="#from-查询顺序-小表在后"></a> from 查询顺序 小表在后</h3>
<p>ORACLE 的解析器按照<strong>从右到左</strong>的顺序处理 FROM 子句中的表名，因此 FROM 子句中写在最后的表（驱动表 driving table) 将被最先处理。在 FROM 子句中包含多个表的情况下，你必须选择记录条数最少的表作为基础表。当 ORACLE 处理多个表时，会运用排序及合并的方式连接它们。首先，扫描第一个表 (FROM 子句中最后的那个表）并对记录进行排序，然后扫描第二个表 (FROM 子句中最后第二个表）, 最后将所有从第二个表中检索出的记录与第一个表中合适记录进行合并。</p>
<p>如：TAB1 有两千万条，TAB2 中有 1 条</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> TAB1, TAB2; <span class="comment">--20s</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> TAB2, TAB1; <span class="comment">--40s</span></span><br></pre></td></tr></table></figure>
<p>如果有 3 个以上的表连接查询，那就需要选择交叉表 (intersection table) 作为基础表，交叉表是指那个被其他表所引用的表。</p>
<p>例如：EMP 表描述了 LOCATION 表和 CATEGORY 表的交集。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> LOCATION L ,</span><br><span class="line">       <span class="keyword">CATEGORY</span> C,</span><br><span class="line">       EMP E</span><br><span class="line"><span class="keyword">WHERE</span> E.EMP_NO <span class="keyword">BETWEEN</span> <span class="number">1000</span> <span class="keyword">AND</span> <span class="number">2000</span></span><br><span class="line"><span class="keyword">AND</span> E.CAT_NO = C.CAT_NO</span><br><span class="line"><span class="keyword">AND</span> E.LOCN = L.LOCN</span><br><span class="line"><span class="comment">-- 将比下列 SQL 更有效率</span></span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> EMP E ,</span><br><span class="line">LOCATION L ,</span><br><span class="line">       <span class="keyword">CATEGORY</span> C</span><br><span class="line"><span class="keyword">WHERE</span>   E.CAT_NO = C.CAT_NO</span><br><span class="line"><span class="keyword">AND</span> E.LOCN = L.LOCN</span><br><span class="line"><span class="keyword">AND</span> E.EMP_NO <span class="keyword">BETWEEN</span> <span class="number">1000</span> <span class="keyword">AND</span> <span class="number">2000</span></span><br></pre></td></tr></table></figure>
<h3 id="where-查询顺序"><a class="markdownIt-Anchor" href="#where-查询顺序"></a> where 查询顺序</h3>
<p>ORACLE 采用<strong>自下而上</strong>的顺序解析 WHERE 子句，根据这个原理，</p>
<ul>
<li>表之间的连接必须写在其他 WHERE 条件之前，</li>
<li>可以过滤掉最大数量记录的条件必须写在 WHERE 子句的末尾。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- （低效，执行时间 156.3 秒）</span></span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> EMP E</span><br><span class="line"><span class="keyword">WHERE</span>   SAL &gt;<span class="number">50000</span></span><br><span class="line"><span class="keyword">AND</span>     JOB = ‘MANAGER’</span><br><span class="line"><span class="keyword">AND</span>     <span class="number">25</span> &lt; (<span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> EMP</span><br><span class="line"><span class="keyword">WHERE</span> MGR=E.EMPNO);</span><br><span class="line"><span class="comment">-- （高效，执行时间 10.6 秒）</span></span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> EMP E</span><br><span class="line"><span class="keyword">WHERE</span> <span class="number">25</span> &lt; (<span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> EMP</span><br><span class="line">              <span class="keyword">WHERE</span> MGR=E.EMPNO)</span><br><span class="line"><span class="keyword">AND</span>     SAL &gt;<span class="number">50000</span></span><br><span class="line"><span class="keyword">AND</span>     JOB = ‘MANAGER’;</span><br></pre></td></tr></table></figure>
<h3 id="避免使用"><a class="markdownIt-Anchor" href="#避免使用"></a> 避免使用 <code>*</code></h3>
<p>ORACLE 在解析的过程中，会将’*’ 依次转换成所有的列名，这个工作是通过查询数据字典完成的，这意味着将耗费更多的时间。</p>
<p><em>在 OLAP 场景下作用不大</em> ，语句运行的时间远大于解析时间 。</p>
<h3 id="减少访问次数"><a class="markdownIt-Anchor" href="#减少访问次数"></a> 减少访问次数</h3>
<p><em>未实践</em></p>
<p>当执行每条 SQL 语句时，ORACLE 在内部执行了许多工作：解析 SQL 语句，估算索引的利用率，绑定变量 , 读数据块等等。由此可见，减少访问数据库的次数 , 就能实际上减少 ORACLE 的工作量。</p>
<p>在 SQL*Plus , SQL*Forms 和 Pro*C 中重新设置 ARRAYSIZE 参数，可以增加每次数据库访问的检索数据量 , 建议值为 200.</p>
<h3 id="使用-decode-函数来减少处理时间"><a class="markdownIt-Anchor" href="#使用-decode-函数来减少处理时间"></a> 使用 DECODE 函数来减少处理时间</h3>
<p>使用 DECODE 函数可以避免重复扫描相同记录或重复连接相同的表。</p>
<h2 id="insert-tuning"><a class="markdownIt-Anchor" href="#insert-tuning"></a> Insert Tuning</h2>
<ul>
<li>停用/删除索引和约束，载入数据后重建</li>
</ul>
<blockquote>
<p>a - Disable/drop indexes and constraints - It’s far faster to rebuild indexes after the data load, all at-once. Also indexes will rebuild cleaner, and with less I/O if they reside in a tablespace with a large block size.</p>
</blockquote>
<ul>
<li>管理并行插入时的段头争用</li>
</ul>
<blockquote>
<p>b - Manage segment header contention for parallel inserts - Make sure to define <a href="https://www.eygle.com/archives/2011/11/freelistsfreeli.html" target="_blank" rel="noopener">multiple freelist (or freelist groups)</a> to remove contention for the table header. Multiple freelists add additional segment header blocks, removing the bottleneck.  You can also use Automatic Segment Space Management (bitmap freelists) to support parallel DML, but ASSM has some limitations.</p>
</blockquote>
<ul>
<li>使用 hint 并行加载</li>
</ul>
<blockquote>
<p>c - Parallelize the load - You can invoke parallel DML (i.e. using the PARALLEL and APPEND hint) to have multiple inserts into the same table. For this INSERT optimization, make sure to define multiple freelists and use the SQL “APPEND” option.  Mark Bobak notes that if you submit parallel jobs to insert against the table at the same time, using the APPEND hint may cause serialization, removing the benefit of parallel jobstreams.</p>
</blockquote>
<ul>
<li>使用 <code>append</code> 使表顺序写入硬盘</li>
</ul>
<blockquote>
<p>d - APPEND into tables - By using the APPEND hint, you ensure that Oracle always grabs “fresh” data blocks by raising the high-water-mark for the table. If you are doing parallel insert DML, the Append mode is the default and you don’t need to specify an APPEND hint.  Mark Bobak notes “Also, if you’re going w/ APPEND, consider putting the table into <strong>NOLOGGING</strong> mode, which will allow Oracle to avoid almost all redo logging.”</p>
<p><code>insert /*+ append */ into customer values ('hello',';there');</code></p>
</blockquote>
<ul>
<li>使用更大的 blocksize</li>
</ul>
<blockquote>
<p>e - Use a large blocksize - By defining large (i.e. 32k) blocksizes for the target table, you reduce I/O because more rows fit onto a block before a “block full” condition (as set by PCTFREE) unlinks the block from the freelist.</p>
<p>See benchmark test of blocksize and inserts <a href="http://www.dba-oracle.com/t_insert_tuning.htm#blocksize_insert" target="_blank" rel="noopener">here</a></p>
<p>See general benefits of multiple blocksizes <a href="http://www.dba-oracle.com/t_multiple_blocksizes_summary.htm" target="_blank" rel="noopener">here</a></p>
</blockquote>
<ul>
<li>使用 NOLOGGING 参数</li>
</ul>
<blockquote>
<p>f - Use NOLOGGING</p>
</blockquote>
<ul>
<li>使用告诉的硬盘</li>
</ul>
<blockquote>
<p>g- RAM disk - You can use high-speed solid-state disk (RAM-SAN) to make Oracle inserts run up to 300x faster than platter disk.</p>
</blockquote>
<p><a href="https://www.akadia.com/services/ora_insert_append.html" target="_blank" rel="noopener">操作顺序</a></p>
<ul>
<li>Mark indexes unuasble</li>
<li>Disable primary key</li>
<li>Alter table nologging</li>
<li>Do an insert /*+ append */ into table (select …)</li>
<li>Enable primary key</li>
<li>Rebuild indexes nologging</li>
</ul>
<p><a href="http://www.dba-oracle.com/t_insert_tuning.htm" target="_blank" rel="noopener">参考</a></p>
<h2 id="update-tuning"><a class="markdownIt-Anchor" href="#update-tuning"></a> Update Tuning</h2>
<h3 id="子查询-update-过慢问题"><a class="markdownIt-Anchor" href="#子查询-update-过慢问题"></a> 子查询 update 过慢问题</h3>
<p>一下两条语句功能完全相同，但在执行效率有巨大差异</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> scott.mytables a</span><br><span class="line"><span class="keyword">SET</span></span><br><span class="line">    a.tablespace_name = (</span><br><span class="line">        <span class="keyword">SELECT</span></span><br><span class="line">            b.tablespace_name</span><br><span class="line">        <span class="keyword">FROM</span></span><br><span class="line">            scott.all_tables b</span><br><span class="line">        <span class="keyword">WHERE</span></span><br><span class="line">            a.owner = b.owner</span><br><span class="line">            <span class="keyword">AND</span> a.table_name = b.table_name</span><br><span class="line">    );<span class="comment">--3.93s</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">MERGE</span> <span class="keyword">INTO</span> scott.mytables a </span><br><span class="line"><span class="keyword">USING</span> scott.all_tables b </span><br><span class="line"><span class="keyword">ON</span> ( a.owner = b.owner <span class="keyword">AND</span> a.table_name = b.table_name )</span><br><span class="line"><span class="keyword">WHEN</span> <span class="keyword">MATCHED</span> <span class="keyword">THEN</span> </span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">SET</span> a.tablespace_name = b.tablespace_name;</span><br></pre></td></tr></table></figure>
<p>适用 autotrace 跟踪实际运行 cost（用 10g 貌似跑不了，执行计划的估计有误），结果如下<br />
<img src="https://i.loli.net/2019/08/06/YNuPfTeKjmhnORW.png" alt="" /></p>
<p><img src="https://i.loli.net/2019/08/06/B1jDuoKHCePpAgd.png" alt="" /></p>
<p>使用子查询时以外表为条件，循环对内表进行查询（Nested Loop Join），join 的 cost 很高</p>
<p>使用 merg 语句时，使用了 hash join 进行了优化，join 几乎没有什么成本（这一点 oracle 优化得不错，mysql 都还没实现 hash join）</p>
<p><a href="https://logicalread.com/oracle-explain-plans-driving-tables-and-table-joins-h01/#.XUkjvN9fgUE" target="_blank" rel="noopener">Nested Loop Join/Merge Join/Hash Join</a></p>
<h2 id="数据库参数调优"><a class="markdownIt-Anchor" href="#数据库参数调优"></a> 数据库参数调优</h2>
<p><a href="https://blog.csdn.net/orcldb/article/details/8078190" target="_blank" rel="noopener">sga/pga 分配</a></p>
<h2 id="use-subqueries-to-count-distinct-50x-faster"><a class="markdownIt-Anchor" href="#use-subqueries-to-count-distinct-50x-faster"></a> Use Subqueries to Count Distinct 50X Faster</h2>
<p><a href="https://www.periscopedata.com/blog/use-subqueries-to-count-distinct-50x-faster" target="_blank" rel="noopener">https://www.periscopedata.com/blog/use-subqueries-to-count-distinct-50x-faster</a></p>
<h2 id="io-优化"><a class="markdownIt-Anchor" href="#io-优化"></a> IO 优化</h2>
<p>通过将数据分布存储至多个硬盘，可以通过并行 IO 提升效率。在建立 datafile 时就要合理分配</p>
<p><a href="http://www.dba-oracle.com/art_disk_io.htm" target="_blank" rel="noopener">Turning the Tables on Disk I/O </a></p>
<p><a href="https://asktom.oracle.com/pls/apex/f?p=100:11:0::::P11_QUESTION_ID:7116328455352" target="_blank" rel="noopener">spread a table into multiple disk</a></p>
<h1 id="错误处理"><a class="markdownIt-Anchor" href="#错误处理"></a> 错误处理</h1>
<h2 id="ora-00257"><a class="markdownIt-Anchor" href="#ora-00257"></a> ORA-00257</h2>
<p>ORA-00257: archiver error. Connect internal only, until freed.</p>
<p>ORACLE 默认的日志归档路径为闪回恢复区（$ORACLE_BASE/fast_recovery_area）。对于这个路径，Oracle 有一个限制，就是默认只有 4G 的空间，而且不只是归档日志的默认路径，也是备份文件和闪回日志的默认地址，这样的话归档日志锁使用的空间就达不到 4G，在没有设置好这个路径大小的情况下，很多系统都遇到过归档日志满而无法归档导致数据库夯住的问题。</p>
<h3 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h3>
<ol>
<li>查看归档日志路径</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SQL&gt;  archive log list;</span><br><span class="line">数据库日志模式            存档模式</span><br><span class="line">自动存档             启用</span><br><span class="line">存档终点            USE_DB_RECOVERY_FILE_DEST</span><br><span class="line">最早的联机日志序列     6827</span><br><span class="line">下一个存档日志序列   6827</span><br><span class="line">当前日志序列           6829</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>查看 DB_RECOVERY_FILE_DEST 路径</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SQL&gt; show parameter db_recovery;</span><br><span class="line"></span><br><span class="line">NAME                                 TYPE        VALUE</span><br><span class="line">------------------------------------ ----------- ------------------------------</span><br><span class="line">db_recovery_file_dest                string      E:\oracle\product\10.2.0&#x2F;flash</span><br><span class="line">                                                 _recovery_area</span><br><span class="line">db_recovery_file_dest_size           big integer 2G</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>查看闪回恢复区的使用情况</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SQL&gt; select * from v$flash_recovery_area_usage;</span><br><span class="line"></span><br><span class="line">FILE_TYPE    PERCENT_SPACE_USED PERCENT_SPACE_RECLAIMABLE NUMBER_OF_FILES</span><br><span class="line">------------ ------------------ ------------------------- ---------------</span><br><span class="line">CONTROLFILE                   0                         0               0</span><br><span class="line">ONLINELOG                     0                         0               0</span><br><span class="line">ARCHIVELOG                98.38                         0              43</span><br><span class="line">BACKUPPIECE                 .69                       .35               2</span><br><span class="line">IMAGECOPY                     0                         0               0</span><br><span class="line">FLASHBACKLOG                  0                         0               0</span><br></pre></td></tr></table></figure>
<p>确定了确实是因为闪回恢复区的空间不足造成的问题</p>
<h3 id="解决方法"><a class="markdownIt-Anchor" href="#解决方法"></a> 解决方法</h3>
<ol>
<li>手动扩容</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter system set db_recovery_file_dest_size&#x3D;10G;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>修改日志路径</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--修改 log_archive_dest_1 值来重新制定路径</span><br><span class="line">SQL&gt; alter system set log_archive_dest_1&#x3D;&#39;location&#x3D;&#x2F;u01&#x2F;oracle&#x2F;archive&#39;;</span><br><span class="line"> </span><br><span class="line">System altered.</span><br></pre></td></tr></table></figure>
<p>重启</p>
<h2 id="ora-22858-数据类型的变更无效"><a class="markdownIt-Anchor" href="#ora-22858-数据类型的变更无效"></a> ORA-22858: 数据类型的变更无效</h2>
<p>原因：Oracle 不允许将字段类型修改为：object、REF、nested table、varchar、clob、blob</p>
<p>解决方法：1. 修改该字段的名称。2. 新建一个正确的字段。3. 将数据同步的到新字段。4. 删除错误字段。</p>
]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 下虚拟机体验</title>
    <url>/2019/07/virtual-machine-in-linux/</url>
    <content><![CDATA[<h1 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h1>
<p>虚拟机磁盘文件格式</p>
<ul>
<li>VDI：virtual box 自有文件格式</li>
<li>VMDK：VMWare 格式，受到众多软件支持，具有将存储的文件分割为少于 2 GB 文件的附加功能</li>
<li>VHD：微软家的格式</li>
</ul>
<a id="more"></a>
<h2 id="qemu"><a class="markdownIt-Anchor" href="#qemu"></a> QEMU</h2>
<p>完全以软件的形式模拟出一台完整的电脑所需的所有硬件，甚至是模拟出不同架构的硬件，在这些虚拟的硬件之上，可以安装完整的操作系统。</p>
<p><img src="https://i.loli.net/2020/04/10/8UGD2wNoegtpZO5.png" alt="" /></p>
<h2 id="kvm"><a class="markdownIt-Anchor" href="#kvm"></a> KVM</h2>
<p>完全以软件模拟硬件的形式虽然功能强大，但是性能难以满足用户的需要。模拟出的硬件的性能和物理硬件的性能相比，必然会大打折扣。为了提高虚拟机软件的性能，最常用的办法就是在主操作系统中通过内核模块开一个洞，通过这个洞将虚拟机中的操作直接映射到物理硬件上，从而提高虚拟机中运行的操作系统的性能。KVM 就是这种加速模式的典型代表。</p>
<p><img src="https://i.loli.net/2020/04/10/W7u12trUlTyjHFx.png" alt="" /></p>
<p>KVM 已经被加入内核中，qemu-kvm 是为了借助 QEMU 运行虚拟机对 qemu-system-x86_64 命令进行的简单包装</p>
<h3 id="virt-manager"><a class="markdownIt-Anchor" href="#virt-manager"></a> virt-manager</h3>
<p>QEMU 和 KVM 自身不带图形界面的虚拟机管理器，virt-manager 提供图形化的管理界面。</p>
<h2 id="virtualbox"><a class="markdownIt-Anchor" href="#virtualbox"></a> VirtualBox</h2>
<p>简单易用，跨平台。</p>
<h2 id="xen"><a class="markdownIt-Anchor" href="#xen"></a> Xen</h2>
<p><img src="https://i.loli.net/2020/04/10/sETLJ6cfgbrAhjH.png" alt="" /></p>
<p>Xen 虚拟机架构中没有 Host System，在硬件层之上是薄薄的一层 Xen Hypervisor，在这之上就是各个虚拟机了，没有 Host System，只有 Domain 0 具有一定特权，而 Guest System 都是 Domain U，不管是 Domain 0 还是 Domain U，都是虚拟机，都是被虚拟机软件管理的对象。</p>
<p>安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo aptitude search xen</span><br><span class="line">sudo aptitude install xen-hypervisor-4.4-amd64</span><br></pre></td></tr></table></figure>
<p>启动时可以选择让该系统运行于 Xen Hypervisor 上。</p>
<p><img src="https://i.loli.net/2020/04/10/OvX1HGlnfLD2krZ.png" alt="" /></p>
<p>通过 Xen 虚拟机启动 Ubuntu 系统时，Grub 先启动的是 /boot/xen-4.4-amd64.gz，然后才把 Linux 内核以及 initrd 文件作为模块载入内存。</p>
<p>参考：</p>
<ol>
<li><a href="https://www.cnblogs.com/youxia/p/LinuxDesktop007.html" target="_blank" rel="noopener">Linux 中的 Qemu、KVM、VirtualBox、Xen 虚拟机体验</a></li>
</ol>
<h1 id="使用经验"><a class="markdownIt-Anchor" href="#使用经验"></a> 使用经验</h1>
<h2 id="host-使用-guest-中的-vpn"><a class="markdownIt-Anchor" href="#host-使用-guest-中的-vpn"></a> Host 使用 Guest 中的 VPN</h2>
<p>有些防火墙（比如华为）只提供 Windows 或 OSX 的 VPN 客户端，Linux 想要建立连接很不方便。这时候只能曲线救国，在 Windows 虚拟机中启动 VPN 客户端，并共享给宿主机。</p>
<h3 id="virtual-box-添加-host-only-网络"><a class="markdownIt-Anchor" href="#virtual-box-添加-host-only-网络"></a> Virtual Box 添加 Host-only 网络</h3>
<p>添加 host-only 网络需要先在 VB 进行全局设置： <code>File &gt; Host Network Manager &gt; Add</code>.</p>
<p>然后相应虚拟机设置中添加 Host-only 网络</p>
<h3 id="guest-中连接-vpn-并设置网络共享"><a class="markdownIt-Anchor" href="#guest-中连接-vpn-并设置网络共享"></a> Guest 中连接 VPN 并设置网络共享</h3>
<p>Guest 中 VPN 给 host-only 设置共享，Host 中设置路由，网关设置成 Guest 的 ip</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo route add -net 10.5.0.0 netmask 255.255.0.0 gw 192.168.56.101</span><br></pre></td></tr></table></figure>
<p>参考：</p>
<ol>
<li><a href="https://lizhiyong2000.github.io/2019/06/18/%E5%85%B1%E4%BA%ABVPN%E8%BF%9E%E6%8E%A5%E8%AE%BF%E9%97%AEVPN%E7%BD%91%E7%BB%9C/" target="_blank" rel="noopener">共享 VPN 连接访问 VPN 网络</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>PySpark 学习笔记</title>
    <url>/2019/06/PySpark-note/</url>
    <content><![CDATA[<h2 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h2>
<p>环境：Ubuntu 16.04 / python3.5</p>
<p>安装报错<code>Could not import pypandoc - required to package PySpark</code>，进行了如下操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install -U pip</span><br><span class="line">pip install -U setuptools</span><br><span class="line">sudo apt install pandoc #不确定是否起作用</span><br><span class="line">pip install pypandoc</span><br></pre></td></tr></table></figure>
<p>运行时发现未安装 JAVA</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install openjdk-8-jdk</span><br></pre></td></tr></table></figure>
<p>成功运行</p>
<a id="more"></a>
<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2>
<p>Spark 是 UC Berkeley AMP lab （加州大学伯克利分校的 AMP 实验室）所开源的类 Hadoop MapReduce 的通用并行框架，Spark，拥有 Hadoop MapReduce 所具有的优点；但不同于 MapReduce 的是 Job 中间输出结果可以保存在内存中，从而不再需要读写 HDFS，因此 Spark 能更好地适用于数据挖掘与机器学习等需要迭代的 MapReduce 的算法。</p>
<p>spark 支持 Scala，Java，JVM，Python，R。</p>
<p>Spark 的核心是一个对<code>由很多计算任务组成的、运行再多个工作机器或者是一个计算集群上的应用</code>进行调度、分发以及监控的计算引擎。</p>
<p><img src="http://insidebigdata.com/wp-content/uploads/2015/11/Spark_ecosystem.png" alt="" /></p>
<p>spark 提供类似 Python 的 pandas 或 R 语言的 data.frame 的操作，但有差异。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1531909-017acff244e3caf2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600/format/webp" alt="" /></p>
<p>SparkContext 使用 Py4J 启动 JVM 并创建 JavaSparkContext。默认情况下，PySpark 将 SparkContext 作为’sc’提供，因此创建新的 SparkContext 将不起作用。</p>
<p>Spark 应用程序会分离主节点上的单个驱动进程，然后将执行进程分配给多个工作节点。</p>
<p>shuffle 数据非常消耗资源，DAGScheduler 会对此进行优化。</p>
<p>Spark SQL 支持 SQL 查询和 DataFrame API，其核心是 Catalyst 优化器。</p>
<p>saprk 2.0 中 Sparksession 是读取数据，处理元数据，配置绘画和管理集群资源的入口。</p>
<p>创建 SparkContext</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">pyspark</span>.<span class="title">SparkContext</span> <span class="params">(</span></span></span><br><span class="line"><span class="class"><span class="params">   master = None,</span></span></span><br><span class="line"><span class="class"><span class="params">   appName = None, </span></span></span><br><span class="line"><span class="class"><span class="params">   sparkHome = None, </span></span></span><br><span class="line"><span class="class"><span class="params">   pyFiles = None, </span></span></span><br><span class="line"><span class="class"><span class="params">   environment = None, </span></span></span><br><span class="line"><span class="class"><span class="params">   batchSize = <span class="number">0</span>, </span></span></span><br><span class="line"><span class="class"><span class="params">   serializer = PickleSerializer<span class="params">()</span>, </span></span></span><br><span class="line"><span class="class"><span class="params">   conf = None, </span></span></span><br><span class="line"><span class="class"><span class="params">   gateway = None, </span></span></span><br><span class="line"><span class="class"><span class="params">   jsc = None, </span></span></span><br><span class="line"><span class="class"><span class="params">   profiler_cls = &lt;class <span class="string">'pyspark.profiler.BasicProfiler'</span>&gt;</span></span></span><br><span class="line"><span class="class"><span class="params">)</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">from</span> <span class="title">pyspark</span> <span class="title">import</span> <span class="title">SparkContext</span></span></span><br><span class="line">sc = SparkContext("local", "First App")</span><br></pre></td></tr></table></figure>
<p>以下是 SparkContext 的参数具体含义：</p>
<ul>
<li><code>Master</code>- 连接到的集群的 URL。</li>
<li><code>appName</code>- 工作名称。</li>
<li><code>sparkHome</code> - Spark 安装目录。</li>
<li><code>pyFiles</code> - 要发送到集群并添加到 PYTHONPATH 的。zip 或。py 文件。</li>
<li><code>environment</code> - 工作节点环境变量。</li>
<li><code>batchSize</code> - 表示为单个 Java 对象的 Python 对象的数量。设置 1 以禁用批处理，设置 0 以根据对象大小自动选择批处理大小，或设置为-1 以使用无限批处理大小。</li>
<li><code>serializer</code>- RDD 序列化器。</li>
<li><code>Conf</code> - <code>SparkConf</code>的一个对象，用于设置所有 Spark 属性。</li>
<li><code>gateway</code>  - 使用现有网关和 JVM，否则初始化新 JVM。</li>
<li><code>JSC</code> - JavaSparkContext 实例。</li>
<li><code>profiler_cls</code> - 用于进行性能分析的一类自定义 Profiler（默认为<code>pyspark.profiler.BasicProfiler</code>）。</li>
</ul>
<h2 id="rdd"><a class="markdownIt-Anchor" href="#rdd"></a> RDD</h2>
<p>RDD（弹性分布式数据集，Resilient Distributed Dataset），是 JVM 对象的分布式集合。</p>
<h3 id="数据读取"><a class="markdownIt-Anchor" href="#数据读取"></a> 数据读取</h3>
<p>RDD 支持多种数据格式读取：文本，parquest，JSON，Hive tables 以及使用 JDBC 驱动可以读取的数据库。Spark 可以自动处理压缩包。</p>
<p>从文件中读取的数据为 MapPartitionRDD，使用。parallelize() 方式获得的是 ParallelCollectionRDD。</p>
<p>RDD 无 schema，可以混用任何数据类型。</p>
<blockquote>
<p>定义纯 Python 方法会降低程序的速度，Spark 需要在 Python 解释器和 JVM 之间切换，因此尽可能使用 Spark 内置的功能。</p>
</blockquote>
<p>作用域：每个执行器从驱动程序中获得一份变量和方法的副本，执行器对这些变量或方法的修改其他执行者是不可见的。</p>
<h3 id="转换"><a class="markdownIt-Anchor" href="#转换"></a> 转换</h3>
<p>转换包括映射、筛选、连接、转换数据集中的值。</p>
<ul>
<li>
<p>.map()</p>
<p>对 RDD 的每个元素进行转换，通常搭配<code>lambda</code>，输出为多列时需要打包成一个 tuple</p>
<p><code>.map(lambda row: (row[16], int(row[16])))</code></p>
</li>
<li>
<p>.filter()</p>
<p>从数据集中选择元素：<code>.filter(lambda row: row[16] == '2014' and row[21] == '0')</code></p>
</li>
<li>
<p>flatMap()</p>
<p>把所有结果扁平化简单拼接</p>
</li>
<li>
<p>.distinct()</p>
<p>返回 distinct 值，开销大，慎用</p>
</li>
<li>
<p>.sample()</p>
<p>sample(isReplace, fraction, seed)</p>
</li>
<li>
<p>.leftOuterJoin()</p>
<p>和 SQL 中一样，<code>a.leftOuterJoin(b)</code>，高开销，慎用。<code>.join()</code>为内连接，<code>.intersection()</code>返回相同的记录</p>
</li>
<li>
<p>.repartition()</p>
<p>重新对数据集进行分区，改变分区数量，会重组数据，开销大，慎用。</p>
</li>
</ul>
<h3 id="行动"><a class="markdownIt-Anchor" href="#行动"></a> 行动</h3>
<ul>
<li>
<p>take()</p>
<p>返回单个数据分区的前 n 行。可以使用 <code>takeSample()</code>取随机样本。</p>
</li>
<li>
<p>collect()</p>
</li>
<li>
<p>reduce()</p>
<p>reduce() 传递的函数需要不受元素顺序和操作符顺序的影响，如<code>x+y</code>没问题，<code>x/y</code>不行</p>
</li>
<li>
<p>count()</p>
<p>统计数量，只返回统计值，不会将数据集返回到驱动程序。如果数据集是 key-value 形式，可以使用 <code>countBykey()</code>方式获取不同键的计数。</p>
</li>
<li>
<p>saveAsTextFile()</p>
<p>把 RDD 保存为文本文件，但不可使用<code>open()</code>读取，要使用<code>textFile()</code>读取。所有数据以字符串形式读取，想要转换为数字要自己进行解析。</p>
</li>
<li>
<p>foreach()</p>
<p>类似<code>map()</code>，对每个元素进行操作，但不要求返回值为 RDD 支持的类型，可以保存到 pyspark 本身不支持的数据库。</p>
</li>
</ul>
<p>Spark 对 RDD 的计算是惰性的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lines = sc.textFile(<span class="string">"README.md"</span>)</span><br><span class="line">pythonLines = lines.filter(<span class="keyword">lambda</span> line: <span class="string">"Python"</span> <span class="keyword">in</span> line)</span><br><span class="line">pythonLines.first()</span><br></pre></td></tr></table></figure>
<p>上例中，第 1，2 行的语句（转换操作）都不会真正计算 RDD，只有再第三行使用到 RDD（行动操作）的时候，才去按照既定的规则扫描文本。若是在第 1 句就讲文本读进内存，而第 2 句又过滤了大量文本，浪费资源。</p>
<p>默认情况下，每次行动操作时会重新计算 RDD，除非使用<code>RDD.persist()</code>将其缓存。</p>
<ul>
<li>转换操作：输入 RDD（可能有多个），返回 RDD</li>
<li>行动操作：输出结果，会触发实际的计算</li>
</ul>
<p>Spark 会维护一个<code>lineage graph/谱系图</code>来记录不同的 RDD 之间的关系，需要这些信息来按需计算 RDD。</p>
<p><strong>传递函数时需要注意，当传递的是某个对象的成员或者包含某个对象中字段的引用，Spark 会把整个对象都发送到工作节点上</strong>，替代方案是将所需字段保存为局部变量再传递。</p>
<h2 id="dataframe"><a class="markdownIt-Anchor" href="#dataframe"></a> DataFrame</h2>
<p><code>Spark 2.0</code><br />
中，我们使用<code>SparkSession</code>来替代<code>SQLContext</code>。各种 Spark 的上下文语境<br />
<code>HiveContext</code>、<code>SQLContext</code>、<code>StreamingContext</code>和<code>SparkContext</code>都被整合到了<br />
<code>SparkSession</code>，这样一来，只需要将此会话作为读取数据的入口点，和元数据、配置以及群集资源管理一起来使用。</p>
<h3 id="python-rdd-的通信"><a class="markdownIt-Anchor" href="#python-rdd-的通信"></a> Python - RDD 的通信</h3>
<p><img src="https://i.loli.net/2020/03/17/zLponBPxWOitYV8.png" alt="" /></p>
<h3 id="catalyst-优化器"><a class="markdownIt-Anchor" href="#catalyst-优化器"></a> Catalyst 优化器</h3>
<p><code>Spark SQL</code> 引擎既有基于规则的优化，也有基于成本的优化，包括但不限于谓词下推和列精简。</p>
<p><img src="https://i.loli.net/2020/03/17/PSr9st4CqTegwWc.png" alt="" /></p>
<h3 id="创建-dataframe"><a class="markdownIt-Anchor" href="#创建-dataframe"></a> 创建 DataFrame</h3>
<blockquote>
<p>在 spark 1.x 中使用 sqlContext</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Create SparkSession</span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> SparkSession</span><br><span class="line">spark = SparkSession \</span><br><span class="line">    .builder \</span><br><span class="line">    .appName(<span class="string">"Python Spark SQL basic example"</span>) \</span><br><span class="line">    .config(<span class="string">"spark.some.config.option"</span>, <span class="string">"some-value"</span>) \</span><br><span class="line">    .getOrCreate()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Generate JSON data </span></span><br><span class="line">stringJSONRDD = sc.parallelize((<span class="string">""" </span></span><br><span class="line"><span class="string">  &#123; "id": "123",</span></span><br><span class="line"><span class="string">    "name": "Katie",</span></span><br><span class="line"><span class="string">    "age": 19,</span></span><br><span class="line"><span class="string">    "eyeColor": "brown"</span></span><br><span class="line"><span class="string">  &#125;"""</span>,</span><br><span class="line">   <span class="string">"""&#123;</span></span><br><span class="line"><span class="string">    "id": "234",</span></span><br><span class="line"><span class="string">    "name": "Michael",</span></span><br><span class="line"><span class="string">    "age": 22,</span></span><br><span class="line"><span class="string">    "eyeColor": "green"</span></span><br><span class="line"><span class="string">  &#125;"""</span>, </span><br><span class="line">  <span class="string">"""&#123;</span></span><br><span class="line"><span class="string">    "id": "345",</span></span><br><span class="line"><span class="string">    "name": "Simone",</span></span><br><span class="line"><span class="string">    "age": 23,</span></span><br><span class="line"><span class="string">    "eyeColor": "blue"</span></span><br><span class="line"><span class="string">  &#125;"""</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create DataFrame using spark.read.json</span></span><br><span class="line">swimmersJSON = spark.read.json(stringJSONRDD)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create temporary table which is necessary for sql</span></span><br><span class="line">swimmersJSON.createOrReplaceTempView(<span class="string">"swimmersJSON"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># get a parameter for the number of rows</span></span><br><span class="line"><span class="comment"># default 10</span></span><br><span class="line">swimmersJSON.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># SQL Query</span></span><br><span class="line">spark.sql(<span class="string">"select * from swimmersJSON"</span>).collect()</span><br></pre></td></tr></table></figure>
<p>Spark 使用反射自动推断数据类型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Print the schema</span></span><br><span class="line">swimmersJSON.printSchema()</span><br></pre></td></tr></table></figure>
<p>指定类型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark.sql.types <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># Generate our own CSV data </span></span><br><span class="line"><span class="comment">#   This way we don't have to access the file system yet.</span></span><br><span class="line">stringCSVRDD = sc.parallelize([(<span class="number">123</span>, <span class="string">'Katie'</span>, <span class="number">19</span>, <span class="string">'brown'</span>), (<span class="number">234</span>, <span class="string">'Michael'</span>, <span class="number">22</span>, <span class="string">'green'</span>), (<span class="number">345</span>, <span class="string">'Simone'</span>, <span class="number">23</span>, <span class="string">'blue'</span>)])</span><br><span class="line"></span><br><span class="line">schema = StructType([</span><br><span class="line">    StructField(<span class="string">"id"</span>, LongType(), <span class="literal">True</span>),    </span><br><span class="line">    StructField(<span class="string">"name"</span>, StringType(), <span class="literal">True</span>),</span><br><span class="line">    StructField(<span class="string">"age"</span>, LongType(), <span class="literal">True</span>),</span><br><span class="line">    StructField(<span class="string">"eyeColor"</span>, StringType(), <span class="literal">True</span>)</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Apply the schema to the RDD and Create DataFrame</span></span><br><span class="line">swimmers = spark.createDataFrame(stringCSVRDD, schema)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Creates a temporary view using the DataFrame</span></span><br><span class="line"><span class="comment"># 这句是必须的，否则'Table or view not found: swimmers; line 1 pos 14'</span></span><br><span class="line">swimmers.createOrReplaceTempView(<span class="string">"swimmers"</span>)</span><br><span class="line"></span><br><span class="line">swimmers.printSchema()</span><br></pre></td></tr></table></figure>
<h3 id="sql-查询"><a class="markdownIt-Anchor" href="#sql-查询"></a> SQL 查询</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">swimmers.count()</span><br><span class="line">spark.sql(<span class="string">"select count(1) from swimmers"</span>).show()</span><br><span class="line"></span><br><span class="line">swimmers.select(swimmers.id, swimmers.age).filter(swimmers.age == <span class="number">22</span>).show()</span><br><span class="line">swimmers.select(<span class="string">"id"</span>, <span class="string">"age"</span>).filter(<span class="string">"age = 22"</span>).show()</span><br><span class="line">spark.sql(<span class="string">"select id, age from swimmers where age = 22"</span>).show()</span><br><span class="line"></span><br><span class="line">spark.sql(<span class="string">"select id, age from swimmers where age = 22"</span>).show()</span><br></pre></td></tr></table></figure>
<h3 id="使用案例"><a class="markdownIt-Anchor" href="#使用案例"></a> 使用案例</h3>
<p><a href="https://github.com/drabastomek/learningPySpark/blob/master/Data/airport-codes-na.txt" target="_blank" rel="noopener">机场数据</a></p>
<p><a href="https://github.com/drabastomek/learningPySpark/blob/master/Data/departuredelays.csv" target="_blank" rel="noopener">航班数据</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">flightPerfFilePath = <span class="string">"spark/flights/departuredelays.csv"</span></span><br><span class="line">airportsFilePath = <span class="string">"spark/flights/airport-codes-na.txt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取机场数据</span></span><br><span class="line">airports = spark.read.csv(airportsFilePath, header=<span class="string">'true'</span>, inferSchema=<span class="string">'true'</span>, sep=<span class="string">'\t'</span>)</span><br><span class="line">airports.createOrReplaceTempView(<span class="string">"airports"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取航班数据</span></span><br><span class="line">flightPerf = spark.read.csv(flightPerfFilePath, header=<span class="string">'true'</span>)</span><br><span class="line">flightPerf.createOrReplaceTempView(<span class="string">"FlightPerformance"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 缓存数据，加快查询</span></span><br><span class="line"><span class="comment"># Cache the Departure Delays dataset </span></span><br><span class="line">flightPerf.cache()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># SQL 关联查询从'WA'起飞的航班的总延误时长</span></span><br><span class="line">spark.sql(<span class="string">"""</span></span><br><span class="line"><span class="string">select a.City, f.origin, sum(f.delay) as Delays </span></span><br><span class="line"><span class="string">  from FlightPerformance f </span></span><br><span class="line"><span class="string">    join airports a </span></span><br><span class="line"><span class="string">on a.IATA = f.origin </span></span><br><span class="line"><span class="string">where a.State = 'WA' </span></span><br><span class="line"><span class="string">group by a.City, f.origin </span></span><br><span class="line"><span class="string">order by sum(f.delay) desc</span></span><br><span class="line"><span class="string">"""</span>).show()</span><br></pre></td></tr></table></figure>
<h2 id="数据建模"><a class="markdownIt-Anchor" href="#数据建模"></a> 数据建模</h2>
<h3 id="清洗数据"><a class="markdownIt-Anchor" href="#清洗数据"></a> 清洗数据</h3>
<ul>
<li>重复数据</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = spark.createDataFrame([</span><br><span class="line">        (<span class="number">1</span>, <span class="number">144.5</span>, <span class="number">5.9</span>, <span class="number">33</span>, <span class="string">'M'</span>),</span><br><span class="line">        (<span class="number">2</span>, <span class="number">167.2</span>, <span class="number">5.4</span>, <span class="number">45</span>, <span class="string">'M'</span>),</span><br><span class="line">        (<span class="number">3</span>, <span class="number">124.1</span>, <span class="number">5.2</span>, <span class="number">23</span>, <span class="string">'F'</span>),</span><br><span class="line">        (<span class="number">4</span>, <span class="number">144.5</span>, <span class="number">5.9</span>, <span class="number">33</span>, <span class="string">'M'</span>),</span><br><span class="line">        (<span class="number">5</span>, <span class="number">133.2</span>, <span class="number">5.7</span>, <span class="number">54</span>, <span class="string">'F'</span>),</span><br><span class="line">        (<span class="number">3</span>, <span class="number">124.1</span>, <span class="number">5.2</span>, <span class="number">23</span>, <span class="string">'F'</span>),</span><br><span class="line">        (<span class="number">5</span>, <span class="number">129.2</span>, <span class="number">5.3</span>, <span class="number">42</span>, <span class="string">'M'</span>),</span><br><span class="line">    ], [<span class="string">'id'</span>, <span class="string">'weight'</span>, <span class="string">'height'</span>, <span class="string">'age'</span>, <span class="string">'gender'</span>])</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 检查是否有重复</span></span><br><span class="line">print(<span class="string">'Count of rows: &#123;0&#125;'</span>.format(df.count()))</span><br><span class="line">print(<span class="string">'Count of distinct rows: &#123;0&#125;'</span>.format(df.distinct().count()))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除重复数据</span></span><br><span class="line">df = df.dropDuplicates()</span><br><span class="line">df.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查除了 id 以外的数据是否相同</span></span><br><span class="line">print(<span class="string">'Count of ids: &#123;0&#125;'</span>.format(df.count()))</span><br><span class="line">print(<span class="string">'Count of distinct ids: &#123;0&#125;'</span>.format(</span><br><span class="line">    df.select([c <span class="keyword">for</span> c <span class="keyword">in</span> df.columns <span class="keyword">if</span> c != <span class="string">'id'</span>]).distinct().count()))</span><br><span class="line"><span class="comment"># 使用 subset 指定列，删除重复数据</span></span><br><span class="line">df = df.dropDuplicates(subset=[c <span class="keyword">for</span> c <span class="keyword">in</span> df.columns <span class="keyword">if</span> c != <span class="string">'id'</span>])</span><br><span class="line">df.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查 id 的唯一性</span></span><br><span class="line"><span class="keyword">import</span> pyspark.sql.functions <span class="keyword">as</span> fn</span><br><span class="line"></span><br><span class="line">df.agg(</span><br><span class="line">    fn.count(<span class="string">'id'</span>).alias(<span class="string">'count'</span>),</span><br><span class="line">    fn.countDistinct(<span class="string">'id'</span>).alias(<span class="string">'distinct'</span>)</span><br><span class="line">).show()</span><br><span class="line"><span class="comment"># 创建新的自增 id，似乎不是随机的</span></span><br><span class="line">df.withColumn(<span class="string">'new_id'</span>, fn.monotonically_increasing_id()).show()</span><br></pre></td></tr></table></figure>
<ul>
<li>缺失值</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df_miss = spark.createDataFrame([</span><br><span class="line">        (<span class="number">1</span>, <span class="number">143.5</span>, <span class="number">5.6</span>, <span class="number">28</span>,   <span class="string">'M'</span>,  <span class="number">100000</span>),</span><br><span class="line">        (<span class="number">2</span>, <span class="number">167.2</span>, <span class="number">5.4</span>, <span class="number">45</span>,   <span class="string">'M'</span>,  <span class="literal">None</span>),</span><br><span class="line">        (<span class="number">3</span>, <span class="literal">None</span> , <span class="number">5.2</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>),</span><br><span class="line">        (<span class="number">4</span>, <span class="number">144.5</span>, <span class="number">5.9</span>, <span class="number">33</span>,   <span class="string">'M'</span>,  <span class="literal">None</span>),</span><br><span class="line">        (<span class="number">5</span>, <span class="number">133.2</span>, <span class="number">5.7</span>, <span class="number">54</span>,   <span class="string">'F'</span>,  <span class="literal">None</span>),</span><br><span class="line">        (<span class="number">6</span>, <span class="number">124.1</span>, <span class="number">5.2</span>, <span class="literal">None</span>, <span class="string">'F'</span>,  <span class="literal">None</span>),</span><br><span class="line">        (<span class="number">7</span>, <span class="number">129.2</span>, <span class="number">5.3</span>, <span class="number">42</span>,   <span class="string">'M'</span>,  <span class="number">76000</span>),</span><br><span class="line">    ], [<span class="string">'id'</span>, <span class="string">'weight'</span>, <span class="string">'height'</span>, <span class="string">'age'</span>, <span class="string">'gender'</span>, <span class="string">'income'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询每行的缺失情况（几列）</span></span><br><span class="line">df_miss.rdd.map(</span><br><span class="line">    <span class="keyword">lambda</span> row: (row[<span class="string">'id'</span>], sum([c == <span class="literal">None</span> <span class="keyword">for</span> c <span class="keyword">in</span> row]))</span><br><span class="line">).collect()</span><br><span class="line"><span class="comment"># 查看某条记录的数据情况</span></span><br><span class="line">df_miss.where(<span class="string">'id == 3'</span>).show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 各特征的缺失比例</span></span><br><span class="line">df_miss.agg(*[</span><br><span class="line">    (<span class="number">1</span> - (fn.count(c) / fn.count(<span class="string">'*'</span>))).alias(c + <span class="string">'_missing'</span>)</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> df_miss.columns</span><br><span class="line">]).show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除某个缺失值过多的特征（列）</span></span><br><span class="line">df_miss_no_income = df_miss.select([c <span class="keyword">for</span> c <span class="keyword">in</span> df_miss.columns <span class="keyword">if</span> c != <span class="string">'income'</span>])</span><br><span class="line">df_miss_no_income.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除特征缺失数大于等于 3 个的行</span></span><br><span class="line">df_miss_no_income.dropna(thresh=<span class="number">3</span>).show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 缺失值填充</span></span><br><span class="line">means = df_miss_no_income.agg(</span><br><span class="line">    *[fn.mean(c).alias(c) <span class="keyword">for</span> c <span class="keyword">in</span> df_miss_no_income.columns <span class="keyword">if</span> c != <span class="string">'gender'</span>]</span><br><span class="line">).toPandas().to_dict(<span class="string">'records'</span>)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">means[<span class="string">'gender'</span>] = <span class="string">'missing'</span></span><br><span class="line"></span><br><span class="line">df_miss_no_income.fillna(means).show()</span><br></pre></td></tr></table></figure>
<ul>
<li>离群值</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df_outliers = spark.createDataFrame([</span><br><span class="line">        (<span class="number">1</span>, <span class="number">143.5</span>, <span class="number">5.3</span>, <span class="number">28</span>),</span><br><span class="line">        (<span class="number">2</span>, <span class="number">154.2</span>, <span class="number">5.5</span>, <span class="number">45</span>),</span><br><span class="line">        (<span class="number">3</span>, <span class="number">342.3</span>, <span class="number">5.1</span>, <span class="number">99</span>),</span><br><span class="line">        (<span class="number">4</span>, <span class="number">144.5</span>, <span class="number">5.5</span>, <span class="number">33</span>),</span><br><span class="line">        (<span class="number">5</span>, <span class="number">133.2</span>, <span class="number">5.4</span>, <span class="number">54</span>),</span><br><span class="line">        (<span class="number">6</span>, <span class="number">124.1</span>, <span class="number">5.1</span>, <span class="number">21</span>),</span><br><span class="line">        (<span class="number">7</span>, <span class="number">129.2</span>, <span class="number">5.3</span>, <span class="number">42</span>),</span><br><span class="line">    ], [<span class="string">'id'</span>, <span class="string">'weight'</span>, <span class="string">'height'</span>, <span class="string">'age'</span>])</span><br><span class="line"></span><br><span class="line">cols = [<span class="string">'weight'</span>, <span class="string">'height'</span>, <span class="string">'age'</span>]</span><br><span class="line">bounds = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算四分之一位点，并计算边界</span></span><br><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> cols:</span><br><span class="line">    quantiles = df_outliers.approxQuantile(col, [<span class="number">0.25</span>, <span class="number">0.75</span>], <span class="number">0.05</span>)</span><br><span class="line">    IQR = quantiles[<span class="number">1</span>] - quantiles[<span class="number">0</span>]</span><br><span class="line">    bounds[col] = [quantiles[<span class="number">0</span>] - <span class="number">1.5</span> * IQR, quantiles[<span class="number">1</span>] + <span class="number">1.5</span> * IQR]</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 筛选离群点  </span></span><br><span class="line">outliers = df_outliers.select(*[<span class="string">'id'</span>] + [</span><br><span class="line">    (</span><br><span class="line">        (df_outliers[c] &lt; bounds[c][<span class="number">0</span>]) | </span><br><span class="line">        (df_outliers[c] &gt; bounds[c][<span class="number">1</span>])</span><br><span class="line">    ).alias(c + <span class="string">'_o'</span>) <span class="keyword">for</span> c <span class="keyword">in</span> cols</span><br><span class="line">])</span><br><span class="line">outliers.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看相应的值</span></span><br><span class="line">df_outliers = df_outliers.join(outliers, on=<span class="string">'id'</span>)</span><br><span class="line">df_outliers.filter(<span class="string">'weight_o'</span>).select(<span class="string">'id'</span>, <span class="string">'weight'</span>).show()</span><br><span class="line">df_outliers.filter(<span class="string">'age_o'</span>).select(<span class="string">'id'</span>, <span class="string">'age'</span>).show()</span><br></pre></td></tr></table></figure>
<h3 id="熟悉数据"><a class="markdownIt-Anchor" href="#熟悉数据"></a> 熟悉数据</h3>
<ul>
<li>描述性统计</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fraud_df.groupby(<span class="string">'gender'</span>).count().show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对数值变量进行统计，统计信息包括 count/mean/stddev/min/max</span></span><br><span class="line">numerical = [<span class="string">'balance'</span>, <span class="string">'numTrans'</span>, <span class="string">'numIntlTrans'</span>]</span><br><span class="line">desc = fraud_df.describe(numerical)</span><br><span class="line">desc.show()</span><br></pre></td></tr></table></figure>
<ul>
<li>相关性</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># numerical 为三个数值型特征，计算它们的相关性矩阵</span></span><br><span class="line">numerical = [<span class="string">'balance'</span>, <span class="string">'numTrans'</span>, <span class="string">'numIntlTrans'</span>]</span><br><span class="line">n_numerical = len(numerical)</span><br><span class="line"></span><br><span class="line">corr = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n_numerical):</span><br><span class="line">    temp = [<span class="literal">None</span>] * i</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(i, n_numerical):</span><br><span class="line">        temp.append(fraud_df.corr(numerical[i], numerical[j]))</span><br><span class="line">    corr.append(temp)</span><br><span class="line">    </span><br><span class="line">print(corr)</span><br></pre></td></tr></table></figure>
<ul>
<li>可视化</li>
</ul>
<p>可使用 <code>matplotlib</code> 不详细展开</p>
<h2 id="mllib"><a class="markdownIt-Anchor" href="#mllib"></a> MLlib</h2>
<ul>
<li>ML 和 MLlib 都是 Spark 中的机器学习库，目前常用的机器学习功能 2 个库都能满足需求。</li>
<li>ML 从 Spark 2.0 开始作为主要的机器学习库， 因为 ML 功能更全面更灵活，未来会主要支持 ML，MLlib 很有可能会被废弃（据说可能是在 spark3.0 中 deprecated）。</li>
<li>ML 主要操作的是 DataFrame， 而 MLlib 操作的是 RDD，也就是说二者面向的数据集不一样。相比于 MLlib 在 RDD 提供的基础操作，ML 在 DataFrame 上的抽象级别更高，数据和操作耦合度更低。
<ul>
<li>DataFrame 和 RDD 什么关系？DataFrame 是 Dataset 的子集，也就是 Dataset[Row]， 而 DataSet 是对 RDD 的封装，对 SQL 之类的操作做了很多优化。</li>
</ul>
</li>
<li>相比于 MLlib 在 RDD 提供的基础操作，ML 在 DataFrame 上的抽象级别更高，数据和操作耦合度更低。</li>
<li>ML 中的操作可以使用 pipeline， 跟 sklearn 一样，可以把很多操作（算法/特征提取/特征转换）以管道的形式串起来，然后让数据在这个管道中流动。</li>
<li>ML 中无论是什么模型，都提供了统一的算法操作接口，比如模型训练都是<code>fit</code>；不像 MLlib 中不同模型会有各种各样的<code>trainXXX</code>。</li>
<li>MLlib 在 spark2.0 之后进入<code>维护状态</code>， 这个状态通常只修复 BUG 不增加新功能。</li>
</ul>
<p>MLlib 包括了三个核心机器学习功能：</p>
<ul>
<li>
<p>数据准备：特征提取、变换、选择、分类特征的散列和一些自然语言处理方法。</p>
</li>
<li>
<p>机器学习算法：实现了一些流行和高级的回归，分类和聚类算法。</p>
</li>
<li>
<p>实用程序：统计方法，如描述性统计、卡方检验、线性代数（稀疏稠密矩阵和向量）<br />
和模型评估方法。</p>
</li>
</ul>
<h3 id="mllib-中的逻辑回归"><a class="markdownIt-Anchor" href="#mllib-中的逻辑回归"></a> MLlib 中的逻辑回归</h3>
<p>MLlib 过去使用 SGD 算法求解，在 Spark 2.0 后被废除，使用 <code>LogisticRegressionWithBFGS</code> 模型，该模型用的是 L-BGFS 优化方法。</p>
<p>评价指标</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pyspark.mllib.evaluation <span class="keyword">as</span> ev</span><br><span class="line">LR_evaluation = ev.BinaryClassificationMetrics(LR_results)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Area under PR: &#123;0:.2f&#125;'</span> \</span><br><span class="line">      .format(LR_evaluation.areaUnderPR))</span><br><span class="line">print(<span class="string">'Area under ROC: &#123;0:.2f&#125;'</span> \</span><br><span class="line">      .format(LR_evaluation.areaUnderROC))</span><br><span class="line">LR_evaluation.unpersist()</span><br></pre></td></tr></table></figure>
<h3 id=""><a class="markdownIt-Anchor" href="#"></a> </h3>
<h2 id="ml-包"><a class="markdownIt-Anchor" href="#ml-包"></a> ML 包</h2>
<p>在顶层，该软件包公开了三个主要的抽象类：转换器（Transformer）、评估器（Estimator）和管道（Pipeline)。</p>
<h3 id="转换器"><a class="markdownIt-Anchor" href="#转换器"></a> 转换器</h3>
<p><code>spark.ml.feature</code> 中提供了许多转换器</p>
<ul>
<li>Binarizer：根据指定的阈值将连续变量转换为对应的二进制值</li>
<li>Bucketizer：根据阈值列表，将连续变量转换为多项值</li>
<li>QuantileDiscretizer：类似 Bucketizer，传递一个 numBuckets 参数，计算分位数进行数据划分</li>
<li>ChiSqSelector：根据卡方检验选择预定义数量的特征</li>
<li>CountVectorizer</li>
<li>DCT：离散余弦变换取实数值向量，并返回相同长度的向量</li>
<li>ElementwiseProduct：逐元素乘积</li>
<li>HashingTF：输入为标记文本的列表，返回一个带有计数的有预订长度的向量</li>
<li>MaxAbsScaler：将数据调整到 [-1, 1]</li>
<li>MinMaxScaler：将数据缩放到 [0,  1]</li>
<li>Normalizer</li>
<li>NGram：输入为标记文本的列表（一个词为一个元素），返回结果包含 n-gram 列表</li>
<li>OneHotEncoder</li>
<li>PCA</li>
<li>PolynominalExpansion：执行向量的多项式扩展，可以创建特征关联项</li>
<li>RFormula：可以传递一个公式，如 <code>vec ~ x*3 + y</code>，将产生 vec 列</li>
<li>StandardScaler：标准化，均值为 0，标准差为 1</li>
<li>VectorAssembler：将多个数字列合并为一列向量</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = spark.createDataFrame(</span><br><span class="line">    [(<span class="number">12</span>,<span class="number">10</span>,<span class="number">3</span>), (<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>)], [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>])</span><br><span class="line"></span><br><span class="line">ft.VectorAssembler(inputCols=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>],</span><br><span class="line">    outputCol=<span class="string">'features'</span>)\</span><br><span class="line">    .transform(df)\</span><br><span class="line">    .select(<span class="string">'features'</span>)\</span><br><span class="line">    .collect()</span><br></pre></td></tr></table></figure>
<p>输出为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Row(features&#x3D;DenseVector([12.0, 10.0, 3.0])),</span><br><span class="line"> Row(features&#x3D;DenseVector([1.0, 4.0, 2.0]))]</span><br></pre></td></tr></table></figure>
<h3 id="评估器"><a class="markdownIt-Anchor" href="#评估器"></a> 评估器</h3>
<h4 id="分类"><a class="markdownIt-Anchor" href="#分类"></a> 分类</h4>
<p>ML 包提供了 7 种分类模型</p>
<ul>
<li>LogisticRegression：目前仅支持二分类</li>
<li>DecisionTreeClassifier</li>
<li>RandomForestClassifier：支持多分类</li>
<li>GBTClassifier：用于分类的梯度提升决策树模型，支持二进制标签，连续特征和分类特征</li>
<li>NaiveBayes：支持多分类</li>
<li>MultilayerPerceptionClassifier</li>
<li>OneVsRest：使用 <code>one vs rest</code>  策略将多分类问题转换为二分类</li>
</ul>
<h4 id="回归"><a class="markdownIt-Anchor" href="#回归"></a> 回归</h4>
<p>ML 包提供 7 种回归模型</p>
<ul>
<li>LinearRegression</li>
<li>AFTSurvivalRegression：加速失效时间生存回归模型。它是一个参数化模型，假设其中一个特征的边际效应加速或减缓了预期寿命，适合具有明确阶段的过程。</li>
<li>DecisionTreeRegression</li>
<li>RandomForestRegression</li>
<li>GBTRegression</li>
<li>GeneralizedLinearRegression：支持 gaussian、binomial、gamma 和 poisson 分布</li>
<li>IsotonicRegression：保序回归，拟合一个非递减的函数，适用于有序和递增的数据集</li>
</ul>
<h4 id="聚类"><a class="markdownIt-Anchor" href="#聚类"></a> 聚类</h4>
<p>ML 包提供 4 种聚类模型</p>
<ul>
<li>KMeans：将样本分为 K 个簇，迭代地划分，使得簇内样本和所属簇的质点之间的距离平方和最小</li>
<li>BisectingKMeans：二分 K 均值算法，结合了 K 均值聚类和层级聚类算法。最初将所有样本作为一个簇，逐步迭代分解为 K 个簇</li>
<li>GaussianMixture：高斯混合模型，使用具有未知参数的 k 个高斯分布刻画数据集，使用期望最大算法寻找参数。对于特征数多的问题，可能表现不佳</li>
<li>LDA</li>
</ul>
<h3 id="实例"><a class="markdownIt-Anchor" href="#实例"></a> 实例</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pyspark.sql.types <span class="keyword">as</span> typ</span><br><span class="line"></span><br><span class="line">labels = [</span><br><span class="line">    (<span class="string">'INFANT_ALIVE_AT_REPORT'</span>, typ.IntegerType()),</span><br><span class="line">    (<span class="string">'BIRTH_PLACE'</span>, typ.StringType()),</span><br><span class="line">    (<span class="string">'MOTHER_AGE_YEARS'</span>, typ.IntegerType()),</span><br><span class="line">    (<span class="string">'FATHER_COMBINED_AGE'</span>, typ.IntegerType()),</span><br><span class="line">    (<span class="string">'CIG_BEFORE'</span>, typ.IntegerType()),</span><br><span class="line">    (<span class="string">'CIG_1_TRI'</span>, typ.IntegerType()),</span><br><span class="line">    (<span class="string">'CIG_2_TRI'</span>, typ.IntegerType()),</span><br><span class="line">    (<span class="string">'CIG_3_TRI'</span>, typ.IntegerType()),</span><br><span class="line">    (<span class="string">'MOTHER_HEIGHT_IN'</span>, typ.IntegerType()),</span><br><span class="line">    (<span class="string">'MOTHER_PRE_WEIGHT'</span>, typ.IntegerType()),</span><br><span class="line">    (<span class="string">'MOTHER_DELIVERY_WEIGHT'</span>, typ.IntegerType()),</span><br><span class="line">    (<span class="string">'MOTHER_WEIGHT_GAIN'</span>, typ.IntegerType()),</span><br><span class="line">    (<span class="string">'DIABETES_PRE'</span>, typ.IntegerType()),</span><br><span class="line">    (<span class="string">'DIABETES_GEST'</span>, typ.IntegerType()),</span><br><span class="line">    (<span class="string">'HYP_TENS_PRE'</span>, typ.IntegerType()),</span><br><span class="line">    (<span class="string">'HYP_TENS_GEST'</span>, typ.IntegerType()),</span><br><span class="line">    (<span class="string">'PREV_BIRTH_PRETERM'</span>, typ.IntegerType())</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">schema = typ.StructType([</span><br><span class="line">    typ.StructField(e[<span class="number">0</span>], e[<span class="number">1</span>], <span class="literal">False</span>) <span class="keyword">for</span> e <span class="keyword">in</span> labels</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">births = spark.read.csv(<span class="string">'births_transformed.csv.gz'</span>, </span><br><span class="line">                        header=<span class="literal">True</span>, </span><br><span class="line">                        schema=schema)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pyspark.ml.feature <span class="keyword">as</span> ft</span><br><span class="line"><span class="comment"># string 转 int</span></span><br><span class="line">births = births.withColumn(<span class="string">'BIRTH_PLACE_INT'</span>, </span><br><span class="line">        births[<span class="string">'BIRTH_PLACE'</span>].cast(typ.IntegerType()))</span><br><span class="line">encoder = ft.OneHotEncoder(</span><br><span class="line">    inputCol=<span class="string">'BIRTH_PLACE_INT'</span>, </span><br><span class="line">    outputCol=<span class="string">'BIRTH_PLACE_VEC'</span>)</span><br><span class="line"></span><br><span class="line">featuresCreator = ft.VectorAssembler(</span><br><span class="line">    inputCols=[</span><br><span class="line">        col[<span class="number">0</span>] </span><br><span class="line">        <span class="keyword">for</span> col </span><br><span class="line">        <span class="keyword">in</span> labels[<span class="number">2</span>:]] + \</span><br><span class="line">    [encoder.getOutputCol()], </span><br><span class="line">    outputCol=<span class="string">'features'</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pyspark.ml.classification <span class="keyword">as</span> cl</span><br><span class="line">logistic = cl.LogisticRegression(</span><br><span class="line">    maxIter=<span class="number">10</span>, </span><br><span class="line">    regParam=<span class="number">0.01</span>, </span><br><span class="line">    labelCol=<span class="string">'INFANT_ALIVE_AT_REPORT'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个管道用于训练模型</span></span><br><span class="line"><span class="keyword">from</span> pyspark.ml <span class="keyword">import</span> Pipeline</span><br><span class="line"></span><br><span class="line">pipeline = Pipeline(stages=[</span><br><span class="line">        encoder, </span><br><span class="line">        featuresCreator, </span><br><span class="line">        logistic</span><br><span class="line">    ])</span><br><span class="line"><span class="comment"># 划分训练集和测试集</span></span><br><span class="line">births_train, births_test = births \</span><br><span class="line">    .randomSplit([<span class="number">0.7</span>, <span class="number">0.3</span>], seed=<span class="number">666</span>)</span><br><span class="line"><span class="comment"># 训练并预测模型</span></span><br><span class="line">model = pipeline.fit(births_train)</span><br><span class="line">test_model = model.transform(births_test)</span><br><span class="line">test_model.take(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>评估模型性能</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pyspark.ml.evaluation <span class="keyword">as</span> ev</span><br><span class="line"></span><br><span class="line">evaluator = ev.BinaryClassificationEvaluator(</span><br><span class="line">    rawPredictionCol=<span class="string">'probability'</span>, </span><br><span class="line">    labelCol=<span class="string">'INFANT_ALIVE_AT_REPORT'</span>)</span><br><span class="line"></span><br><span class="line">print(evaluator.evaluate(test_model, </span><br><span class="line">     &#123;evaluator.metricName: <span class="string">'areaUnderROC'</span>&#125;))</span><br><span class="line">print(evaluator.evaluate(test_model, &#123;evaluator.metricName: <span class="string">'areaUnderPR'</span>&#125;))</span><br></pre></td></tr></table></figure>
<p>保存/加载模型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pipelinePath = <span class="string">'./infant_oneHotEncoder_Logistic_Pipeline'</span></span><br><span class="line">pipeline.write().overwrite().save(pipelinePath)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pyspark.ml <span class="keyword">import</span> PipelineModel</span><br><span class="line"></span><br><span class="line">modelPath = <span class="string">'./infant_oneHotEncoder_Logistic_PipelineModel'</span></span><br><span class="line">model.write().overwrite().save(modelPath)</span><br><span class="line"></span><br><span class="line">loadedPipelineModel = PipelineModel.load(modelPath)</span><br><span class="line">test_loadedModel = loadedPipelineModel.transform(births_test)</span><br></pre></td></tr></table></figure>
<p>调（lian）参（dan）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pyspark.ml.tuning <span class="keyword">as</span> tune</span><br><span class="line"></span><br><span class="line">logistic = cl.LogisticRegression(</span><br><span class="line">    labelCol=<span class="string">'INFANT_ALIVE_AT_REPORT'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 网格搜索</span></span><br><span class="line">grid = tune.ParamGridBuilder() \</span><br><span class="line">    .addGrid(logistic.maxIter,  </span><br><span class="line">             [<span class="number">2</span>, <span class="number">10</span>, <span class="number">50</span>]) \</span><br><span class="line">    .addGrid(logistic.regParam, </span><br><span class="line">             [<span class="number">0.01</span>, <span class="number">0.05</span>, <span class="number">0.3</span>]) \</span><br><span class="line">    .build()</span><br><span class="line">    </span><br><span class="line">evaluator = ev.BinaryClassificationEvaluator(</span><br><span class="line">    rawPredictionCol=<span class="string">'probability'</span>, </span><br><span class="line">    labelCol=<span class="string">'INFANT_ALIVE_AT_REPORT'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 交叉验证</span></span><br><span class="line">cv = tune.CrossValidator(</span><br><span class="line">    estimator=logistic, </span><br><span class="line">    estimatorParamMaps=grid, </span><br><span class="line">    evaluator=evaluator</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">pipeline = Pipeline(stages=[encoder,featuresCreator])</span><br><span class="line">data_transformer = pipeline.fit(births_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># cvModel 是寻找到的最佳模型</span></span><br><span class="line">cvModel = cv.fit(data_transformer.transform(births_train))</span><br><span class="line"></span><br><span class="line">data_train = data_transformer \</span><br><span class="line">    .transform(births_test)</span><br><span class="line">results = cvModel.transform(data_train)</span><br><span class="line"></span><br><span class="line">print(evaluator.evaluate(results, </span><br><span class="line">     &#123;evaluator.metricName: <span class="string">'areaUnderROC'</span>&#125;))</span><br><span class="line">print(evaluator.evaluate(results, </span><br><span class="line">     &#123;evaluator.metricName: <span class="string">'areaUnderPR'</span>&#125;))</span><br></pre></td></tr></table></figure>
<p>获取最佳模型的参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">results = [</span><br><span class="line">    (</span><br><span class="line">        [</span><br><span class="line">            &#123;key.name: paramValue&#125; </span><br><span class="line">            <span class="keyword">for</span> key, paramValue </span><br><span class="line">            <span class="keyword">in</span> zip(</span><br><span class="line">                params.keys(), </span><br><span class="line">                params.values())</span><br><span class="line">        ], metric</span><br><span class="line">    ) </span><br><span class="line">    <span class="keyword">for</span> params, metric </span><br><span class="line">    <span class="keyword">in</span> zip(</span><br><span class="line">        cvModel.getEstimatorParamMaps(), </span><br><span class="line">        cvModel.avgMetrics</span><br><span class="line">    )</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">sorted(results, </span><br><span class="line">       key=<span class="keyword">lambda</span> el: el[<span class="number">1</span>], </span><br><span class="line">       reverse=<span class="literal">True</span>)[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h3 id="spark-与-深度学习"><a class="markdownIt-Anchor" href="#spark-与-深度学习"></a> Spark 与 深度学习</h3>
<p>// TODO</p>
]]></content>
      <categories>
        <category>BigData</category>
      </categories>
      <tags>
        <tag>pyspark</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 环境变量</title>
    <url>/2019/06/linux-env/</url>
    <content><![CDATA[<p>Linux 系统包含两类环境变量：系统环境变量和用户环境变量。</p>
<p>系统环境变量对所有系统用户都有效，用户环境变量仅仅对当前的用户有效。</p>
<p>1、修改用户环境变量<br />
用户环境变量通常被存储在下面的文件中：</p>
<ul>
<li>
<p>~/.profile</p>
</li>
<li>
<p>~/.bash_profile 或者 ~./bash_login</p>
</li>
<li>
<p>~/.bashrc</p>
</li>
</ul>
<p>上述文件在 Ubuntu 10.0 以前版本不推荐使用。</p>
<a id="more"></a>
<p>2、系统环境变量<br />
系统环境变量一般保存在下面的文件中：</p>
<ul>
<li>
<p>/etc/environment</p>
</li>
<li>
<p>/etc/profile</p>
</li>
<li>
<p>/etc/bash.bashrc</p>
</li>
</ul>
<p>其中 environment 文件直接写变量 <code>$VAR='ABC'</code>；profile 文件是在登录时被执行，要写成命令的形式，如<code>export $VAR='ABC'</code>；bashrc 是当 bash 被打开的时候被读取执行</p>
<h3 id="etcprofile-不生效问题"><a class="markdownIt-Anchor" href="#etcprofile-不生效问题"></a> /etc/profile 不生效问题</h3>
<p>发现启动后/etc/profile 不生效，需要手动<code>source /etc/profile</code>.</p>
<p>首先查到可能是<code>login shell</code>和<code>non-login shell</code>的区别：<br />
简单来说需要输入密码登陆的是<code>login shell</code>如通过 ssh 访问，在图形桌面中直接打开的终端为<code>non-login</code>.</p>
<p>login shell(bash) 在登入时，会读取的配置文件：</p>
<ol>
<li>/etc/profile</li>
<li>~/.bash_profile 或~/.bash_login 或 ~/.profile （就按照这个顺序）</li>
<li>~/.bashrc （通常是写在前面两个配置文件中）</li>
</ol>
<p>第二步之所以有三个文件，是因为不同的 shell 有可能命名不同，只会按顺序读取其中的一个。</p>
<p>non-login shell(bash) 在登入时，只会读取 ~/.bashrc</p>
<p>参考：</p>
<ol>
<li><a href="https://blog.csdn.net/linuxnews/article/details/52579186" target="_blank" rel="noopener">https://blog.csdn.net/linuxnews/article/details/52579186</a></li>
<li>(<a href="http://feihu.me/blog/2014/env-problem-when-ssh-executing-command-on-remote/" target="_blank" rel="noopener">http://feihu.me/blog/2014/env-problem-when-ssh-executing-command-on-remote/</a>)</li>
</ol>
<h4 id="使用-ssh-连接还是不生效"><a class="markdownIt-Anchor" href="#使用-ssh-连接还是不生效"></a> 使用 ssh 连接还是不生效</h4>
<p>最后发现是因为使用的 zsh 并不会读取<code>/etc/profile</code>, 而是使用<code>/etc/zsh/</code>下面<code>的 zshenv、zprofile、zshrc、zlogin</code>文件，并以这个顺序进行加载。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>ETL 概念解析</title>
    <url>/2019/03/ETL-overview/</url>
    <content><![CDATA[<h2 id="实现方法"><a class="markdownIt-Anchor" href="#实现方法"></a> 实现方法</h2>
<p>常见的 ETL 实现方法</p>
<ol>
<li>借助 ETL 工具（如 Oracle 的 OWB、Informatic、Kettle 等）实现</li>
<li>SQL 方式实现</li>
<li>ETL 工具和 SQL 相结合。</li>
</ol>
<p>借助工具可以快速的建立起 ETL 工程，屏蔽了复杂的编码任务，提高了速度，降低了难度，但是缺少灵活性。SQL 的方法优点是灵活，提高 ETL 运行效率，但是编码复杂，对技术要求比较高。往往需要结合使用。</p>
<a id="more"></a>
<h2 id="抽取"><a class="markdownIt-Anchor" href="#抽取"></a> 抽取</h2>
<p>数据抽取主要是针对各个业务系统及不同数据源的分散数据，充分理解数据定义后，规划需要的数据源及数据定义，制定可操作的数据源抽取（增量抽取）方案。</p>
<p>数据抽取过程中需要关注的要点：</p>
<ul>
<li>确认每个数据源的系统和数据结构。</li>
<li>定义抽取方式，是人工抽取还是基于工具抽取。</li>
<li>对于每个数据源，确定数据抽取的频度，是每天、每星期、还是每个季度等。</li>
<li>决定抽取任务中各项任务的先后顺序，某项工作是否必须等到前面的工作成功完成后，才可以开始。</li>
<li>决定如何处理无法抽取的输入记录。</li>
</ul>
<h3 id="增量抽取"><a class="markdownIt-Anchor" href="#增量抽取"></a> 增量抽取</h3>
<h4 id="1-触发器方式"><a class="markdownIt-Anchor" href="#1-触发器方式"></a> 1、触发器方式</h4>
<p>触发器方式是普遍采取的一种增量抽取机制。该方式是根据抽取要求，在要被抽取的源表上建立插入、修改、删除 3 个触发器，每当源表中的数据发生变化，就被相应的触发器将变化的数据写入一个增量日志表，ETL 的增量抽取则是从增量日志表中而不是直接在源表中抽取数据，同时增量日志表中抽取过的数据要及时被标记或删除。为了简单起见，增量日志表一般不存储增量数据的所有字段信息，而只是存储源表名称、更新的关键字值和更新操作类型（KNSEN、UPDATE 或 DELETE），ETL 增量抽取进程首先根据源表名称和更新的关键字值，从源表中提取对应的完整记录，再根据更新操作类型，对目标表进行相应的处理。</p>
<p>例如，对于源表为 ORACLE 类型的数据库，采用触发器方式进行增量数据捕获的过程如下：</p>
<p>SQL 代码</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 1. 创建增量日志表 DML_LOG：</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> DML_LOG( <span class="comment">--新建 DML_LOG 表记录增量数据变化</span></span><br><span class="line"> <span class="keyword">ID</span> <span class="built_in">NUMBER</span> PRIMARY <span class="keyword">KEY</span>, <span class="comment">--自增主键</span></span><br><span class="line"> TABLE_NAME <span class="built_in">VARCHAR2</span>(<span class="number">200</span>), <span class="comment">--源表名称</span></span><br><span class="line"> RECORD_ID <span class="built_in">NUMBER</span>, <span class="comment">--源表增量记录的主键值</span></span><br><span class="line"> DML_TYPE <span class="built_in">CHAR</span>(<span class="number">1</span>), <span class="comment">--增量类型，I 表示新增：U 表示更新；D 表示删除</span></span><br><span class="line"> EXECUTE_DATE <span class="built_in">DATE</span> <span class="comment">--发生时间</span></span><br><span class="line"> )；</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 为 DML_LOG 创建一个序列 SEQ_DML_LOG 上，以便触发器写增量日志表时生成 ID 值。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3. 针对要监听的每一张表，创建一个触发器，例如对表 TEST 创建触发器如下：</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">TRIGGER</span> T <span class="keyword">BEFORE</span> <span class="keyword">INSERT</span> <span class="keyword">OR</span> <span class="keyword">UPDATE</span></span><br><span class="line"> <span class="keyword">OR</span> <span class="keyword">DELETE</span> <span class="keyword">ON</span> T <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span></span><br><span class="line"><span class="keyword">DECLARE</span> L_DML_TYPE <span class="built_in">VARCHAR2</span>(<span class="number">1</span>)；</span><br><span class="line"> <span class="keyword">BEGIN</span></span><br><span class="line"> <span class="keyword">IF</span> INSERTING <span class="keyword">THEN</span> L_DML_TYPE：=<span class="string">'I'</span>；<span class="comment">-- 源表有新增数据</span></span><br><span class="line"> <span class="keyword">ELSIF</span> UPDATING <span class="keyword">THEN</span> L_DML_TYPE：=<span class="string">'U'</span>； <span class="comment">-- 源表有更新数据</span></span><br><span class="line"> <span class="keyword">ELSIF</span> DELETING <span class="keyword">THEN</span> L_DML_TYPE：=<span class="string">'D'</span>； <span class="comment">-- 源表有删除数据</span></span><br><span class="line"> ENDIF；</span><br><span class="line"><span class="keyword">IF</span> DELETING <span class="keyword">THEN</span> <span class="comment">-- 源表有删除数据 </span></span><br><span class="line"> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> DML_LOG(<span class="keyword">ID</span>，TABLE_NAME，RECORD_ID，EXECUTE_DATE，DML_TYPE)</span><br><span class="line"> <span class="keyword">VALUES</span>(SEQ_DML_LOG.NEXTVAL, <span class="string">'TEST'</span>, OLD.ID, <span class="keyword">SYSDATE</span>, L_DML_TYPE)；</span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line"> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> DML_LOG(<span class="keyword">ID</span>，TABLE_NAME，RECORD_ID，EXECUTE_DATE，DML_TYPE)</span><br><span class="line"> <span class="keyword">VALUES</span>(SEQ_DML_LOG.NEXTVAL, <span class="string">'TEST'</span>, NEW.ID, <span class="keyword">SYSDATE</span>, L_DML_TYPE)；</span><br><span class="line"> ENDIF；</span><br><span class="line"><span class="keyword">END</span>；</span><br></pre></td></tr></table></figure>
<p>这样，对表 T 的所有 DML 操作就记录在增量日志表 DML_LOG 中，注意增量日志表中并没有完全记录增量数据本身，只是记录了增量数据的来源。进行增量 ETL 时，只需要根据增量日志表中的记录情况，反查源表得到真正的增量数据。</p>
<p>优点：数据抽取的性能较高。</p>
<p>缺点：要求业务表建立触发器，对业务系统有影响，需要对用户数据库进行修改，不能对多表和视图进行操作，如果目标表发生错误会造成级联事务失败，这在生产系统无法忍受，另外一个缺点是如果触发器运行过程中产生问题，有时需要重新加载整个表来恢复加载作业的运行。这类方法适用于一对一且业务逻辑不复杂的表的增量更新。</p>
<h4 id="2-时间戳方式"><a class="markdownIt-Anchor" href="#2-时间戳方式"></a> 2、时间戳方式</h4>
<p>实现原理是指增量抽取时，抽取进程通过比较系统时间或者源表上次抽取时的最大时间戳与抽取源表的时间戳字段的值来决定抽取哪些数据。这种方式需要在源表上增加一个时间戳字段，系统中更新修改表数据的时候，同时修改时间戳字段的值。</p>
<p>采用时间戳进行增量更新时需要源表有相应的时间戳字段，所以对于没有时间戳的源表需要进行相应业务需要改造，增加必要的时间戳字段。</p>
<p>有的数据库（例如 SQL SERVER）的时间戳支持自动更新，即表的其它字段的数据发生改变时，时间戳字段的值会被自动更新为记录改变的时刻。在这种情下，进行 ETL 实施时就只需要在源表加上时间戳字段就可以了。</p>
<p>对于不支持时间戳自动更新的数据库，这就要求业务系统在更新业务数据时，通过编程的方式手工更新时间戳字段。使用时间戳方式可以正常捕获源表的插入和更新操作，但对于删除操作则无能为力，需要结合其它机制才能完成。</p>
<p>时间戳方式通常需要一个日志表对 ETL 的更新操作进行记录，将最后一次成功更新的时间戳记录下来，以方便进行时间筛选。每次进行 ETL 增量更新时，读取日志表里的上次更新时间戳记录，作为本次增量更新的时间窗口起始时间。</p>
<p>优点：</p>
<ul>
<li>实现逻辑简单，可以大批量更新数据。不仅可以对一张源表进行数据捕获，也可以对多张源表的增量数据进行捕获。</li>
</ul>
<p>缺点：</p>
<ul>
<li>使用时间戳方式可以正常捕获源表的插入和更新操作，但对于删除操作则无能为力，需要结合其它机制才能完成。这时可以设计一张和源表相同的数据表记录源表中删除的数据，同时记录删除时的时间戳，在对目标表更新时同时读取这张表的记录，进行删除操作。或者在目标表通过打标记的方式（update active_flag=1）进行逻辑删除。</li>
<li>应用起来有部分局限性。即源表都需要有时间戳字段。如果部分源表（或参考表）无时间戳字段，且源表有部分字段更新时（常见于维度表的定义更新），则面临历史数据的更新问题。这时一般需要采用 SQL 语句或者下文介绍的全表对比方式进行历史数据更新。或者调整时间戳范围，做全表数据的刷新。这种情况需要对目标表的实时性要求不高，可以在系统空闲时进行处理。</li>
</ul>
<h4 id="3-全表删除插入方式"><a class="markdownIt-Anchor" href="#3-全表删除插入方式"></a> 3、全表删除插入方式</h4>
<p>全表删除插入方式是指每次抽取前先删除目标表数据，抽取时全新加载数据。该方式实际上将增量抽取等同于全量抽取。对于数据量不大，全量抽取的时间代价小于执行增量抽取的算法和条件代价时，可以采用该方式。</p>
<h4 id="4-全表比对方式"><a class="markdownIt-Anchor" href="#4-全表比对方式"></a> 4、全表比对方式</h4>
<p>全表比对即在增量抽取时，ETL 进程逐条比较源表和目标表的记录，将新增和修改的记录读取出来。优化之后的全部比对方式是采用 MD5 校验码，需要事先为要抽取的表建立一个结构类似的临时表，该临时表记录源表的主键值以及根据源表所有字段的数据计算出来的 MD5 校验码，每次进行数据抽取时，对源表和 MD5 临时表进行 MD5 校验码的比对，</p>
<ul>
<li>如有不同，进行 UPDATE 操作</li>
<li>如目标表没有存在该主键值，表示该记录还没有，则进行 INSERT 操作。</li>
<li>对在源表中已不存在而目标表仍保留的主键值，执行 DELETE 操作。</li>
</ul>
<p>一般全表比对更新可以采用一些常用的 ETL 工具协助进行。</p>
<p>优点：</p>
<ul>
<li>适用于涉及多张源表的抽取与转换，业务逻辑复杂的增量更新。</li>
<li>适用于源表无时间戳字段，无法采用时间戳方式进行增量更新。</li>
</ul>
<p>缺点：</p>
<ul>
<li>对于大数据量数据表，效率不高。</li>
</ul>
<h4 id="5-日志表方式"><a class="markdownIt-Anchor" href="#5-日志表方式"></a> 5、日志表方式</h4>
<p>对于建立了业务系统的生产数据库，可以在数据库中创建业务日志表，当特定需要监控的业务数据发生变化时，由相应的业务系统程序模块来更新维护日志表内容。增量抽取时，</p>
<p>通过读日志表数据决定加载哪些数据及如何加载。日志表的维护需要由业务系统程序用代码来完成。</p>
<h4 id="6-系统日志分析方式"><a class="markdownIt-Anchor" href="#6-系统日志分析方式"></a> 6、系统日志分析方式</h4>
<p>该方式通过分析数据库自身的日志来判断变化的数据。关系型数据库系统都会将所有的 DML 操作存储在日志文件中，以实现数据库的备份和还原功能。ETL 增量抽取进程通过对数据库的日志进行分析，提取对相关源表在特定时间后发生的 DML 操作信息，就可以得知自上次抽取时刻以来该表的数据变化情况，从而指导增量抽取动作。有些数据库系统提供了访问日志的专用的程序包（例如 ORACLE 的 LOGMINDER），使数据库日志的分析工作得到大大简化。</p>
<h4 id="7-特定数据库方式oracle"><a class="markdownIt-Anchor" href="#7-特定数据库方式oracle"></a> 7、特定数据库方式（ORACLE）</h4>
<p>以下介绍常见的针对特有数据库系统的增景抽取方式。</p>
<ol>
<li>ORACLE 改变数据捕获（CHANGEDDATACAPTURE，CDC）方式：</li>
</ol>
<p>ORACLECDC 特性是在 ORAELE9I 数据库中引入的。CDC 能够帮助识别从上次抽取之后发生变化的数据。利用 CDC，在对源表进行 INSERT、UPCLATE 或 DELETE 等操作的同时就可以提取数据，并且变化的数据被保存在数据库的变化表中。这样就可以捕获发生变化的数据，然后利用数据库视图以一种可控的方式提供给 ETL 抽取进程，作为增量抽取的依据。CDC 方式对源表数据变化情况的捕获有两种方式：同步 CDC 和异步 CDC。同步 CDC 使用源数据库触发器来捕获变更的数据。这种方式是实时的，没有任何延迟。当 DML 操作提交后，变更表中就产生了变更数据。异步 CDC 使用数据库重做日志（REDOLOG）文件，在源数据库发生变更以后，才进行数据捕获。</p>
<ol start="2">
<li>ORACLE 闪回查询方式</li>
</ol>
<p>ORACLE9I 以上版本的数据库系统提供了闪回查询机制，允许用户查询过去某个时刻的数据库状态。这样，抽取进程可以将源数据库的当前状态和上次抽取时刻的状态进行对比，快速得出源表数据记录的变化情况。</p>
<h4 id="8-比较和分析"><a class="markdownIt-Anchor" href="#8-比较和分析"></a> 8、比较和分析</h4>
<p>可见，ETL 在进行增量抽取操作时，有以上各种机制可以选择。现从兼容性、完备性、性能和侵入性 3 个方面对这些机制的优劣进行比较分析。</p>
<ul>
<li>兼容性</li>
</ul>
<p>数据抽取需要面对的源系统，并不一定都是关系型数据库系统。某个 ETL 过程可能需要从若干年前的遗留系统中抽取 EXCEL 或者 CSV 文本数据。这时，所有基于关系型数据库产品的增量机制都无法工作，时间戳方式和全表比对方式可能有一定的利用价值，在最坏的情况下，只有放弃增量抽取的思路，转而采用全表删除插入方式。</p>
<ul>
<li>完备性</li>
</ul>
<p>时间戳方式不能捕获 DELETE 操作，需要结合其它方式一起使用。</p>
<ul>
<li>性能</li>
</ul>
<p>增量抽取的性能因素表现在两个方面，一是抽取进程本身的性能，二是对源系统性能的负面影响。</p>
<p>触发器方式、日志表方式以及系统日志分析方式由于不需要在抽取过程中执行比对步骤，所以增量抽取的性能较佳。全表比对方式需要经过复杂的比对过程才能识别出更改的记录，抽取性能最差。</p>
<p>在对源系统的性能影响方面，触发器方式由于是直接在源系统业务表上建立触发器，同时写临时表，对于频繁操作的业务系统可能会有一定的性能损失，尤其是当业务表上执行批量操作时，行级触发器将会对性能产生严重的影响；同步 CDC 方式内部采用触发器的方式实现，也同样存在性能影响的问题；全表比对方式和日志表方式对数据源系统数据库的性能没有任何影响，只是它们需要业务系统进行额外的运算和数据库操作，会有少许的时间损耗；时间戳方式、系统日志分析方式以及基于系统日志分析的方式（异步 CDC 和闪回查询）对数据库性能的影响也是非常小的。</p>
<ul>
<li>侵入性</li>
</ul>
<p>指业务系统是否要为实现增抽取机制做功能修改和额外操作，在这一点上，时间戳方式值得特别关注该方式除了要修改数据源系统表结构外，对于不支持时间戳字段自动更新的关系型数据库产品，还必须要修改业务系统的功能，让它在源表 T 执行每次操作时都要显式的更新表的时间戳字段，这在 ETL 实施过程中必须得到数据源系统高度的配合才能达到，并且在多数情况下这种要求在数据源系统看来是比较“过分”的，这也是时间戳方式无法得到广泛运用的主要原因。另外，触发器方式需要在源表上建立触发器，这种在某些场合中也遭到拒绝。还有一些需要建立临时表的方式，例如全表比对和日志表方式。可能因为开放给 ETL 进程的数据库权限的限制而无法实施。同样的情况也可能发生在基于系统日志分析的方式上，因为大多数的数据库产品只允许特定组的用户甚至只有 DBA 才能执行日志分析。闪回查询在侵入性方面的影响是最小的。</p>
<table>
<thead>
<tr>
<th>增量机制</th>
<th>兼容性</th>
<th>完备性</th>
<th>抽取性能</th>
<th>对源系统性能影响</th>
<th>对源系统侵入性</th>
<th>实现难度</th>
</tr>
</thead>
<tbody>
<tr>
<td>触发器方式</td>
<td>关系型数据库</td>
<td>高</td>
<td>优</td>
<td>大</td>
<td>一般</td>
<td>较容易</td>
</tr>
<tr>
<td>时间戳方式</td>
<td>关系型数据库，具有“字段”结构的其它数据格式</td>
<td>低</td>
<td>较优</td>
<td>很小</td>
<td>大</td>
<td>较容易</td>
</tr>
<tr>
<td>全表删除插入方式</td>
<td>任何数据格式</td>
<td>高</td>
<td>极差</td>
<td>无</td>
<td>无</td>
<td>容易</td>
</tr>
<tr>
<td>全表比对方式</td>
<td>关系型数据库、文本格式</td>
<td>高</td>
<td>差</td>
<td>小</td>
<td>一般</td>
<td>一般</td>
</tr>
<tr>
<td>日志表方式</td>
<td>关系型数据库</td>
<td>高</td>
<td>优</td>
<td>小</td>
<td>较大</td>
<td>较容易</td>
</tr>
<tr>
<td>系统日志分析方式</td>
<td>关系型数据库</td>
<td>高</td>
<td>优</td>
<td>很小</td>
<td>较大</td>
<td>难</td>
</tr>
<tr>
<td>同步 CDC 方式</td>
<td>Oracle 数据库 9i 以上</td>
<td>高</td>
<td>优</td>
<td>大</td>
<td>一般</td>
<td>较难</td>
</tr>
<tr>
<td>异步 CDC 方式</td>
<td>Oracle 数据库 9i 以上</td>
<td>高</td>
<td>优</td>
<td>很小</td>
<td>一般</td>
<td>较难</td>
</tr>
<tr>
<td>闪回查询方式</td>
<td>Oracle 数据库 9i 以上</td>
<td>高</td>
<td>较优</td>
<td>很小</td>
<td>无</td>
<td>较容易</td>
</tr>
</tbody>
</table>
<h2 id="清洗"><a class="markdownIt-Anchor" href="#清洗"></a> 清洗</h2>
<p>一般情况下，数据仓库分为 ODS、DW 两部分。通常的做法是从业务系统到 ODS 做清洗，将脏数据和不完整数据过滤掉，在从 ODS 到 DW 的过程中转换，进行一些业务规则的计算和聚合。</p>
<h3 id="1-数据清洗"><a class="markdownIt-Anchor" href="#1-数据清洗"></a> 1、数据清洗</h3>
<p>数据清洗的任务是过滤那些不符合要求的数据，将过滤的结果交给业务主管部门，确认是否过滤掉还是由业务单位修正之后再进行抽取。不符合要求的数据主要是有不完整的数据、错误的数据、重复的数据三大类。</p>
<ul>
<li>
<p>不完整的数据：这一类数据主要是一些应该有的信息缺失。对于这一类数据过滤出来，按缺失的内容分别写入不同 Excel 文件向客户提交，要求在规定的时间内补全。补全后才写入数据仓库。</p>
</li>
<li>
<p>错误的数据：这一类错误产生的原因是业务系统不够健全，在接收输入后没有进行判断直接写入后台数据库造成的，比如数值数据输成全角数字字符、字符串数据后面有一个回车操作、日期格式不正确、日期越界等。这一类数据也要分类，对于类似于全角字符、数据前后有不可见字符的问题，只能通过写 SQL 语句的方式找出来，然后要求客户在业务系统修正之后抽取。日期格式不正确的或者是日期越界的这一类错误会导致 ETL 运行失败，这一类错误需要去业务系统数据库用 SQL 的方式挑出来，交给业务主管部门要求限期修正，修正之后再抽取。</p>
</li>
<li>
<p>重复的数据：对于这一类数据——特别是维表中会出现这种情况——将重复数据记录的所有字段导出来，让客户确认并整理。</p>
</li>
</ul>
<p>数据清洗是一个反复的过程，不可能在几天内完成，只有不断的发现问题，解决问题。对于是否过滤，是否修正一般要求客户确认，对于过滤掉的数据，写入 Excel 文件或者将过滤数据写入数据表，在 ETL 开发的初期可以每天向业务单位发送过滤数据的邮件，促使他们尽快地修正错误，同时也可以做为将来验证数据的依据。数据清洗需要注意的是不要将有用的数据过滤掉，对于每个过滤规则认真进行验证，并要用户确认。</p>
<h3 id="2-数据转换"><a class="markdownIt-Anchor" href="#2-数据转换"></a> 2、数据转换</h3>
<p>数据转换的任务主要进行不一致的数据转换、数据粒度的转换，以及一些商务规则的计算。</p>
<ul>
<li>
<p>不一致数据转换：这个过程是一个整合的过程，将不同业务系统的相同类型的数据统一，比如同一个供应商在结算系统的编码是 XX0001, 而在 CRM 中编码是 YY0001，这样在抽取过来之后统一转换成一个编码。</p>
</li>
<li>
<p>数据粒度的转换：业务系统一般存储非常明细的数据，而数据仓库中数据是用来分析的，不需要非常明细的数据。一般情况下，会将业务系统数据按照数据仓库粒度进行聚合。</p>
</li>
<li>
<p>商务规则的计算：不同的企业有不同的业务规则、不同的数据指标，这些指标有的时候不是简单的加加减减就能完成，这个时候需要在 ETL 中将这些数据指标计算好了之后存储在数据仓库中，以供分析使用。</p>
</li>
</ul>
<h2 id="etl-日志"><a class="markdownIt-Anchor" href="#etl-日志"></a> ETL 日志</h2>
<p>ETL 日志分为三类。</p>
<ul>
<li>执行过程日志：这一部分日志是在 ETL 执行过程中每执行一步的记录，记录每次运行每一步骤的起始时间，影响了多少行数据，流水账形式。</li>
<li>错误日志：当某个模块出错的时候写错误日志，记录每次出错的时间、出错的模块以及出错的信息等。</li>
<li>总体日志：只记录 ETL 开始时间、结束时间是否成功信息。如果使用 ETL 工具，ETL 工具会自动产生一些日志，这一类日志也可以作为 ETL 日志的一部分。记录日志的目的是随时可以知道 ETL 运行情况，如果出错了，可以知道哪里出错。</li>
</ul>
<p>参考文章:</p>
<ul>
<li><a href="https:--blog.csdn.net/hzp666/article/details/70139867" target="_blank" rel="noopener">BI的ETL中怎么做增量处理</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/data/library/techarticle/dm-1508-etlsataloadmechanism/index.html" target="_blank" rel="noopener">ETL 数据加载机制概述</a></li>
</ul>
]]></content>
      <categories>
        <category>BigData</category>
      </categories>
      <tags>
        <tag>ETL</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 杂记</title>
    <url>/2019/03/Linux-note/</url>
    <content><![CDATA[<p>本文记录 Linux 使用过程中遇到的小问题和解决方法，比较杂。</p>
<p>日常使用<code>Ubuntu 18.04</code>，服务器常用<code>CentOS 7</code>。</p>
<a id="more"></a>
<h2 id="gnome"><a class="markdownIt-Anchor" href="#gnome"></a> Gnome</h2>
<h3 id="菜单管理"><a class="markdownIt-Anchor" href="#菜单管理"></a> 菜单管理</h3>
<p><strong>菜单快捷方式文件路径</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">global: &#x2F;usr&#x2F;share&#x2F;application</span><br><span class="line">local: &#x2F;home&#x2F;vc&#x2F;.local&#x2F;share&#x2F;applications</span><br></pre></td></tr></table></figure>
<p><strong>Menu 中为 App 创建文件夹</strong></p>
<p>方法一：安装插件</p>
<p>方法二：在 Ubuntu Software 中操作，在 install 选项卡中选中多个 app 添加到 folder</p>
<p><a href="https://askubuntu.com/questions/1091972/how-do-i-create-app-folders-in-the-gnome-application-menu" target="_blank" rel="noopener">ref</a></p>
<p><strong>部分 App 在 Menu 中不显示图标</strong></p>
<p>标记文件中有个<code>NotShowIn=GNOME</code>选项，将其注释</p>
<h3 id="dock-启用minimize-on-click"><a class="markdownIt-Anchor" href="#dock-启用minimize-on-click"></a> Dock 启用“Minimize on Click”</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 默认为&#39;previews&#39;</span><br><span class="line">gsettings set org.gnome.shell.extensions.dash-to-dock click-action &#39;minimize&#39;</span><br></pre></td></tr></table></figure>
<h3 id="document-viewer-shortcut"><a class="markdownIt-Anchor" href="#document-viewer-shortcut"></a> document viewer <a href="https://help.gnome.org/users/evince/stable/shortcuts.html.zh_CN" target="_blank" rel="noopener">shortcut</a></h3>
<ul>
<li>文档管理器切换路径输入快捷键<code>ctrl+L</code></li>
<li>在此处打开终端<code>app+E</code></li>
</ul>
<h3 id="gnome-桌面美化"><a class="markdownIt-Anchor" href="#gnome-桌面美化"></a> Gnome 桌面美化</h3>
<p><a href="https://www.cnblogs.com/youxia/p/LinuxDesktop003.html" target="_blank" rel="noopener">针对 Gnome 3 的 Linux 桌面进行美化</a></p>
<h3 id="中文字体"><a class="markdownIt-Anchor" href="#中文字体"></a> 中文字体</h3>
<p>中文字体异常，如‘门’字显示为日文。系统级别的解决方法为，修改系统配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vi &#x2F;etc&#x2F;fonts&#x2F;conf.d&#x2F;64-language-selector-prefer.conf</span><br></pre></td></tr></table></figure>
<p>将<code>&lt;family&gt;Noto Sans CJK CS&lt;/falimy&gt;</code>提到最前面。</p>
<p>Chrome 中可以单独对字体进行设置。</p>
<h3 id="远程连接桌面"><a class="markdownIt-Anchor" href="#远程连接桌面"></a> 远程连接桌面</h3>
<p><a href="http://www.blogjava.net/ivanwan/archive/2012/04/26/376670.html" target="_blank" rel="noopener">Xming</a>: 连不上注意查看 log, 看是不是 server 的访问权限问题，</p>
<h2 id="软件与命令"><a class="markdownIt-Anchor" href="#软件与命令"></a> 软件与命令</h2>
<h3 id="wps"><a class="markdownIt-Anchor" href="#wps"></a> WPS</h3>
<ol>
<li>进入 <a href="http://linux.wps.com/" target="_blank" rel="noopener">WPS 官网</a> 下载最新版安装包
<ul>
<li>可卸载自带 office <code>sudo apt-get remove --purge libreoffice*</code></li>
</ul>
</li>
<li>终端下<code>dpkg</code>安装</li>
<li>若出现系统字体缺失问题可 <a href="https://pan.baidu.com/s/1i5dzB9r" target="_blank" rel="noopener">下载字体库</a> 安装，密码：pwe1</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo unzip wps_symbol_fonts.zip -d &#x2F;usr&#x2F;share&#x2F;fonts&#x2F;wps-office</span><br></pre></td></tr></table></figure>
<h3 id="ufw"><a class="markdownIt-Anchor" href="#ufw"></a> UFW</h3>
<p>LInux 原始的防火墙工具 iptables 由于过于繁琐，所以 ubuntu 系统默认提供了一个基于 iptable 之上的防火墙工具 ufw。</p>
<p>ref:</p>
<ul>
<li><a href="https://wiki.ubuntu.org.cn/UbuntuHelp:UFW" target="_blank" rel="noopener">参考 1</a></li>
<li><a href="https://www.sysgeek.cn/ubuntu-18-04-ufw/" target="_blank" rel="noopener">参考 2</a></li>
</ul>
<h3 id="sudo"><a class="markdownIt-Anchor" href="#sudo"></a> sudo</h3>
<p>sudo cd 命令无法进入权限 700 的目录，要通过 <code>sudo -i/-s</code></p>
<p>类似的 cp 命令也无法正常运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo cp -R &#x2F;var&#x2F;lib&#x2F;docker&#x2F;* &#x2F;home&#x2F;vc&#x2F;Docker&#x2F;lib&#x2F;</span><br><span class="line">cp: cannot stat &#39;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;*&#39;: No such file or directory</span><br></pre></td></tr></table></figure>
<p><a href="https://superuser.com/questions/918333/why-cant-sudo-cp-find-the-files" target="_blank" rel="noopener">参考</a></p>
<p>You can get an interactive shell running as root using any of the following methods (these are the full commands just run as is from an existing shell and they will give you a root shell).</p>
<ul>
<li>sudo -i: Gives you a root prompt with a new shell environment (as if root did a login). Does a cd to root’s home directory as well.</li>
<li>sudo sh or sudo bash: Gives a basic root shell spawned in the environment of the calling user (sanitized by sudo).</li>
<li>sudo -s -H: Gives a shell and resets $HOME, but doesn’t cd to $HOME like sudo -i.</li>
<li>sudo su: Uses the normal su method of becoming root but doesn’t need a root password.</li>
</ul>
<p>Basically I use either sudo -i or sudo -s -H in most cases depending on if I wanted to end up in root’s home directory or not.</p>
<h2 id="存储管理"><a class="markdownIt-Anchor" href="#存储管理"></a> 存储管理</h2>
<h3 id="根目录扩展"><a class="markdownIt-Anchor" href="#根目录扩展"></a> 根目录扩展</h3>
<ol>
<li>查看硬盘使用情况：df -lh</li>
<li>安装 gparted： sudo apt-get install gparted</li>
<li>打开 gparted 后会发现，有许多小钥匙标识无法去掉，也无法进行分区操作。</li>
</ol>
<blockquote>
<p>因为分区已经挂载了，没法再当前系统下进行重新分配空间，所以得准备一个 Ubuntu 启动盘，在 live 系统中进行操作<br />
搜索 gparted 并打开，小钥匙标识还没有消除！依次选中你要操作的两个分区（我的是”/“和&quot;/home&quot;）以及 linux-swap，右键选择** unmount**，即可对其进行改变大小的操作。</p>
</blockquote>
<ol start="4">
<li>从/home 分区中分出 20G，如果这个空闲的 20G 不在根目录&quot;/&quot;的下方，则需要向上调整大小，直到调整到根目录的下方。这时就可以对根目录进行操作，resize 根目录的大小，将空闲的 20G 合并进去。</li>
<li>最后，一定要记得应用到整个系统，即选择菜单栏 &gt;&gt; Edit &gt;&gt; Apply all Operations &gt;&gt; Apply</li>
</ol>
<p>成功！</p>
<p><a href="https://blog.csdn.net/byn12345/article/details/88829984" target="_blank" rel="noopener">参考</a></p>
<h3 id="snap-安装目录迁移"><a class="markdownIt-Anchor" href="#snap-安装目录迁移"></a> snap 安装目录迁移</h3>
<p>参考：<a href="https://askubuntu.com/questions/1029562/move-snap-packages-to-another-location-directory/1029948" target="_blank" rel="noopener">https://askubuntu.com/questions/1029562/move-snap-packages-to-another-location-directory/1029948</a></p>
<h2 id="外设"><a class="markdownIt-Anchor" href="#外设"></a> 外设</h2>
<h3 id="蓝牙耳机连接"><a class="markdownIt-Anchor" href="#蓝牙耳机连接"></a> 蓝牙耳机连接</h3>
<p>配对后无法连接，运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install pulseaudio-module-bluetooth（已安装）</span><br><span class="line"></span><br><span class="line">pactl load-module module-bluetooth-discover（执行后成功连接）</span><br></pre></td></tr></table></figure>
<h3 id="添加添加-25601440-分辨率"><a class="markdownIt-Anchor" href="#添加添加-25601440-分辨率"></a> 添加添加 2560×1440 分辨率</h3>
<p>前段时间购入了戴尔 U2515 2K 显示器，分辨率为 2560×1440, 不过发现在 Ubuntu 中找不到 2560×1440 分辨率设置，最大的只有 2560×1600 分辨率。查了下，通过 xrandr 命令可解决。</p>
<p>1）通过 xrandr 即可查看当前显示器所有分辨率，其中 Virtual1 是是当前显示器名称：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jeff@jeff-virtual-machine:~$ xrandr</span><br><span class="line">Screen 0: minimum 1 x 1, current 2560 x 1440, maximum 16384 x 16384</span><br><span class="line">Virtual1 connected primary 2560x1440+0+0 (normal left inverted right x axis y axis) 0mm x 0mm</span><br><span class="line">   2560x1440     60.00*+</span><br><span class="line">   2560x1600     59.99  </span><br><span class="line">   1920x1440     60.00  </span><br><span class="line">   1856x1392     60.00  </span><br><span class="line">   1792x1344     60.00  </span><br><span class="line">   1920x1200     59.88  </span><br><span class="line">   1600x1200     60.00  </span><br><span class="line">   1680x1050     59.95  </span><br><span class="line">   1400x1050     59.98  </span><br><span class="line">   1280x1024     60.02  </span><br><span class="line">   1440x900      59.89  </span><br><span class="line">   1280x960      60.00  </span><br><span class="line">   1360x768      60.02  </span><br><span class="line">   1280x800      59.81  </span><br><span class="line">   1152x864      75.00  </span><br><span class="line">   1280x768      59.87  </span><br><span class="line">   1024x768      60.00  </span><br><span class="line">   800x600       60.32  </span><br><span class="line">   640x480       59.94</span><br></pre></td></tr></table></figure>
<p>2）接着敲入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cvt 2560 1440</span><br><span class="line"># 2560x1440 59.96 Hz (CVT 3.69M9) hsync: 89.52 kHz; pclk: 312.25 MHz</span><br><span class="line">Modeline &quot;2560x1440_60.00&quot;  312.25  2560 2752 3024 3488  1440 1443 1448 1493 -hsync +vsync</span><br></pre></td></tr></table></figure>
<p>添加我们的 2K 分辨率。</p>
<p>3）在显示器分辨率列表中添加上面得到的分辨率设置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xrandr --newmode &quot;2560x1440_60.00&quot;  312.25  2560 2752 3024 3488  1440 1443 1448 1493 -hsync +vsync</span><br></pre></td></tr></table></figure>
<p>4）添加该模式，其中 Virtual1 是第一步中得到的显示器名称：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xrandr --addmode HDMI-1 &quot;2560x1440_60.00&quot;</span><br></pre></td></tr></table></figure>
<p>最后就可以在分辨率设置中找到该分辨率了，用命令行设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xrandr --output HDMI-1 --mode &quot;2560x1440_60.00&quot;</span><br></pre></td></tr></table></figure>
<p>保持副屏旋转和位置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xrandr --output VGA-1 --rotate left --pos 2560x0</span><br></pre></td></tr></table></figure>
<p>汇总</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cvt 2560 1440</span><br><span class="line">xrandr --newmode &quot;2560x1440_60.00&quot;  312.25  2560 2752 3024 3488  1440 1443 1448 1493 -hsync +vsync</span><br><span class="line">xrandr --addmode HDMI-1 &quot;2560x1440_60.00&quot;</span><br><span class="line">xrandr --output HDMI-1 --mode &quot;2560x1440_60.00&quot;</span><br><span class="line">xrandr --output VGA-1 --rotate left --pos 2560x0</span><br></pre></td></tr></table></figure>
<h3 id="多屏管理"><a class="markdownIt-Anchor" href="#多屏管理"></a> 多屏管理</h3>
<p><a href="https://wiki.archlinux.org/index.php/multihead" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/multihead</a></p>
<p>psychtoolbox 里有一些 po</p>
<h3 id="使用-windows-共享打印机"><a class="markdownIt-Anchor" href="#使用-windows-共享打印机"></a> 使用 windows 共享打印机</h3>
<ul>
<li>安装 samba</li>
<li>在 <code>设置/设备/打印机</code> 中添加</li>
</ul>
<p><a href="https://blog.csdn.net/xindablack/article/details/95182327" target="_blank" rel="noopener">https://blog.csdn.net/xindablack/article/details/95182327</a></p>
<h2 id="网络"><a class="markdownIt-Anchor" href="#网络"></a> 网络</h2>
<h3 id="dns"><a class="markdownIt-Anchor" href="#dns"></a> DNS</h3>
<p>ubuntu 18.04 的 DNS 似乎是由 service systemd-resolved 控制，重启这个服务以后，/etc/resolv.conf 会被重置</p>
<p>重启 systemd 解析服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl is-active systemd-resolved.service</span><br><span class="line">sudo systemd-resolve --flush-caches</span><br></pre></td></tr></table></figure>
<p>重启 DNSMasq 缓存服务，Dnsmasq 是轻量级的 DHCP 和 DNS 缓存名称服务器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart dnsmasq.service</span><br><span class="line">sudo service dnsmasq restart</span><br></pre></td></tr></table></figure>
<h3 id="ubuntu-zjuvpn"><a class="markdownIt-Anchor" href="#ubuntu-zjuvpn"></a> ubuntu zjuvpn</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">default dev ppp0 </span><br><span class="line">default via 10.12.45.1 dev enp3s0 proto static metric 20100 </span><br><span class="line">10.0.0.0&#x2F;8 via 10.12.45.1 dev enp3s0 </span><br><span class="line">10.5.1.0&#x2F;24 via 10.12.45.1 dev enp3s0 </span><br><span class="line">10.10.0.0&#x2F;24 via 10.12.45.1 dev enp3s0 </span><br><span class="line">10.12.45.0&#x2F;24 dev enp3s0 proto kernel scope link src 10.12.45.78 metric 100 </span><br><span class="line">58.196.192.0&#x2F;19 via 10.12.45.1 dev enp3s0 </span><br><span class="line">58.196.224.0&#x2F;20 via 10.12.45.1 dev enp3s0 </span><br><span class="line">58.200.100.0&#x2F;24 via 10.12.45.1 dev enp3s0 </span><br><span class="line">169.254.0.0&#x2F;16 dev enp3s0 scope link metric 1000 </span><br><span class="line">210.32.0.0&#x2F;20 via 10.12.45.1 dev enp3s0 </span><br><span class="line">210.32.128.0&#x2F;19 via 10.12.45.1 dev enp3s0 </span><br><span class="line">210.32.160.0&#x2F;21 via 10.12.45.1 dev enp3s0 </span><br><span class="line">210.32.168.0&#x2F;22 via 10.12.45.1 dev enp3s0 </span><br><span class="line">210.32.172.0&#x2F;23 via 10.12.45.1 dev enp3s0 </span><br><span class="line">210.32.176.0&#x2F;20 via 10.12.45.1 dev enp3s0 </span><br><span class="line">222.205.0.0&#x2F;17 via 10.12.45.1 dev enp3s0</span><br></pre></td></tr></table></figure>
<p>10.5.1.0/24 via 10.12.45.1 dev enp3s0</p>
<p>直接改 lns 地址没法联网，改完路由表可以联网但是只能下载不能上传，待续。…</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IPv4 路由表</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">活动路由：</span><br><span class="line">网络目标        网络掩码          网关       接口   跃点数</span><br><span class="line">          0.0.0.0          0.0.0.0       10.12.45.1      10.12.45.78   4506</span><br><span class="line">          0.0.0.0          0.0.0.0            在链路上    222.205.29.215     26</span><br><span class="line">         10.0.0.0        255.0.0.0       10.12.45.1      10.12.45.78   4251</span><br><span class="line">        10.0.2.72  255.255.255.255       10.12.45.1      10.12.45.78   4251</span><br><span class="line">       10.12.45.0    255.255.255.0            在链路上       10.12.45.78   4506</span><br><span class="line">      10.12.45.78  255.255.255.255            在链路上       10.12.45.78   4506</span><br><span class="line">     10.12.45.255  255.255.255.255            在链路上       10.12.45.78   4506</span><br><span class="line">        127.0.0.0        255.0.0.0            在链路上         127.0.0.1   4556</span><br><span class="line">        127.0.0.1  255.255.255.255            在链路上         127.0.0.1   4556</span><br><span class="line">  127.255.255.255  255.255.255.255            在链路上         127.0.0.1   4556</span><br><span class="line">       210.32.0.0    255.255.240.0       10.12.45.1      10.12.45.78   4251</span><br><span class="line">     210.32.128.0    255.255.192.0       10.12.45.1      10.12.45.78   4251</span><br><span class="line">      222.205.0.0    255.255.128.0       10.12.45.1      10.12.45.78   4251</span><br><span class="line">   222.205.29.215  255.255.255.255            在链路上    222.205.29.215    281</span><br><span class="line">        224.0.0.0        240.0.0.0            在链路上         127.0.0.1   4556</span><br><span class="line">        224.0.0.0        240.0.0.0            在链路上       10.12.45.78   4506</span><br><span class="line">        224.0.0.0        240.0.0.0            在链路上    222.205.29.215     26</span><br><span class="line">  255.255.255.255  255.255.255.255            在链路上         127.0.0.1   4556</span><br><span class="line">  255.255.255.255  255.255.255.255            在链路上       10.12.45.78   4506</span><br><span class="line">  255.255.255.255  255.255.255.255            在链路上    222.205.29.215    281</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>
<h2 id="deepin-wine"><a class="markdownIt-Anchor" href="#deepin-wine"></a> deepin wine</h2>
<p>为了在 Linux 下使用 QQ 和微信，安装 deepin 魔改过的 wine</p>
<h3 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h3>
<p>deepin wine 的安装参照 <a href="https://github.com/wszqkzqk/deepin-wine-ubuntu" target="_blank" rel="noopener">deepin-wine-ubuntu</a> 和 <a href="https://github.com/zq1997/deepin-wine" target="_blank" rel="noopener">deepin-wine</a>l 两个就行。实践中花了很多时间解决依赖问题是因为上一条提到的<code>proposed</code>仓库的问题，导致报了很多依赖问题。</p>
<h3 id="中文乱码问题"><a class="markdownIt-Anchor" href="#中文乱码问题"></a> 中文乱码问题</h3>
<p>参考 <a href="https://blog.csdn.net/qq_37624415/article/details/82228572" target="_blank" rel="noopener">1</a> 解决了 TIM 的乱码，但 WeChat 依旧乱码。微信现在主要适用网页版，先不处理了，心累。</p>
<p>其他参考 <a href="http://linux-wiki.cn/wiki/Wine%E7%9A%84%E4%B8%AD%E6%96%87%E6%98%BE%E7%A4%BA%E4%B8%8E%E5%AD%97%E4%BD%93%E8%AE%BE%E7%BD%AE" target="_blank" rel="noopener">2</a>/<a href="https://github.com/wszqkzqk/deepin-wine-ubuntu/issues/136" target="_blank" rel="noopener">3</a>/<a href="https://www.jianshu.com/p/e6f4beff6543" target="_blank" rel="noopener">4</a></p>
<p>界面的中文正常，输入框的中文依然乱码（气泡模式）。</p>
<p>根据参考 <a href="https://github.com/wszqkzqk/deepin-wine-ubuntu/issues/136" target="_blank" rel="noopener">3</a>:</p>
<ul>
<li>step 1</li>
</ul>
<blockquote>
<p><strong># 经验证这步不做也行</strong></p>
<p>系统语言非中文时，中文全显示成方块，需要在<code>/opt/deepinwine/tools/run.sh</code>中将 WINE_CMD 那一行修改为:</p>
<p>WINE_CMD=“LC_ALL=zh_CN.UTF-8 deepin-wine”</p>
</blockquote>
<ul>
<li>step2</li>
</ul>
<blockquote>
<p>#1. 添加字体<br />
cp msyh.ttc ~/.deepinwine/Deepin-WeChat/drive_c/windows/Fonts<br />
#2. 修改系统注册表<br />
edit ~/.deepinwine/Deepin-WeChat/system.reg<br />
#修改以下两行<br />
“MS Shell Dlg”=“msyh”<br />
“MS Shell Dlg 2”=“msyh”</p>
</blockquote>
<p>2019-09-11 更新：又 GG 了，把<code>sim*</code>, <code>ms*</code>字体复制到 wine 的 Fonts 目录，解决。</p>
<h3 id="winecfg"><a class="markdownIt-Anchor" href="#winecfg"></a> winecfg</h3>
<p>如果是 QQ 用下面的命令执行 WINEPREFIX=~/.deepinwine/Deepin-QQ deepin-wine winecfg 其他应用修改 WINEPREFIX 的值就好了。</p>
<h3 id="wine-qq-tim"><a class="markdownIt-Anchor" href="#wine-qq-tim"></a> <a href="https://github.com/askme765cs/Wine-QQ-TIM" target="_blank" rel="noopener">Wine-QQ-TIM</a></h3>
<p>提供在 Linux 上运行最新版腾讯 QQ 与 TIM 的解决方案 Easiest Way to Run QQ&amp;TIM on Linux</p>
<h2 id="ubuntu-镜像源-channel-之间的关系"><a class="markdownIt-Anchor" href="#ubuntu-镜像源-channel-之间的关系"></a> Ubuntu 镜像源 channel 之间的关系</h2>
<p><a href="https://help.ubuntu.com/community/UbuntuUpdates" target="_blank" rel="noopener">ubuntu</a> 官方说明</p>
<h3 id="proposed-updates"><a class="markdownIt-Anchor" href="#proposed-updates"></a> Proposed updates</h3>
<p>IconsPage/stop.png</p>
<p><mark>Enabling the proposed updates repository can break your system. It is not recommended for inexperienced users.</mark></p>
<p>The proposed updates are updates which are waiting to be moved into the recommended updates queue after some testing. They may never reach recommended or they may be replaced with a more recent update.</p>
<p>Enabling this is reasonable if you want to participate in testing minor updates, or know that your specific problem has been solved here but the package hasn’t reached recommended yet.</p>
<p>即<code>proposed</code>为测试版，尽量不要开启。在安装<code>deepin-wine</code>的过程中发现因为以前开过<code>proposed</code>，把一下包升级到了较高版本（amd64），在安装相应的 i386 包的时候就不得不使用<code>proposed</code>，否则会找不到依赖。因此以后慎用这个仓库。</p>
<p>尝试 <a href="http://www.webupd8.org/2013/11/how-to-downgrade-proposed-repository.html" target="_blank" rel="noopener">降级</a> 成功</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>CentOS</tag>
      </tags>
  </entry>
</search>
